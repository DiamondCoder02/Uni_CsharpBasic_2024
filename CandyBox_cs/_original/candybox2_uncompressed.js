/**
 *
 * @source: http://candybox2.github.io/candybox2_uncompressed.js
 *
 * @licstart  The following is the entire license notice for the 
 *  JavaScript code in this page.
 *
 * Copyright (C) 2012 David "aniwey" L.
 *
 *
 * The JavaScript code in this page is free software: you can
 * redistribute it and/or modify it under the terms of the GNU
 * General Public License (GNU GPL) as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option)
 * any later version.  The code is distributed WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.
 *
 * As additional permission under GNU GPL version 3 section 7, you
 * may distribute non-source (e.g., minimized or compacted) forms of
 * that code without the copy of the GNU GPL normally required by
 * section 4, provided you include this license notice and a URL
 * through which recipients can access the Corresponding Source.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in this page.
 *
 */

var Place = (function () {
    // Constructor
    function Place(game) {
        this.game = game;
    }
    // Public methods
    Place.prototype.addBackToButton = function (renderArea, callbackCollection, text, translated, otherClass, y, x) {
        if (y === void 0) { y = 0; }
        if (x === void 0) { x = -1; }
        // If the x position is under zero, we set it so that the button will be centered
        if (x < 0) {
            x = renderArea.getWidth() / 2 - text.length / 2;
        }
        renderArea.addAsciiRealButton(text, x, y, otherClass, translated, true);
        renderArea.addLinkCall("." + otherClass, callbackCollection);
    };
    Place.prototype.addBackToMainMapButton = function (renderArea, otherClass, textName) {
        if (textName === void 0) { textName = "buttonBackToTheMap"; }
        this.addBackToButton(renderArea, new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), Database.getText(textName), Database.getTranslatedText(textName), otherClass);
    };
    // Public getters
    Place.prototype.getDefaultScroll = function () {
        return 0;
    };
    Place.prototype.getGame = function () {
        return this.game;
    };
    Place.prototype.getGap = function () {
        return 0;
    };
    Place.prototype.getRenderArea = function () {
        return new RenderArea(); // We return a new render area, but this should not happen, since our daughter class should override this function
    };
    Place.prototype.getScrolling = function () {
        return false; // By default, we disable scrolling on the place
    };
    Place.prototype.willBeClosed = function () { };
    Place.prototype.willBeDisplayed = function () { };
    Place.prototype.willStopBeingDisplayed = function () { };
    return Place;
})();
var Saving;
(function (Saving) {
    // Saving maps
    var bools = {};
    var numbers = {};
    var strings = {};
    // Can we register?
    Saving.canRegister = true;
    // Special public functions : used to load or the actual save
    function load(game, loadingType, loadingString) {
        // Depending on the loading type, do different things
        switch (loadingType) {
            // We don't load anything
            case MainLoadingType.NONE:
                // You can uncomment the lines below to start your game with everything unlocked (useful for testing purposes)
                /*
                Saving.saveNumber("aTreeStep", 2);
                
                Saving.saveBool("mainMapDoneDesert", true);
                Saving.saveBool("mainMapDoneBridge", true);
                Saving.saveBool("mainMapDoneCaveEntrance", true);
                Saving.saveBool("mainMapDonePier", true);
                Saving.saveBool("mainMapDoneForest", true);
                Saving.saveBool("mainMapDoneCastleEntrance", true);
                
                Saving.saveBool("gridItemPossessedMainMap", true);
                Saving.saveBool("gridItemPossessedTimeRing", true);
                Saving.saveBool("gridItemPossessedThirdHouseKey", true);
                Saving.saveBool("gridItemPossessedBeginnersGrimoire", true);
                
                Saving.saveBool("gridItemPossessedFeather", true);
                Saving.saveBool("gridItemPossessedPogoStick", true);
                Saving.saveBool("gridItemPossessedHeartPlug", true);
                Saving.saveBool("gridItemPossessedAdvancedGrimoire", true);
                
                Saving.saveBool("gridItemPossessedSponge", true);
                Saving.saveBool("gridItemPossessedShellPowder", true);
                Saving.saveBool("gridItemPossessedHeartPendant", true);
                Saving.saveBool("gridItemPossessedBlackMagicGrimoire", true);
                
                Saving.saveBool("gridItemPossessedFortressKey", true);
                Saving.saveBool("gridItemPossessedUnicornHorn", true);
                Saving.saveBool("gridItemPossessedXinopherydonClaw", true);
                Saving.saveBool("gridItemPossessedPitchfork", true);
                
                Saving.saveBool("gridItemPossessedRedSharkFin", true);
                Saving.saveBool("gridItemPossessedGreenSharkFin", true);
                Saving.saveBool("gridItemPossessedPurpleSharkFin", true);
                
                Saving.saveBool("gridItemPossessedTalkingCandy", true);
                
                Saving.saveBool("gridItemPossessedP", true);
                Saving.saveBool("gridItemPossessedL", true);
                Saving.saveBool("gridItemPossessedA", true);
                Saving.saveBool("gridItemPossessedY", true);
                
                Saving.saveBool("eqItemGlovesRedEnchantedGloves", true);
                Saving.saveBool("eqItemGlovesPinkEnchantedGloves", true);
                //Saving.saveBool("eqItemWeaponWoodenSword", true);
                Saving.saveBool("eqItemWeaponTrollBludgeon", true);
                Saving.saveBool("eqItemWeaponTribalSpear", true);
                Saving.saveBool("eqItemWeaponSummoningTribalSpear", true);
                Saving.saveBool("eqItemWeaponMonkeyWizardStaff", true);
                Saving.saveBool("eqItemWeaponGiantSpoon", true);
                Saving.saveBool("eqItemHatOctopusKingCrown", true);
                
                Saving.saveBool("eqItemBootsBootsOfIntrospection", true);
                
                Saving.saveBool("eqItemBootsRocketBoots", true);
                
                Saving.saveBool("eqItemWeaponGiantSpoonOfDoom", true);
                
                Saving.saveBool("eqItemBodyArmoursEnchantedKnightBodyArmour", true);
                
                Saving.saveNumber("gameCandiesEatenCurrent", 500000000);
                Saving.saveNumber("gameCandiesEatenMax", 500000000);
                
                Saving.saveNumber("playerHp", 1000);
                
                Saving.saveBool("questPlayerSpellHealthPotionHasSpell", true);
                Saving.saveBool("questPlayerSpellTurtlePotionHasSpell", true);
                Saving.saveBool("questPlayerSpellAntiGravityPotionHasSpell", true);
                Saving.saveBool("questPlayerSpellBerserkPotionHasSpell", true);
                Saving.saveBool("questPlayerSpellCloningPotionHasSpell", true);
                Saving.saveBool("questPlayerSpellPPotionHasSpell", true);
                Saving.saveBool("questPlayerSpellXPotionHasSpell", true);
                
                Saving.saveNumber("questPlayerSpellHealthPotionQuantity", 0);
                Saving.saveNumber("questPlayerSpellTurtlePotionQuantity", 64084);
                Saving.saveNumber("questPlayerSpellAntiGravityPotionQuantity", 47542);
                Saving.saveNumber("questPlayerSpellBerserkPotionQuantity", 99549);
                Saving.saveNumber("questPlayerSpellCloningPotionQuantity", 10050);
                Saving.saveNumber("questPlayerSpellPPotionQuantity", 10085250);
                Saving.saveNumber("questPlayerSpellXPotionQuantity", 10050999);
                
                //Saving.saveBool("gameDebug", true);
                
                Saving.saveNumber("gameCandiesCurrent", 5000000);
                Saving.saveNumber("gameCandiesMax", 5000000);
                
                Saving.saveNumber("gameLollipopsCurrent", 5000000000);
                Saving.saveNumber("gameLollipopsMax", 500000000000);
                
                Saving.saveNumber("gameChocolateBarsCurrent", 7);
                Saving.saveNumber("gameChocolateBarsMax", 7);
                
                Saving.saveNumber("gamePainsAuChocolatCurrent", 7);
                Saving.saveNumber("gamePainsAuChocolatMax", 7);
                
                Saving.saveBool("lonelyHouseTakeTheBoxDone", true);
                
                Saving.saveNumber("lollipopFarmPondHowManyLolligators", 0);
                
                Saving.saveBool("statusBarUnlocked", true);
                Saving.saveBool("statusBarUnlockedCfg", true);
                Saving.saveBool("statusBarUnlockedSave", true);
                Saving.saveBool("statusBarUnlockedMap", true);
                Saving.saveBool("statusBarUnlockedInventory", true);
                Saving.saveBool("statusBarUnlockedLollipopFarm", true);
                Saving.saveBool("statusBarUnlockedCauldron", true);
                Saving.saveBool("statusBarUnlockedHealthBar", true);
                Saving.saveBool("statusBarUnlockedInsideYourBox", true);
                Saving.saveBool("statusBarUnlockedTheComputer", true);
                Saving.saveBool("statusBarUnlockedTheArena", true);
                
                Saving.saveBool("castleKilledNougatMonster", true);
                
                Saving.saveBool("dragonDone", true);
                Saving.saveBool("dragonUnlockedCyclops", true);
                
                Saving.saveBool("castleTowerFirstVisitDone", true);
                
                Saving.saveString("gameLanguage", "fr");
                */
                break;
            case MainLoadingType.LOCAL:
                LocalSaving.load(loadingString);
                break;
            case MainLoadingType.FILE:
                var fileBools = loadingString.match(/bool +[a-zA-Z0-9_]+ *= *[a-zA-Z0-9_]+/g);
                var fileNumbers = loadingString.match(/number +[a-zA-Z0-9_]+ *= *[a-zA-Z0-9_]+/g);
                var fileStrings = loadingString.match(/string +[a-zA-Z0-9_]+ *= *[a-zA-Z0-9_]+/g);
                // Load the bools
                if (fileBools != null) {
                    for (var i = 0; i < fileBools.length; i++) {
                        Saving.saveBool(fileBools[i].match(/[a-zA-Z0-9_]+=/)[0].replace("=", ""), Saving.stringToBool(fileBools[i].match(/=[a-zA-Z0-9_]+/)[0].replace("=", "")));
                    }
                }
                // Load the numbers
                if (fileNumbers != null) {
                    for (var i = 0; i < fileNumbers.length; i++) {
                        Saving.saveNumber(fileNumbers[i].match(/[a-zA-Z0-9_]+=/)[0].replace("=", ""), Saving.stringToNumber(fileNumbers[i].match(/=[a-zA-Z0-9_]+/)[0].replace("=", "")));
                    }
                }
                // Load the strings
                if (fileStrings != null) {
                    for (var i = 0; i < fileStrings.length; i++) {
                        Saving.saveString(fileStrings[i].match(/[a-zA-Z0-9_]+=/)[0].replace("=", ""), fileStrings[i].match(/=[a-zA-Z0-9_]+/)[0].replace("=", ""));
                    }
                }
                break;
        }
        // Apply the loaded variables to various things by calling the load() methods of various objects
        game.load(); // Various variables owned by the game object
        game.getPlayer().load(); // The player
    }
    Saving.load = load;
    function save(game, savingType, savingString) {
        // Save some special variables by calling the save() methods of various objects
        game.save(); // Various variables owned by the game object
        game.getPlayer().save(); // The player
        // Do different things depending on the saving type
        switch (savingType) {
            case MainLoadingType.LOCAL:
                return LocalSaving.save(savingString);
                break;
            case MainLoadingType.FILE:
                return false;
                break;
        }
    }
    Saving.save = save;
    // Public conversion functions (useful because we sometimes only want to store strings, either locally or online, but in fact we also work with numbers and bools)
    function boolToString(b) {
        if (b)
            return "true";
        return "false";
    }
    Saving.boolToString = boolToString;
    function numberToString(n) {
        return n.toString();
    }
    Saving.numberToString = numberToString;
    function stringToBool(s) {
        if (s == "true")
            return true;
        else if (s == "false")
            return false;
        console.log("Error : trying to convert a string to a bool but the string value is " + s + ".");
    }
    Saving.stringToBool = stringToBool;
    function stringToNumber(s) {
        return parseFloat(s); // We need to use parseFloat to avoid problems with scientific notations
    }
    Saving.stringToNumber = stringToNumber;
    // Public functions
    function getAllBools() {
        return bools;
    }
    Saving.getAllBools = getAllBools;
    function getAllNumbers() {
        return numbers;
    }
    Saving.getAllNumbers = getAllNumbers;
    function getAllStrings() {
        return strings;
    }
    Saving.getAllStrings = getAllStrings;
    function loadBool(key) {
        // BUGS
        if (Bugs.getUltimateBugLevel() >= 2)
            saveBool(key, Random.flipACoin());
        if (key in bools)
            return bools[key];
        console.log("Error : trying to load the unknown bool " + key + ".");
    }
    Saving.loadBool = loadBool;
    function loadNumber(key) {
        // BUGS
        if (Bugs.getUltimateBugLevel() >= 3 && Random.oneChanceOutOf(2))
            saveNumber(key, Random.between(0, 10000) - 5000);
        if (key in numbers)
            return numbers[key];
        console.log("Error : trying to load the unknown number " + key + ".");
    }
    Saving.loadNumber = loadNumber;
    function loadString(key) {
        // BUGS
        if (Bugs.getUltimateBugLevel() >= 4 && Random.oneChanceOutOf(5))
            saveString(key, "bug");
        if (key in strings)
            return strings[key];
        console.log("Error : trying to load the unknown string " + key + ".");
    }
    Saving.loadString = loadString;
    function registerBool(key, b) {
        if (Saving.canRegister) {
            if (key in bools || key in numbers || key in strings)
                console.log("Error : trying to register the key " + key + " as bool, but this key is already registered.");
            this.saveBool(key, b, true);
        }
    }
    Saving.registerBool = registerBool;
    function registerNumber(key, n) {
        if (Saving.canRegister) {
            if (key in numbers || key in bools || key in strings)
                console.log("Error : trying to register the key " + key + " as number, but this key is already registered.");
            this.saveNumber(key, n, true);
        }
    }
    Saving.registerNumber = registerNumber;
    function registerString(key, s) {
        if (Saving.canRegister) {
            if (key in strings || key in bools || key in numbers)
                console.log("Error : trying to register the key " + key + " as string, but this key is already registered.");
            this.saveString(key, s, true);
        }
    }
    Saving.registerString = registerString;
    function saveBool(key, b, registering) {
        if (registering === void 0) { registering = false; }
        if (key in bools || registering) {
            bools[key] = b;
            return;
        }
        console.log("Error : trying to save the unknown bool " + key + ".");
    }
    Saving.saveBool = saveBool;
    function saveNumber(key, n, registering) {
        if (registering === void 0) { registering = false; }
        if (key in numbers || registering) {
            numbers[key] = n;
            return;
        }
        console.log("Error : trying to save the unknown number " + key + ".");
    }
    Saving.saveNumber = saveNumber;
    function saveString(key, s, registering) {
        if (registering === void 0) { registering = false; }
        if (key in strings || registering) {
            strings[key] = s;
            return;
        }
        console.log("Error : trying to save the unknown string " + key + ".");
    }
    Saving.saveString = saveString;
})(Saving || (Saving = {}));
///<reference path="Place.ts"/>
///<reference path="Saving.ts"/>
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
Saving.registerNumber("aTreeStep", 0);
var ATree = (function (_super) {
    __extends(ATree, _super);
    // Constructor
    function ATree(game) {
        _super.call(this, game);
        // Render area
        this.renderArea = new RenderArea();
        // Special tic-tac-toa variables
        this.ticTacToeStep = null;
        this.ticTacToeBoard = null;
        // If we're going to play tic tac toe
        if (Saving.loadNumber("aTreeStep") == 7) {
            this.startTicTacToe();
        }
        // If we're at step 8 (just won the tic tac toe game), go on to step 9
        if (Saving.loadNumber("aTreeStep") == 8)
            this.nextStep();
        // Resize & update
        this.renderArea.resizeFromArray(Database.getAscii("places/aTree/background"), 17, 3);
        this.update();
    }
    // getRenderArea()
    ATree.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // Private methods
    ATree.prototype.addEnigma = function (enigmaAnswer, callbackCollection, otherClass, wrongClass, wrongMessage) {
        if (wrongClass === void 0) { wrongClass = ""; }
        if (wrongMessage === void 0) { wrongMessage = "Wrong"; }
        this.renderArea.addEnigma(21, 41, 24, enigmaAnswer, callbackCollection, otherClass, wrongClass, wrongMessage);
    };
    ATree.prototype.drawSpeech = function (normal, translated, x2) {
        if (x2 === void 0) { x2 = 59; }
        this.renderArea.drawSpeech(normal, 4, 38, x2, "aTreeSpeech", translated);
    };
    ATree.prototype.drawTicTacToeBoard = function (addButtons, x, y) {
        if (addButtons === void 0) { addButtons = true; }
        if (x === void 0) { x = 19; }
        if (y === void 0) { y = 23; }
        // If the board isn't null
        if (this.ticTacToeBoard != null) {
            // Draw the board background
            this.renderArea.drawArray(Database.getAscii("places/aTree/ticTacToeBoard"), x + 7, y + 5);
            // Iterate over the board to draw signs && add buttons
            for (var i = 0; i < 5; i++) {
                for (var j = 0; j < 5; j++) {
                    // Draw the sign or add the button, depending on the sign
                    switch (this.ticTacToeBoard[i][j]) {
                        // There's already a sign : draw the sign
                        case ATreeTicTacToeSign.X:
                            this.renderArea.drawArray(Database.getAscii("places/aTree/ticTacToeX"), x + i * 7 + 3, y + j * 4 + 3);
                            break;
                        case ATreeTicTacToeSign.O:
                            this.renderArea.drawArray(Database.getAscii("places/aTree/ticTacToeO"), x + i * 7 + 2, y + j * 4 + 2);
                            break;
                        // There's no sign yet : draw the button
                        case ATreeTicTacToeSign.NO_SIGN:
                            if (addButtons) {
                                // Iterate over the lines on which we need to add the buttons
                                for (var yButton = y + j * 4 + 1; yButton <= y + j * 4 + 4; yButton++) {
                                    // If we're outside the board : add a ninja button
                                    if (i == 0 || i == 4 || j == 0 || j == 4) {
                                        this.renderArea.addAsciiNinjaButton(x + i * 7 + 1, x + i * 7 + 7, yButton, "aTreeTicTacToeBoardButton" + i + "_" + j);
                                    }
                                    else {
                                        this.renderArea.addAsciiButton(x + i * 7 + 1, x + i * 7 + 7, yButton, "aTreeTicTacToeBoardButton" + i + "_" + j);
                                    }
                                }
                                // Add the link
                                this.renderArea.addLinkCall(".aTreeTicTacToeBoardButton" + i + "_" + j, new CallbackCollection(this.playTicTacToeSign.bind(this, i, j)));
                            }
                            break;
                    }
                }
            }
        }
    };
    ATree.prototype.nextStep = function () {
        // We change the step
        Saving.saveNumber("aTreeStep", Saving.loadNumber("aTreeStep") + 1);
        // We possibly do some action depending on the new step
        if (Saving.loadNumber("aTreeStep") == 7) {
            this.startTicTacToe();
        }
        if (Saving.loadNumber("aTreeStep") == 9) {
            this.getGame().gainItem("gridItemPossessedThirdHouseKey");
        }
        // We update
        this.update();
        this.getGame().updatePlace();
    };
    ATree.prototype.playTicTacToe_copyBoard = function (board) {
        // Create the new board
        var newBoard = [];
        // Copy the old one in the new one
        for (var i = 0; i < board.length; i++) {
            newBoard.push(board[i].slice(0));
        }
        // Return the new board
        return newBoard;
    };
    ATree.prototype.playTicTacToe_evaluateBoard = function (board) {
        // The score
        var score = 0;
        // Evaluate all the lines
        score += this.playTicTacToe_evaluateLine(board, 1, 1, 2, 1, 3, 1); // First column
        score += this.playTicTacToe_evaluateLine(board, 1, 2, 2, 2, 3, 2); // Second column
        score += this.playTicTacToe_evaluateLine(board, 1, 3, 2, 3, 3, 3); // Third column
        score += this.playTicTacToe_evaluateLine(board, 1, 1, 1, 2, 1, 3); // First row
        score += this.playTicTacToe_evaluateLine(board, 2, 1, 2, 2, 2, 3); // Second row
        score += this.playTicTacToe_evaluateLine(board, 3, 1, 3, 2, 3, 3); // Third row
        score += this.playTicTacToe_evaluateLine(board, 1, 1, 2, 2, 3, 3); // Diagonal
        score += this.playTicTacToe_evaluateLine(board, 1, 3, 2, 2, 3, 1); // The other diagonal
        // Return the score
        return score;
    };
    ATree.prototype.playTicTacToe_evaluateLine = function (board, row1, col1, row2, col2, row3, col3) {
        // The score
        var score = 0;
        // First cell
        if (board[row1][col1] == ATreeTicTacToeSign.O)
            score = 1;
        else if (board[row1][col1] == ATreeTicTacToeSign.X)
            score = -1;
        // Second cell
        if (board[row2][col2] == ATreeTicTacToeSign.O) {
            if (score == 1)
                score = 10;
            else if (score == -1)
                return 0;
            else
                score = 1;
        }
        else if (board[row2][col2] == ATreeTicTacToeSign.X) {
            if (score == 1)
                return 0;
            else if (score == -1)
                score = -10;
            else
                score = -1;
        }
        // Third cell
        if (board[row3][col3] == ATreeTicTacToeSign.O) {
            if (score > 0)
                score *= 10;
            else if (score < 0)
                return 0;
            else
                score = 1;
        }
        else if (board[row3][col3] == ATreeTicTacToeSign.X) {
            if (score > 0)
                return 0;
            else if (score < 0)
                score *= 10;
            else
                score = -1;
        }
        // Return the score
        return score;
    };
    ATree.prototype.playTicTacToe_minimax = function (board, playerSign, depth) {
        if (depth === void 0) { depth = 2; }
        // Variables
        var tempBoard; // The temp board, used to simulate moves
        var currentScore; // Current score, used for calculations
        var returnValue = new ATreeTicTacToeMinimaxReturnValue; // The return value, which contains the best position and the best score
        var gameFull = true; // Used later to find out if the game is full or not
        // Set the initial best score, depending on the playerSign parameter
        if (playerSign == ATreeTicTacToeSign.O)
            returnValue.bestScore = -99999999;
        else
            returnValue.bestScore = 99999999;
        // If the depth is > to 0 (this condition is needed to stop the iterating loop at some point)
        if (depth > 0) {
            // Iterate over all the board
            for (var i = 1; i <= 3; i++) {
                for (var j = 1; j <= 3; j++) {
                    // If this cell is empty
                    if (board[i][j] == ATreeTicTacToeSign.NO_SIGN) {
                        // We found at least one non-empty cell : the game isn't full
                        gameFull = false;
                        // Set the temp board from the real board
                        tempBoard = this.playTicTacToe_copyBoard(board);
                        // Try to play on this cell using the temp board
                        tempBoard[i][j] = playerSign;
                        if (playerSign == ATreeTicTacToeSign.O) {
                            currentScore = this.playTicTacToe_minimax(tempBoard, ATreeTicTacToeSign.X, depth - 1).bestScore;
                            if (returnValue.bestScore <= currentScore) {
                                returnValue.bestScore = currentScore;
                                returnValue.bestPosition = new Pos(i, j);
                            }
                        }
                        else {
                            currentScore = this.playTicTacToe_minimax(tempBoard, ATreeTicTacToeSign.O, depth - 1).bestScore;
                            if (returnValue.bestScore >= currentScore) {
                                returnValue.bestScore = currentScore;
                                returnValue.bestPosition = new Pos(i, j);
                            }
                        }
                    }
                }
            }
            // If the game seems full, we calculate the best score too
            if (gameFull)
                returnValue.bestScore = this.playTicTacToe_evaluateBoard(board);
        }
        else
            returnValue.bestScore = this.playTicTacToe_evaluateBoard(board);
        // Return the return value (best position found + the score)
        return returnValue;
    };
    ATree.prototype.playTicTacToe_testEndGameConditions = function () {
        // Variables
        var shouldEnd = false;
        // Test if someone won (in the 5*5 grid)
        switch (this.playTicTacToe_testGameSomeoneWon()) {
            case ATreeTicTacToeSign.O:
                this.ticTacToeStep = ATreeTicTacToeStep.YOU_LOSE;
                return true;
                break;
            case ATreeTicTacToeSign.X:
                // add object to the player here
                this.nextStep();
                return true;
                break;
        }
        // Test if the game is full (in the 3*3 grid)
        if (this.playTicTacToe_testGameFull()) {
            this.ticTacToeStep = ATreeTicTacToeStep.NOBODY_WINS;
            return true;
        }
        // Nothing happens, we return false
        return false;
    };
    ATree.prototype.playTicTacToe_testGameFull = function () {
        // Variables
        var isFull = true; // Will be set to false if there's any empty cell
        // Search for any empty cell
        for (var i = 1; i <= 3; i++) {
            for (var j = 1; j <= 3; j++) {
                if (this.ticTacToeBoard[i][j] == ATreeTicTacToeSign.NO_SIGN) {
                    isFull = false;
                    break;
                }
            }
            if (isFull == false)
                break;
        }
        // If the board is full, return true
        if (isFull)
            return true;
        // Else, return false
        return false;
    };
    ATree.prototype.playTicTacToe_testGameSomeoneWon = function () {
        // Variables
        var returnSign;
        for (var i = 0; i < 5; i++) {
            returnSign = this.playTicTacToe_fiveInARow(i, 0, 0, 1);
            if (returnSign != null)
                return returnSign;
        }
        for (var i = 0; i < 5; i++) {
            returnSign = this.playTicTacToe_fiveInARow(0, i, 1, 0);
            if (returnSign != null)
                return returnSign;
        }
        if ((returnSign = this.playTicTacToe_fiveInARow(0, 0, 1, 1)) != null)
            return returnSign;
        if ((returnSign = this.playTicTacToe_fiveInARow(0, 1, 1, 1)) != null)
            return returnSign;
        if ((returnSign = this.playTicTacToe_fiveInARow(1, 0, 1, 1)) != null)
            return returnSign;
        if ((returnSign = this.playTicTacToe_fiveInARow(0, 2, 1, 1)) != null)
            return returnSign;
        if ((returnSign = this.playTicTacToe_fiveInARow(2, 0, 1, 1)) != null)
            return returnSign;
        if ((returnSign = this.playTicTacToe_fiveInARow(4, 0, -1, 1)) != null)
            return returnSign;
        if ((returnSign = this.playTicTacToe_fiveInARow(3, 1, -1, 1)) != null)
            return returnSign;
        if ((returnSign = this.playTicTacToe_fiveInARow(3, 0, -1, 1)) != null)
            return returnSign;
        if ((returnSign = this.playTicTacToe_fiveInARow(4, 2, -1, 1)) != null)
            return returnSign;
        if ((returnSign = this.playTicTacToe_fiveInARow(2, 0, -1, 1)) != null)
            return returnSign;
        // No won won, we return NO_SIGN
        return ATreeTicTacToeSign.NO_SIGN;
    };
    ATree.prototype.playTicTacToe_fiveInARow = function (x1, y1, x2, y2) {
        // Variables
        var column = x1;
        var row = y1;
        var counter = 0;
        var currentSign = null;
        while (column >= 0 && column < 5 && row >= 0 && row < 5) {
            if (this.ticTacToeBoard[column][row] != ATreeTicTacToeSign.NO_SIGN) {
                if (this.ticTacToeBoard[column][row] != currentSign) {
                    currentSign = this.ticTacToeBoard[column][row];
                    counter = 1;
                }
                else
                    counter++;
            }
            else
                counter = 0;
            if (currentSign != null && counter == 3)
                return currentSign;
            column += x2;
            row += y2;
        }
        return null;
    };
    ATree.prototype.playTicTacToe_tryAgain = function () {
        this.startTicTacToe();
        this.update();
        this.getGame().updatePlace();
    };
    ATree.prototype.playTicTacToeSign = function (xIndex, yIndex) {
        // Add the sign
        this.ticTacToeBoard[xIndex][yIndex] = ATreeTicTacToeSign.X;
        // Test end game conditions (we only make the squirrel play if nothing happens)
        if (this.playTicTacToe_testEndGameConditions() == false) {
            // IA
            var bestPosition = this.playTicTacToe_minimax(this.ticTacToeBoard, ATreeTicTacToeSign.O).bestPosition;
            this.ticTacToeBoard[bestPosition.x][bestPosition.y] = ATreeTicTacToeSign.O;
            // Test end game conditions
            this.playTicTacToe_testEndGameConditions();
        }
        // Update
        this.update();
        this.getGame().updatePlace();
    };
    ATree.prototype.reward1 = function () {
        this.getGame().getCandies().add(20);
    };
    ATree.prototype.reward2 = function () {
        this.getGame().getCandies().add(100);
    };
    ATree.prototype.reward3 = function () {
        this.getGame().getCandies().add(500);
    };
    ATree.prototype.reward4 = function () {
        this.getGame().getLollipops().add(3);
    };
    ATree.prototype.reward5 = function () {
        this.getGame().getChocolateBars().add(3);
    };
    ATree.prototype.startTicTacToe = function () {
        // Reset the array
        this.ticTacToeBoard = [];
        // Add the signs to the board
        for (var i = 0; i < 5; i++) {
            this.ticTacToeBoard.push([]);
            for (var j = 0; j < 5; j++) {
                this.ticTacToeBoard[i].push(ATreeTicTacToeSign.NO_SIGN);
            }
        }
        // Set the step
        this.ticTacToeStep = ATreeTicTacToeStep.PLAYING;
    };
    ATree.prototype.update = function () {
        // Erase everything
        this.renderArea.resetAllButSize();
        // Back to the map button
        this.addBackToMainMapButton(this.renderArea, "aTreeBackToTheMapButton");
        // Draw the tree with the squirrel
        this.renderArea.drawArray(Database.getAscii("places/aTree/background"), 0, 3);
        // Draw the speech
        switch (Saving.loadNumber("aTreeStep")) {
            // Introduction speech
            case 0:
                this.drawSpeech(Database.getText("mapATreeIntroductionSpeech"), Database.getTranslatedText("mapATreeIntroductionSpeech"));
                this.renderArea.addAsciiRealButton(Database.getText("mapATreeIntroductionButton"), 21, 24, "aTreeIntroductionButton", Database.getTranslatedText("mapATreeIntroductionButton"));
                this.renderArea.addLinkCall(".aTreeIntroductionButton", new CallbackCollection(this.nextStep.bind(this)));
                break;
            // First question (do you like candies)
            case 1:
                this.drawSpeech(Database.getText("mapATreeFirstQuestion"), Database.getTranslatedText("mapATreeFirstQuestion"));
                this.addEnigma(new EnigmaAnswerStrings(["yes", "y", "yeah", "yeap", "yep"]), new CallbackCollection(this.nextStep.bind(this), this.reward1.bind(this)), "aTreeFirstQuestionEnigma", "aTreeFirstQuestionWrong");
                break;
            // Second question (S E I D N A ?)
            case 2:
                this.drawSpeech(Database.getText("mapATreeSecondQuestion"), Database.getTranslatedText("mapATreeSecondQuestion"));
                this.addEnigma(new EnigmaAnswerStrings(["c", "letterc", "theletterc"]), new CallbackCollection(this.nextStep.bind(this), this.reward2.bind(this)), "aTreeSecondQuestionEnigma", "aTreeSecondQuestionWrong");
                break;
            // Third question (how many candies does the candiest man in the world possess?)
            case 3:
                this.drawSpeech(Database.getText("mapATreeThirdQuestion"), Database.getTranslatedText("mapATreeThirdQuestion"));
                this.addEnigma(new EnigmaAnswerCandies(this.getGame()), new CallbackCollection(this.nextStep.bind(this), this.reward3.bind(this)), "aTreeThirdQuestionEnigma", "aTreeThirdQuestionWrong");
                break;
            // Fourth question (number of marks on the tree)
            case 4:
                this.drawSpeech(Database.getText("mapATreeFourthQuestion"), Database.getTranslatedText("mapATreeFourthQuestion"), 75);
                this.addEnigma(new EnigmaAnswerStrings(["10", "ten", "10marks", "tenmarks"]), new CallbackCollection(this.nextStep.bind(this), this.reward4.bind(this)), "aTreeFourthQuestionEnigma", "aTreeFourthQuestionWrong");
                break;
            // Fifth question (yellow hat in the red sea)
            case 5:
                this.drawSpeech(Database.getText("mapATreeFifthQuestion"), Database.getTranslatedText("mapATreeFifthQuestion"), 75);
                this.addEnigma(new EnigmaAnswerStrings(["wet", "itbecomeswet", "itbecomewet", "becomeswet", "becomewet", "itgetswet", "itgetwet", "itswet", "itgotwet", "itiswet", "itiswetnow", "itswetnow", "float", "floats", "itfloats", "itsfloating", "itisfloating", "floating", "itfloat"]), new CallbackCollection(this.nextStep.bind(this), this.reward5.bind(this)), "aTreeFifthQuestionEnigma", "aTreeFifthQuestionWrong");
                break;
            // Sixth question (tic-tac-toe) : intro speech
            case 6:
                // Draw the speech
                this.drawSpeech(Database.getText("mapATreeTicTacToeIntro"), Database.getTranslatedText("mapATreeTicTacToeIntro"), 75);
                // Add the button to go to the next step
                this.renderArea.addAsciiRealButton(Database.getText("mapATreeTicTacToeIntroButton"), 21, 24, "mapATreeTicTacToeIntroButton", Database.getTranslatedText("mapATreeTicTacToeIntroButton"));
                this.renderArea.addLinkCall(".mapATreeTicTacToeIntroButton", new CallbackCollection(this.nextStep.bind(this)));
                break;
            case 7:
                // Draw different things depending on the tic-tac-toa step
                switch (this.ticTacToeStep) {
                    case ATreeTicTacToeStep.PLAYING:
                        this.drawSpeech(Database.getText("mapATreeTicTacToeLetsPlay"), Database.getTranslatedText("mapATreeTicTacToeLetsPlay"), 75); // Speech
                        this.drawTicTacToeBoard(); // Board
                        break;
                    case ATreeTicTacToeStep.NOBODY_WINS:
                        this.drawSpeech(Database.getText("mapATreeTicTacToeNobodyWins"), Database.getTranslatedText("mapATreeTicTacToeNobodyWins"), 75); // Speech
                        this.drawTicTacToeBoard(false); // Board
                        break;
                    case ATreeTicTacToeStep.YOU_LOSE:
                        this.drawSpeech(Database.getText("mapATreeTicTacToeYouLose"), Database.getTranslatedText("mapATreeTicTacToeYouLose"), 75); // Speech
                        this.drawTicTacToeBoard(false); // Board
                        break;
                }
                // If was just had a draw / lose, add the button to try again
                if (this.ticTacToeStep == ATreeTicTacToeStep.NOBODY_WINS || this.ticTacToeStep == ATreeTicTacToeStep.YOU_LOSE) {
                    this.renderArea.addAsciiRealButton(Database.getText("mapATreeTicTacToeTryAgainButton"), 21, 24, "mapATreeTicTacToeTryAgainButton", Database.getTranslatedText("mapATreeTicTacToeTryAgainButton"));
                    this.renderArea.addLinkCall(".mapATreeTicTacToeTryAgainButton", new CallbackCollection(this.playTicTacToe_tryAgain.bind(this)));
                }
                break;
            case 8:
                this.drawSpeech(Database.getText("mapATreeTicTacToeYouWin"), Database.getTranslatedText("mapATreeTicTacToeYouWin"), 75); // Speech
                this.drawTicTacToeBoard(false); // Board
                // Button
                this.renderArea.addAsciiRealButton(Database.getText("mapATreeTicTacToeAnymoreSweet"), 21, 24, "mapATreeTicTacToeAnymoreSweet", Database.getTranslatedText("mapATreeTicTacToeAnymoreSweet"), true);
                this.renderArea.addLinkCall(".mapATreeTicTacToeAnymoreSweet", new CallbackCollection(this.nextStep.bind(this)));
                break;
            case 9:
                this.drawSpeech(Database.getText("mapATreeNoMoreChallenge"), Database.getTranslatedText("mapATreeNoMoreChallenge"));
                break;
        }
    };
    return ATree;
})(Place);
var ATreeTicTacToeMinimaxReturnValue = (function () {
    function ATreeTicTacToeMinimaxReturnValue() {
        this.bestPosition = null;
        this.bestScore = null;
    }
    return ATreeTicTacToeMinimaxReturnValue;
})();
var ATreeTicTacToeSign;
(function (ATreeTicTacToeSign) {
    ATreeTicTacToeSign[ATreeTicTacToeSign["NO_SIGN"] = 0] = "NO_SIGN";
    ATreeTicTacToeSign[ATreeTicTacToeSign["X"] = 1] = "X";
    ATreeTicTacToeSign[ATreeTicTacToeSign["O"] = 2] = "O";
})(ATreeTicTacToeSign || (ATreeTicTacToeSign = {}));
var ATreeTicTacToeStep;
(function (ATreeTicTacToeStep) {
    ATreeTicTacToeStep[ATreeTicTacToeStep["PLAYING"] = 0] = "PLAYING";
    ATreeTicTacToeStep[ATreeTicTacToeStep["NOBODY_WINS"] = 1] = "NOBODY_WINS";
    ATreeTicTacToeStep[ATreeTicTacToeStep["YOU_LOSE"] = 2] = "YOU_LOSE";
})(ATreeTicTacToeStep || (ATreeTicTacToeStep = {}));
// N.B. : the case when the player wins isn't in this enumeration because this case is a new aTreeStep and is therefore handled by the global saving system 
var Algo;
(function (Algo) {
    // Return 0 is the number given is under 0, else return the number given
    function correctIfUnderZero(n) {
        if (n < 0)
            return 0;
        return n;
    }
    Algo.correctIfUnderZero = correctIfUnderZero;
    // Return the maximum value a javascript Number can get before loosing precision
    function getMaximumJavascriptInt() {
        return 9007199254740992; // 2^53
    }
    Algo.getMaximumJavascriptInt = getMaximumJavascriptInt;
    // Return a Pos object corresponding to a direction
    // x and y values can be between -a and a, but they can't both be 0
    function getRandomNotImmobileDirectionUpToThisSpeed(a) {
        var pos = new Pos();
        // Set x and y
        pos.x = Random.between(-a, a);
        if (pos.x != 0)
            pos.y = Random.between(-a, a);
        else {
            // x is 0, so y can't be 0 : we pick positive or negative randomly
            if (Random.flipACoin())
                pos.y = Random.between(-a, -1);
            else
                pos.y = Random.between(1, a);
        }
        // We possibly invert x and y because since x is treated first, basically it has more chance than y to be 0
        if (Random.flipACoin())
            pos.invert();
        // We return the position
        return pos;
    }
    Algo.getRandomNotImmobileDirectionUpToThisSpeed = getRandomNotImmobileDirectionUpToThisSpeed;
    // Add the html <u> tag around the specified letter in the string given, and return the resulting string
    function makeUnderlinedLetter(s, underlinedLetter) {
        if (underlinedLetter != -1)
            return s.slice(0, underlinedLetter) + "<u>" + s.charAt(underlinedLetter) + "</u>" + s.slice(underlinedLetter + 1, s.length);
        else
            return s;
    }
    Algo.makeUnderlinedLetter = makeUnderlinedLetter;
    // Transform a number in a string and add whitespaces every three figures
    function numberToStringButNicely(n) {
        // We store the number as a string in the variable str
        var str = n.toString();
        // If the number isn't going to loose precision because it's too big, we add whitespaces every three characters
        if (n < getMaximumJavascriptInt()) {
            // If the var is bigger than 3 characters
            if (str.length > 3) {
                for (var i = Math.floor(str.length / 3); i > 0; i--) {
                    if (i * 3 != str.length)
                        str = str.addAt(str.length - i * 3, " ");
                }
            }
        }
        // Return str
        return str;
    }
    Algo.numberToStringButNicely = numberToStringButNicely;
    // Create a string from a number and a word added depending on the plurality of the number
    function pluralFormat(n, singular, plural) {
        if (n == 1)
            return n.toString() + singular;
        return n.toString() + plural;
    }
    Algo.pluralFormat = pluralFormat;
    // Create a string from a number and a word added depending on the plurality of the number (and format the number nicely)
    function pluralFormatNicely(n, singular, plural) {
        if (n == 1)
            return numberToStringButNicely(n) + singular;
        return numberToStringButNicely(n) + plural;
    }
    Algo.pluralFormatNicely = pluralFormatNicely;
    // Remove all special characters from a string, only let lower-case letters
    function simplifyString(s) {
        return s.toLowerCase().replace(/[^\w]|_/g, "");
    }
    Algo.simplifyString = simplifyString;
    // Return the biggest number between two numbers
    function takeBiggest(a, b) {
        if (a > b)
            return a;
        return b;
    }
    Algo.takeBiggest = takeBiggest;
})(Algo || (Algo = {}));
var BarType;
(function (BarType) {
    BarType[BarType["SIMPLE"] = 0] = "SIMPLE";
    BarType[BarType["HEALTH"] = 1] = "HEALTH";
    BarType[BarType["UNICOLOR_HEALTH"] = 2] = "UNICOLOR_HEALTH";
})(BarType || (BarType = {}));
///<reference path="./../../libs/jquery.d.ts"/>
var RenderLink = (function () {
    // Constructor
    function RenderLink() {
    }
    // Public methods
    RenderLink.prototype.run = function () {
    };
    return RenderLink;
})();
var RenderTag = (function () {
    // Constructor
    function RenderTag(x, tagString) {
        this.x = x;
        this.tagString = tagString;
    }
    // Public methods
    RenderTag.prototype.clone = function () {
        return new RenderTag(this.x, this.tagString);
    };
    RenderTag.prototype.draw = function (str) {
        return str.addAt(this.x, this.tagString);
    };
    // Public getters
    RenderTag.prototype.getString = function () {
        return this.tagString;
    };
    RenderTag.prototype.getX = function () {
        return this.x;
    };
    // Public setters
    RenderTag.prototype.setX = function (x) {
        this.x = x;
        return this;
    };
    return RenderTag;
})();
String.prototype.addAt = function (index, text) {
    return this.substr(0, index) + text + this.substr(index);
};
String.prototype.addChineseSpaces = function () {
    var newStr = "";
    for (var i = 0; i < Math.floor(this.length / 3); i++) {
        newStr += " ";
    }
    newStr += this;
    for (var i = 0; i < Math.floor(this.length / 3); i++) {
        newStr += " ";
    }
    return newStr;
};
String.prototype.fillWith = function (characters, howMuch) {
    var str = "";
    for (var i = 0; i < howMuch; i++) {
        str += characters;
    }
    return this.concat(str);
};
String.prototype.replaceAt = function (index, text) {
    return this.substr(0, index) + text + this.substr(index + text.length);
};
///<reference path="RenderLink.ts"/>
///<reference path="RenderTag.ts"/>
///<reference path="string_prototype.ts"/>
var RenderArea = (function () {
    // Constructor : by default, it creates en empty drawing area
    function RenderArea(width, height, character) {
        if (width === void 0) { width = 0; }
        if (height === void 0) { height = 0; }
        if (character === void 0) { character = " "; }
        this.area = []; // Array of strings
        this.width = 0; // Width of the area = length of the strings
        this.height = 0; // Height of the area = number of strings
        this.tags = []; // Array of array of tags
        this.links = []; // Array of links
        this.resize(width, height, character);
    }
    // Public methods
    RenderArea.prototype.addAsciiButton = function (x1, x2, y, otherClass) {
        if (otherClass === void 0) { otherClass = ""; }
        return this.addTwoTags(x1, x2, y, "<span class=\"asciiButton " + otherClass + "\">", "</span>");
    };
    RenderArea.prototype.addAsciiNinjaButton = function (x1, x2, y, otherClass) {
        if (otherClass === void 0) { otherClass = ""; }
        return this.addTwoTags(x1, x2, y, "<span class=\"asciiNinjaButton " + otherClass + "\">", "</span>");
    };
    RenderArea.prototype.addAsciiRealButton = function (str, x, y, otherClass, comment, commentBelow, underlinedLetter, color, commentCentered, commentRightAligned) {
        if (otherClass === void 0) { otherClass = ""; }
        if (comment === void 0) { comment = ""; }
        if (commentBelow === void 0) { commentBelow = false; }
        if (underlinedLetter === void 0) { underlinedLetter = -1; }
        if (color === void 0) { color = null; }
        if (commentCentered === void 0) { commentCentered = true; }
        if (commentRightAligned === void 0) { commentRightAligned = false; }
        // Add the button
        if (this.addTag(new RenderTag(x, "<span class=\"aroundRealButton\"><span class=\"asciiRealButton " + otherClass + "\"" + (color == null ? "" : " style=\"background-color:" + color.getColorString() + ";\"") + ">" + Algo.makeUnderlinedLetter(str, underlinedLetter) + "</span></span>"), y) == false)
            return false;
        // Add the comment
        if (comment != "") {
            var commentX;
            var commentY;
            // If the comment should be on the right
            if (commentBelow == false) {
                commentX = x + str.length + 2;
                commentY = y;
            }
            else {
                if (commentCentered)
                    commentX = Algo.correctIfUnderZero(x + str.length / 2 - comment.length / 2);
                else if (commentRightAligned == false)
                    commentX = x;
                else
                    commentX = x + (str.length - comment.length);
                commentY = y + 1;
            }
            if (this.drawString(comment, commentX, commentY) == false)
                return false;
            if (this.addTwoTags(commentX, commentX + comment.length, commentY, "<span class=\"translated\">", "</span>") == false)
                return false;
        }
        return true;
    };
    RenderArea.prototype.addBackgroundColor = function (x1, x2, y, color) {
        return this.addTwoTags(x1, x2, y, "<span style=\"background-color:" + color.getColorString() + "\">", "</span>");
    };
    RenderArea.prototype.addBold = function (x1, x2, y) {
        return this.addTwoTags(x1, x2, y, "<b>", "</b>");
    };
    RenderArea.prototype.addCheckbox = function (x, y, callbackCollectionWhenChecked, callbackCollectionWhenUnchecked, otherClass, checkedByDefault) {
        if (checkedByDefault === void 0) { checkedByDefault = false; }
        this.addTag(new RenderTag(x, "<span class=\"aroundCheckbox\"><input type=\"checkbox\" class=\"asciiCheckbox " + otherClass + "\"" + (checkedByDefault ? "checked" : "") + "></span>"), y);
        this.addLinkCheckbox("." + otherClass, callbackCollectionWhenChecked, callbackCollectionWhenUnchecked);
    };
    RenderArea.prototype.addColor = function (x1, x2, y, color) {
        return this.addTwoTags(x1, x2, y, "<span style=\"color:" + color.getColorString() + "\">", "</span>");
    };
    RenderArea.prototype.addComment = function (x, y, text, otherClass) {
        return this.addTag(new RenderTag(x, "<span class=\"aroundComment " + otherClass + "\"><span class=\"comment englishComment\">" + text + "</span></span>"), y);
    };
    RenderArea.prototype.addEnigma = function (x1, x2, y, enigmaAnswer, callbackCollection, otherClass, wrongClass, wrongMessage) {
        if (wrongClass === void 0) { wrongClass = null; }
        if (wrongMessage === void 0) { wrongMessage = "Wrong"; }
        this.addTag(new RenderTag(x1, "<span class=\"aroundTextInput\"><input type=\"text\" class=\"asciiTextInput noHotkeys " + otherClass + "\" style=\"width:" + (x2 - x1).toString() + "ex\"></span>"), y);
        // If there should be a wrong message
        if (wrongClass != null) {
            // We add the wrong message
            this.drawString(wrongMessage, x1, y + 2);
            this.addTwoTags(x1, x1 + wrongMessage.length, y + 2, "<span class=\"enigmaWrongMessage " + wrongClass + "\">", "</span>");
            // We add the link input which will also display the wrong message if needed
            this.addLinkInput("." + otherClass, enigmaAnswer, callbackCollection, new CallbackCollection(function () {
                // We make the element visible
                $("." + wrongClass).css("visibility", "visible");
                // We add a timeout to hide it soon
                window.setTimeout(function () {
                    $("." + wrongClass).css("visibility", "hidden");
                }, 1000);
            }));
        }
        else {
            // We add a simple link input
            this.addLinkInput("." + otherClass, enigmaAnswer, callbackCollection, new CallbackCollection());
        }
    };
    RenderArea.prototype.addFullComment = function (x, y, english, translated, otherClass) {
        if (this.addComment(Algo.correctIfUnderZero(x - (english.length / 2)), y, english, otherClass) == false)
            return false;
        else
            return this.addTranslatedComment(Algo.correctIfUnderZero(x - (translated.length / 2)), y + 1, translated, otherClass);
    };
    RenderArea.prototype.addHiddenClass = function (x1, x2, y, className) {
        return this.addTwoTags(x1, x2, y, "<span visibility=\"hidden\" class=\"" + className + "\">", "</span>");
    };
    RenderArea.prototype.addHtmlLink = function (x, y, url, text) {
        this.drawString(text, x, y);
        this.addTwoTags(x, x + text.length, y, "<a target=\"_blank\" href=\"" + url + "\">", "</a>");
    };
    RenderArea.prototype.addLinkCall = function (e, callbackCollection) {
        this.links.push(new RenderLinkClick(e, callbackCollection));
    };
    RenderArea.prototype.addLinkCallbackCollection = function (callbackCollection) {
        this.links.push(new RenderLinkCallbackCollection(callbackCollection));
    };
    RenderArea.prototype.addLinkChange = function (e, callbackCollection) {
        this.links.push(new RenderLinkChange(e, callbackCollection));
    };
    RenderArea.prototype.addLinkCheckbox = function (e, callbackCollectionWhenChecked, callbackCollectionWhenUnchecked) {
        this.links.push(new RenderLinkCheckbox(e, callbackCollectionWhenChecked, callbackCollectionWhenUnchecked));
    };
    RenderArea.prototype.addLinkInput = function (e, enigmaAnswer, callbackCollection, callbackCollectionWrong) {
        this.links.push(new RenderLinkInput(e, enigmaAnswer, callbackCollection, callbackCollectionWrong));
    };
    RenderArea.prototype.addLinkOnHoverShowTooltip = function (classHover, classTooltip) {
        this.links.push(new RenderLinkOnHoverShowTooltip(classHover, classTooltip));
    };
    RenderArea.prototype.addLinkOver = function (e1, e2) {
        this.links.push(new RenderLinkOver(e1, e2));
    };
    RenderArea.prototype.addLinkSimpleInput = function (e, callbackCollection, defaultValue, hasFocus) {
        this.links.push(new RenderLinkSimpleInput(e, callbackCollection, defaultValue, hasFocus));
    };
    RenderArea.prototype.addList = function (x1, x2, y, id, callbackCollection, optionsArray) {
        if (optionsArray === void 0) { optionsArray = []; }
        var options = "";
        // Add all the options tag & text to the options string
        for (var i = 0; i < optionsArray.length / 2; i++) {
            options += "<option id=\"" + optionsArray[i * 2] + "\" class=\"asciiSelectOption\">" + optionsArray[i * 2 + 1] + "</option>";
        }
        // Add the list itself as a tag
        this.addTag(new RenderTag(x1, "<span class=\"aroundSelect\"><select id=\"" + id + "\" class=\"asciiSelect\" style=\"width:" + (x2 - x1).toString() + "ex\">" + options + "</select></span>"), y);
        // Add the render link used to control the list
        this.addLinkChange("#" + id, callbackCollection);
    };
    RenderArea.prototype.addMultipleAsciiButtons = function (otherClass) {
        var coordinates = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            coordinates[_i - 1] = arguments[_i];
        }
        // If the length of the coordinates array isn't multiple of 3, we return false
        if (coordinates.length % 3 != 0)
            return false;
        // We add all the buttons
        for (var i = 0; i < coordinates.length / 3; i++) {
            if (this.addAsciiButton(coordinates[3 * i], coordinates[3 * i + 1], coordinates[3 * i + 2], otherClass) == false)
                return false;
        }
        // We return true
        return true;
    };
    RenderArea.prototype.addMultipleAsciiNinjaButtons = function (otherClass) {
        var coordinates = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            coordinates[_i - 1] = arguments[_i];
        }
        // If the length of the coordinates array isn't multiple of 3, we return false
        if (coordinates.length % 3 != 0)
            return false;
        // We add all the buttons
        for (var i = 0; i < coordinates.length / 3; i++) {
            if (this.addAsciiNinjaButton(coordinates[3 * i], coordinates[3 * i + 1], coordinates[3 * i + 2], otherClass) == false)
                return false;
        }
        // We return true
        return true;
    };
    RenderArea.prototype.addSimpleInput = function (x1, x2, y, callbackCollection, otherClass, defaultValue, hasFocus) {
        if (defaultValue === void 0) { defaultValue = null; }
        if (hasFocus === void 0) { hasFocus = false; }
        this.addTag(new RenderTag(x1, "<span class=\"aroundTextInput\"><input type=\"text\" class=\"asciiTextInput noHotkeys " + otherClass + "\" style=\"width:" + (x2 - x1).toString() + "ex\"></span>"), y);
        this.addLinkSimpleInput("." + otherClass, callbackCollection, defaultValue, hasFocus);
    };
    RenderArea.prototype.addTag = function (tag, y) {
        // BUGS
        if (Bugs.getGraphicalBugLevel() >= 3)
            y += Random.between(0, 10) - 5;
        // Return false if y is out of bounds
        if (y < 0 || y >= this.height)
            return false;
        // Return false if x is out of bounds
        if (tag.getX() < 0 || tag.getX() > this.getWidth())
            return false;
        // If it's the first tag we add, we just add it
        if (this.tags[y].length == 0) {
            this.tags[y].push(tag);
            return true;
        }
        else {
            for (var i = 0; i < this.tags[y].length; i++) {
                // If this is the right place to add the tag, we add it and we break the loop
                if (tag.getX() > this.tags[y][i].getX()) {
                    this.tags[y].splice(i, 0, tag); // We add the tag just before the one we're iterating
                    return true;
                }
            }
        }
        // If we didn't add it yet, it means we have to add it at the end of the array : we do so
        this.tags[y].push(tag);
        // Return true
        return true;
    };
    RenderArea.prototype.addTextarea = function (x, y, width, height, otherClass, text) {
        if (text === void 0) { text = ""; }
        return this.addTag(new RenderTag(x, "<textarea class=\"textarea " + otherClass + "\" rows=\"" + height.toString() + "\" cols=\"" + width.toString() + "\">" + text + "</textarea>"), y);
    };
    RenderArea.prototype.addTooltip = function (tooltipClass, tooltipText) {
        return this.addTag(new RenderTag(0, "<span class=\"tooltip " + tooltipClass + "\">" + tooltipText + "</span>"), 0);
    };
    RenderArea.prototype.addTranslatedComment = function (x, y, text, otherClass) {
        return this.addTag(new RenderTag(x, "<span class=\"aroundComment " + otherClass + "\"><span class=\"comment translated\">" + text + "</span></span>"), y);
    };
    RenderArea.prototype.addTwoTags = function (x1, x2, y, tag1, tag2) {
        // If it fails, we return false
        if (this.addTag(new RenderTag(x1, tag1), y) == false || this.addTag(new RenderTag(x2, tag2), y) == false)
            return false;
        // Else, we return true
        return true;
    };
    RenderArea.prototype.drawArea = function (renderArea, x, y, transparency) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (transparency === void 0) { transparency = null; }
        // Iterate over lines of the area to draw
        for (var i = 0; i < renderArea.getHeight(); i++) {
            // Draw the text
            this.drawString(renderArea.getLine(i), x, y + i, false, transparency);
            // Add the tags
            for (var j = 0; j < renderArea.getTags()[i].length; j++) {
                this.addTag(renderArea.getTags()[i][j].clone().setX(renderArea.getTags()[i][j].getX() + x), y + i);
            }
        }
    };
    RenderArea.prototype.drawArray = function (array, x, y, transparency, spanClass) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (transparency === void 0) { transparency = null; }
        if (spanClass === void 0) { spanClass = null; }
        for (var i = 0; i < array.length; i++) {
            // Draw the string
            this.drawString(array[i], x, y + i, false, transparency);
            // Add the tags
            if (spanClass != null) {
                this.addTwoTags(x, x + array[i].length, y + i, "<span class=\"" + spanClass + "\">", "</span>");
            }
        }
    };
    RenderArea.prototype.drawHorizontalLine = function (str, x1, x2, y) {
        var strBuffer = "";
        // We put the string to draw in a buffer (for optimizations reasons)
        strBuffer = strBuffer.fillWith(str, x2 - x1);
        // We draw the string
        return this.drawString(strBuffer, x1, y);
    };
    RenderArea.prototype.drawSpeech = function (str, y, x1, x2, speechClass, translatedText) {
        if (speechClass === void 0) { speechClass = null; }
        if (translatedText === void 0) { translatedText = null; }
        var currentLine = ""; // Current line
        var lastWordIndex = 0; // Index of the last word drawn
        var width = x2 - x1 - 1; // We calculate the speech's width (-1 because we need space for the " characters)
        var words = str.split(" "); // We split the strings into an array of words
        var xPos; // Used to store some position at some time
        // Draw the first " character
        this.drawString("\"", x1, y);
        for (var i = 0; i < words.length; i++) {
            // If adding the current word to the line would exceed the width or we're working on the last word
            if (currentLine.length + words[i].length >= width) {
                // We draw the current line
                xPos = x1 + 1 + width / 2 - (currentLine.length / 2);
                this.drawString(currentLine, xPos, y);
                // If a speechClass is specified, we add tags
                if (speechClass != null)
                    this.addTwoTags(xPos, xPos + currentLine.length, y, "<span class=\"" + speechClass + "\">", "</span>");
                // We go to the line below
                currentLine = "";
                y++;
            }
            // We add a space before the word if there's at least one word before
            if (currentLine != "")
                currentLine += " ";
            // We add the word to the current line
            currentLine += words[i];
            // If we're working on the last word, we draw the line anyway
            if (i == words.length - 1) {
                xPos = x1 + 1 + width / 2 - (currentLine.length / 2);
                this.drawString(currentLine, xPos, y);
                // If a speechClass is specified, we add tags
                if (speechClass != null)
                    this.addTwoTags(xPos, xPos + currentLine.length, y, "<span class=\"" + speechClass + "\">", "</span>");
            }
        }
        // Draw the second " character
        this.drawString("\"", x2, y);
        // If we should add a translation, then we add it and the translated text isn't empty
        if (translatedText != null && translatedText != "") {
            this.addTooltip(speechClass + "Tooltip", translatedText);
            this.addLinkOnHoverShowTooltip("." + speechClass, "." + speechClass + "Tooltip");
        }
        // We return y, which is the y position of the last speech line
        return y;
    };
    RenderArea.prototype.drawString = function (str, x, y, translated, transparency) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (translated === void 0) { translated = false; }
        if (transparency === void 0) { transparency = null; }
        var indexFirst;
        var indexLast;
        // BUGS (change position)
        if (Bugs.getGraphicalBugLevel() >= 4) {
            x += Random.between(0, 20) - 10;
            y += Random.between(0, 4) - 2;
        }
        // Return false if y is out of bounds
        if (y < 0 || y >= this.height)
            return false;
        // BUGS (random character)
        if (Bugs.getGraphicalBugLevel() >= 3)
            str = Bugs.changeRandomCharacter(str);
        else if (Bugs.getGraphicalBugLevel() >= 2 && Random.oneChanceOutOf(2))
            str = Bugs.changeRandomCharacter(str);
        else if (Bugs.getGraphicalBugLevel() >= 1 && Random.oneChanceOutOf(3))
            str = Bugs.changeRandomCharacter(str);
        // The indices of the first and last character we're going to draw
        indexFirst = 0;
        indexLast = str.length;
        // Restrict the indices if out of bounds
        if (x + indexLast >= this.width)
            indexLast -= (x + indexLast - this.width);
        if (x < 0)
            indexFirst = -x;
        // If there isn't even one character to draw, we return false
        if (indexLast < 0 || indexFirst >= str.length)
            return false;
        // If there's no transparent character, we just draw the whole string
        if (transparency == null) {
            this.area[y] = this.area[y].replaceAt(x + indexFirst, str.substring(indexFirst, indexLast));
        }
        else {
            for (var i = indexFirst; i < indexLast; i++) {
                // If the character isn't alpha
                if (str[i] != transparency.getAlphaCharacter()) {
                    // If the meta alpha character isn't null and our character is this meta alpha character, we draw the alpha character
                    if (transparency.getMetaAlphaCharacter() != null && str[i] == transparency.getMetaAlphaCharacter())
                        this.area[y] = this.area[y].replaceAt(x + i, transparency.getAlphaCharacter());
                    else
                        this.area[y] = this.area[y].replaceAt(x + i, str[i]);
                }
            }
        }
        // If translated is true, add the tags
        if (translated) {
            this.addTwoTags(x, x + str.length, y, "<span class=\"translated\">", "</span>");
        }
        // And we return true
        return true;
    };
    RenderArea.prototype.drawVerticalLine = function (str, x, y1, y2) {
        for (var i = y1; i <= y2; i++) {
            if (this.drawString(str, x, i) == false)
                return false;
        }
        return true;
    };
    RenderArea.prototype.eraseEverything = function (character) {
        if (character === void 0) { character = " "; }
        var str;
        // We check if the character is correct, return false if it isn't
        if (character.length != 1)
            return false;
        // We prepare the string
        str = "";
        str = str.fillWith(character, this.width);
        // We fill all the lines with the character given in parameter
        for (var i = 0; i < this.height; i++) {
            this.drawString(str, 0, i);
        }
        // We return true
        return true;
    };
    RenderArea.prototype.removeAllLinks = function () {
        this.links = [];
    };
    RenderArea.prototype.removeAllTags = function () {
        for (var i = 0; i < this.tags.length; i++) {
            this.tags[i] = [];
        }
    };
    RenderArea.prototype.resetAllButSize = function (character) {
        if (character === void 0) { character = " "; }
        this.eraseEverything(character);
        this.removeAllTags();
        this.removeAllLinks();
    };
    RenderArea.prototype.resize = function (newWidth, newHeight, character) {
        if (character === void 0) { character = " "; }
        // We store the old size
        var oldWidth = this.width;
        var oldHeight = this.height;
        // We check if the character is correct, return false if it isn't
        if (character.length != 1)
            return false;
        // We try to change the size, return false if failure
        if (this.setSize(newWidth, newHeight) == false)
            return false;
        // We resize the height
        if (newHeight > oldHeight) {
            for (var i = oldHeight; i < newHeight; i++) {
                // We resize the tags
                this.tags.push([]);
                // We resize the area
                this.area.push("");
                // If the new width is higher
                if (newWidth > oldWidth) {
                    for (var j = 0; j < oldWidth; j++) {
                        this.area[i] += character;
                    }
                }
                else if (oldWidth > newWidth) {
                    for (var j = 0; j < newWidth; j++) {
                        this.area[i] += character;
                    }
                }
            }
        }
        else if (oldHeight > newHeight) {
            // We resize the tags
            this.tags.splice(this.tags.length - (oldHeight - newHeight), oldHeight - newHeight); // We remove some lines to reduce the height
            // We resize the area
            this.area.splice(this.area.length - (oldHeight - newHeight), oldHeight - newHeight); // We remove some lines to reduce the height
        }
        // We resize the width
        if (newWidth > oldWidth) {
            // We add characters at the end of the lines (lines 0 to new height)
            for (var i = 0; i < newHeight; i++) {
                for (var j = oldWidth; j < newWidth; j++) {
                    this.area[i] += character;
                }
            }
        }
        else if (oldWidth > newWidth) {
            // We each line (0 to new height), we only keep the beginning of the string
            for (var i = 0; i < newHeight; i++) {
                this.area[i] = this.area[i].substr(0, newWidth);
            }
        }
        // And we return true
        return true;
    };
    RenderArea.prototype.resizeFromArea = function (renderArea) {
        this.resize(renderArea.getWidth(), renderArea.getHeight());
    };
    RenderArea.prototype.resizeFromArray = function (array, xAdd, yAdd) {
        if (xAdd === void 0) { xAdd = 0; }
        if (yAdd === void 0) { yAdd = 0; }
        var width = 0;
        var height = array.length;
        for (var i = 0; i < array.length; i++) {
            if (width < array[i].length)
                width = array[i].length;
        }
        this.resize(width + xAdd, height + yAdd);
    };
    RenderArea.prototype.runLinks = function () {
        for (var i = 0; i < this.links.length; i++) {
            this.links[i].run();
        }
    };
    // Public getters
    RenderArea.prototype.getForRendering = function () {
        var areaClone = [];
        // If we have no tags at all
        if (this.tags.length == 0) {
            // We simply return the area as a string
            return this.area.join("\n");
        }
        else {
            // We clone the area
            areaClone = this.area.slice(0);
            // We add tags to it
            for (var i = 0; i < this.height; i++) {
                for (var j = 0; j < this.tags[i].length; j++) {
                    // If the tag should be added, we add it
                    areaClone[i] = this.tags[i][j].draw(areaClone[i]);
                }
            }
            // We return the cloned area as a string
            return areaClone.join("\n");
        }
    };
    RenderArea.prototype.getLine = function (n) {
        if (n < 0 || n >= this.height)
            console.log("Error : trying to get a line out of the bounds of a drawing area.");
        else
            return this.area[n];
    };
    RenderArea.prototype.getTags = function () {
        return this.tags;
    };
    RenderArea.prototype.getWidth = function () {
        return this.width;
    };
    RenderArea.prototype.getHeight = function () {
        return this.height;
    };
    // Private methods
    RenderArea.prototype.setSize = function (width, height) {
        // Return false if the size given is incorrect
        if (width < 0 || height < 0)
            return false;
        this.width = width;
        this.height = height;
        return true;
    };
    return RenderArea;
})();
var CallbackCollection = (function () {
    // Constructor
    function CallbackCollection() {
        var callbacks = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            callbacks[_i - 0] = arguments[_i];
        }
        this.callbacks = []; // Array of functions returning void
        this.callbacks = callbacks;
    }
    // Public methods
    CallbackCollection.prototype.addCallback = function (callback) {
        this.callbacks.push(callback);
        return this;
    };
    CallbackCollection.prototype.fire = function () {
        for (var i = 0; i < this.callbacks.length; i++) {
            this.callbacks[i]();
        }
    };
    CallbackCollection.prototype.reset = function () {
        this.callbacks = [];
    };
    return CallbackCollection;
})();
///<reference path="CallbackCollection.ts"/>
var Resource = (function () {
    // Constructor
    function Resource(savingPrefix) {
        if (savingPrefix === void 0) { savingPrefix = null; }
        // Attributes
        this.accumulated = 0;
        this.current = 0;
        this.max = 0;
        this.callbackCollection = new CallbackCollection();
        // Set the saving prefix
        this.savingPrefix = savingPrefix;
    }
    // Public methods
    Resource.prototype.add = function (n) {
        // If the operation would leave an < 0 value, we stop
        if (this.current + n < 0)
            return false;
        // If we add a positive value, we also add it to the accumulated
        if (n > 0)
            this.setAccumulated(this.accumulated + n);
        // We add to the current value
        this.setCurrent(this.current + n);
        // We return true
        return true;
    };
    Resource.prototype.load = function () {
        this.setAccumulated(Saving.loadNumber(this.savingPrefix + "Accumulated"));
        this.setCurrent(Saving.loadNumber(this.savingPrefix + "Current"));
        this.setMax(Saving.loadNumber(this.savingPrefix + "Max"));
    };
    Resource.prototype.save = function () {
        Saving.saveNumber(this.savingPrefix + "Accumulated", this.getAccumulated());
        Saving.saveNumber(this.savingPrefix + "Current", this.getCurrent());
        Saving.saveNumber(this.savingPrefix + "Max", this.getMax());
    };
    Resource.prototype.transferTo = function (resource, howMany, ratio) {
        if (howMany === void 0) { howMany = -1; }
        if (ratio === void 0) { ratio = 1; }
        // If howMany is below 0, then we transfer everything
        if (howMany < 0)
            howMany = this.current;
        else {
            // If we don't have enough to transfer, we return false
            if (howMany > this.current)
                return false;
        }
        // We lower our current quantity
        this.add(-howMany);
        // We add to the other resource
        resource.add(howMany * ratio);
        // We return true
        return true;
    };
    // Public getters
    Resource.prototype.getAccumulated = function () {
        return this.accumulated;
    };
    Resource.prototype.getCurrent = function () {
        return this.current;
    };
    Resource.prototype.getCurrentAsString = function () {
        return this.current.toString();
    };
    Resource.prototype.getCallbackCollection = function () {
        return this.callbackCollection;
    };
    Resource.prototype.getMax = function () {
        return this.max;
    };
    // Public setters
    Resource.prototype.setCurrent = function (n) {
        // Set the value
        this.current = n;
        // Check if the max value should change
        if (this.current > this.max)
            this.max = this.current;
        // Fire the callbacks
        this.callbackCollection.fire();
    };
    // Private methods
    Resource.prototype.setAccumulated = function (n) {
        this.accumulated = n;
    };
    Resource.prototype.setMax = function (n) {
        this.max = n;
    };
    return Resource;
})();
///<reference path="BarType.ts"/>
///<reference path="RenderArea.ts"/>
///<reference path="Resource.ts"/>
var Bar = (function (_super) {
    __extends(Bar, _super);
    // Constructor
    function Bar(type) {
        // Super constructor
        _super.call(this);
        // We set the type
        this.type = type;
        // We set some parameters depending on the bar type
        switch (this.type) {
            case BarType.SIMPLE:
                this.contentCharacter = "*";
                this.bordersCharacter = "-";
                break;
            case BarType.HEALTH:
            case BarType.UNICOLOR_HEALTH:
                this.contentCharacter = " ";
                this.bordersCharacter = "-";
                break;
            default:
                console.log("Error : trying to load an incorrect bar type");
                break;
        }
    }
    // Public methods
    Bar.prototype.update = function (ratio, text) {
        if (text === void 0) { text = ""; }
        var bordersBool;
        var lateralBordersBool;
        var textBool;
        var contentY1;
        var contentY2;
        var contentSize;
        var colorType;
        // If we have no height, we return
        if (this.getHeight() <= 0)
            return false;
        // If the width is really to low, we return
        if (this.getWidth() <= 1)
            return false;
        // We remove all the tags and all the text
        this.removeAllTags();
        this.eraseEverything();
        // We decide if there will be text or not..
        if (text.length != 0)
            textBool = true;
        else
            textBool = false;
        // We decide if there will be borders or not..
        if (this.getHeight() < (textBool ? 4 : 3))
            bordersBool = false;
        else
            bordersBool = true;
        // ..and where the real content of the bar will take place
        if (bordersBool) {
            contentY1 = 1;
            if (textBool)
                contentY2 = this.getHeight() - 3;
            else
                contentY2 = this.getHeight() - 2;
        }
        else {
            contentY1 = 0;
            if (textBool && this.getHeight() > 1)
                contentY2 = this.getHeight() - 2;
            else
                contentY2 = this.getHeight() - 1;
        }
        // We decide if there will be lateral borders
        if (this.getWidth() >= 20)
            lateralBordersBool = true;
        else
            lateralBordersBool = false;
        // We possibly draw the lateral borders
        if (lateralBordersBool) {
            for (var i = contentY1; i <= contentY2; i++) {
                this.drawString("|", 0, i);
                this.drawString("|", this.getWidth() - 1, i);
            }
        }
        // We draw the borders if there are borders
        if (bordersBool) {
            this.drawHorizontalLine(this.bordersCharacter, 0, this.getWidth() - 1, 0);
            if (textBool)
                this.drawHorizontalLine(this.bordersCharacter, 0, this.getWidth() - 1, this.getHeight() - 2);
            else
                this.drawHorizontalLine(this.bordersCharacter, 0, this.getWidth() - 1, this.getHeight() - 1);
        }
        // We calculate the content size
        contentSize = Math.floor((this.getWidth() - (lateralBordersBool ? 2 : 0)) * ratio);
        if (contentSize == 0 && ratio > 0)
            contentSize = 1; // If the ratio is > 0, then the content size can't be == 0
        // We draw the content if the content size is > 0
        if (contentSize > 0) {
            for (var i = contentY1; i <= contentY2; i++) {
                this.drawHorizontalLine(this.contentCharacter, (lateralBordersBool ? 1 : 0), contentSize, i);
            }
        }
        // We draw the text if there is text
        if (textBool) {
            this.drawString(text, (text.length > this.getWidth() ? 0 : Math.floor(this.getWidth() / 2 - text.length / 2)), this.getHeight() - 1);
        }
        // We add special tags, depending on the type of bar
        switch (this.type) {
            case BarType.HEALTH:
            case BarType.UNICOLOR_HEALTH:
                // We choose the color
                if (this.type == BarType.HEALTH) {
                    if (ratio < 0.2)
                        colorType = ColorType.HEALTH_RED;
                    else if (ratio < 0.5)
                        colorType = ColorType.HEALTH_ORANGE;
                    else
                        colorType = ColorType.HEALTH_GREEN;
                }
                else
                    colorType = ColorType.HEALTH_UNICOLOR;
                // We add the tags
                if (contentSize > 0) {
                    for (var i = contentY1; i <= contentY2; i++) {
                        this.addBackgroundColor((lateralBordersBool ? 1 : 0), (lateralBordersBool ? 1 : 0) + contentSize, i, new Color(colorType));
                    }
                }
                break;
        }
        // Finally, we return true
        return true;
    };
    return Bar;
})(RenderArea);
var QuestEntity = (function () {
    // Constructor
    function QuestEntity(quest, globalPosition, naming, renderArea, renderAreaPosition, cbc, questEntityMovement, questEntityAnimation) {
        if (naming === void 0) { naming = new Naming("???", "???"); }
        if (renderArea === void 0) { renderArea = null; }
        if (renderAreaPosition === void 0) { renderAreaPosition = new Pos(0, 0); }
        if (cbc === void 0) { cbc = null; }
        if (questEntityMovement === void 0) { questEntityMovement = null; }
        if (questEntityAnimation === void 0) { questEntityAnimation = null; }
        // Is dead ?
        this.dead = false;
        // Is out of area ?
        this.outOfArea = false;
        // Is destructible ?
        this.destructible = false;
        // Should the health bar be shown ?
        this.healthBar = null;
        this.transparency = null;
        this.noMovementLastUpdate = true;
        // Weapon
        this.questEntityWeapons = [];
        // Spell casters
        this.questEntitySpellCasters = [];
        // Last damage reason
        this.lastDamageReason = null;
        // Naming
        this.naming = null;
        // Team
        this.team = QuestEntityTeam.MOBS; // The default team of an entity is MOBS because most entities want to use this one
        // Can it be forced to move?
        this.canBeForcedToMove = true;
        // The special spell casting damage reason, null until we create it
        this.spellCastingDamageReason = null;
        // Is a spell?
        this.isASpell = false;
        // Is jumping?
        this.jumping = false;
        this.jumpSpeed = null;
        this.jumpDuration = null;
        // Is controlled falling? (controlled falling is when we fall after a jump for example, it means that we can move while falling)
        this.controlledFalling = false;
        // Is stopped?
        this.stopped = false;
        this.stoppedDuration = null;
        // Is affected by anti gravity?
        this.antiGravity = false;
        this.antiGravityDuration = null;
        // Is a turtle?
        this.turtle = false;
        this.turtleDuration = null;
        this.turtleLastMovement = null;
        // Is in berserk mode?
        this.berserk = false;
        this.berserkDuration = null;
        // Apply parameters
        this.quest = quest;
        this.globalPosition = globalPosition;
        this.naming = naming;
        this.setRenderArea(renderArea);
        this.renderAreaPosition = renderAreaPosition;
        this.setCbc(cbc);
        this.setQuestEntityMovement(questEntityMovement);
        this.setQuestEntityAnimation(questEntityAnimation);
    }
    // Public methods
    QuestEntity.prototype.addQuestEntitySpellCaster = function (questEntitySpellCaster) {
        this.questEntitySpellCasters.push(questEntitySpellCaster);
    };
    QuestEntity.prototype.addQuestEntityWeapon = function (questEntityWeapon) {
        this.questEntityWeapons.push(questEntityWeapon);
    };
    QuestEntity.prototype.beginAntiGravity = function (antiGravityDuration) {
        if (this.antiGravity == false) {
            this.antiGravity = true;
            this.antiGravityDuration = antiGravityDuration;
            return true;
        }
        return false;
    };
    QuestEntity.prototype.beginBerserk = function (berserkDuration) {
        if (this.berserk == false) {
            this.berserk = true;
            this.berserkDuration = berserkDuration;
            this.setHp(Math.ceil(this.getHp() / 2));
            return true;
        }
        return false;
    };
    QuestEntity.prototype.beginTurtle = function (turtleDuration) {
        if (this.turtle == false) {
            this.turtle = true;
            this.turtleDuration = turtleDuration;
            this.turtleLastMovement = 0;
            return true;
        }
        return false;
    };
    QuestEntity.prototype.canJumpInMidAir = function () {
        return false;
    };
    QuestEntity.prototype.checkCollision = function (pos) {
        if (pos === void 0) { pos = new Pos(0, 0); }
        // BUGS : if the level is >= 4, we just return a random value
        if (Bugs.getQuestBugLevel() >= 4)
            return Random.flipACoin();
        for (var i = 0; i < this.quest.getEntities().length; i++) {
            // If it's not the same object as us
            if (this.quest.getEntities()[i] != this) {
                // If we collide with it, we return true
                if (this.collidesWith(this.quest.getEntities()[i], pos))
                    return true;
            }
        }
        // No collision
        return false;
    };
    QuestEntity.prototype.collidesWith = function (questEntity, pos) {
        if (pos === void 0) { pos = new Pos(0, 0); }
        // If we both have a collision box collection, we return the result of the collision test
        if (this.cbc != null && questEntity.getCbc() != null)
            return this.cbc.collidesWith(questEntity.getCbc(), pos);
        // Else, we return false, there can't be any collision
        return false;
    };
    QuestEntity.prototype.draw = function (renderArea) {
        if (this.renderArea != null) {
            // On some conditions, we exit now and don't draw anything (it allows no drawing outside of the quest panel when realQuestSize and realQuestDrawingSize are different (in the hole for example)
            if (this.globalPosition.x + this.renderAreaPosition.x + this.quest.getGlobalDrawingOffset().x > this.quest.getRealQuestDrawingSize().x)
                return;
            if (this.globalPosition.y + this.renderAreaPosition.y + this.quest.getGlobalDrawingOffset().y > this.quest.getRealQuestDrawingSize().y)
                return;
            if (this.globalPosition.x + this.renderAreaPosition.x + this.renderArea.getWidth() + this.quest.getGlobalDrawingOffset().x < 0)
                return;
            if (this.globalPosition.y + this.renderAreaPosition.y + this.renderArea.getHeight() + this.quest.getGlobalDrawingOffset().y < 0)
                return;
            renderArea.drawArea(this.renderArea, this.quest.getRealQuestPosition().x + this.quest.getGlobalDrawingOffset().x + this.globalPosition.x + this.renderAreaPosition.x, this.quest.getRealQuestPosition().y + this.quest.getGlobalDrawingOffset().y + this.globalPosition.y + this.renderAreaPosition.y, this.transparency);
        }
        // If the debug mode is on
        if (Saving.loadBool("gameDebug")) {
            if (this.cbc != null) {
                for (var i = 0; i < this.cbc.getBoxes().length; i++) {
                    for (var k = 0; k < this.cbc.getBoxes()[i].getSize().x; k++) {
                        for (var j = 0; j < this.cbc.getBoxes()[i].getSize().y; j++) {
                            renderArea.drawString("D", this.quest.getRealQuestPosition().x + this.quest.getGlobalDrawingOffset().x + this.globalPosition.x + this.cbc.getBoxes()[i].getPosition().x + k, this.quest.getRealQuestPosition().y + this.quest.getGlobalDrawingOffset().y + this.globalPosition.y + this.cbc.getBoxes()[i].getPosition().y + j);
                        }
                    }
                }
            }
        }
    };
    QuestEntity.prototype.forceMoving = function (movement) {
        if (this.canBeForcedToMove)
            this.move(movement, true);
    };
    QuestEntity.prototype.getAndPossiblyCreateSpellCastingDamageReason = function (naming) {
        // If our spell casting damage reason is null, we create it
        if (this.spellCastingDamageReason == null) {
            this.spellCastingDamageReason = new QuestEntityDamageReason(QuestEntityDamageReasonWhoType.ENTITY, QuestEntityDamageReasonWhatType.SPELL);
            this.spellCastingDamageReason.setQuestEntity(this);
        }
        // We set the naming given
        this.spellCastingDamageReason.setSpellNaming(naming);
        // We return it
        return this.spellCastingDamageReason;
    };
    QuestEntity.prototype.getDeathMessage = function () {
        // If there's a last damage reason
        if (this.getLastDamageReason() != null) {
            return this.getLastDamageReason().getWhoNaming().getBeginning() + " killed " + this.naming.getAnywhere() + " with " + this.getLastDamageReason().getWhatNaming().getAnywhere() + ".";
        }
        // Else
        return this.naming.getBeginning() + " was erased from reality.";
    };
    QuestEntity.prototype.getRenderAreaCenter = function () {
        if (this.renderArea != null)
            return this.globalPosition.plus(new Pos(Math.floor(this.renderArea.getWidth() / 2), Math.floor(this.renderArea.getHeight() / 2)));
        return this.globalPosition;
    };
    QuestEntity.prototype.goTowards = function (ourPosition, goalPosition, minDistance, speed, dontTakeYInAccount) {
        if (minDistance === void 0) { minDistance = 0; }
        if (speed === void 0) { speed = new Pos(1, 1); }
        if (dontTakeYInAccount === void 0) { dontTakeYInAccount = false; }
        // We create the movement
        var movement = new Pos(0, 0);
        // We find the distance between our position and the position where we want to go
        var distance = ourPosition.getDistance(goalPosition);
        // If the x distance is the biggest (we do /2 because characters are thin in the ascii art world!) and big enough (or if we don't take in account y)
        if ((Math.abs(distance.x) / 2 > Math.abs(distance.y) && Math.abs(distance.x) > minDistance * 2) || dontTakeYInAccount) {
            if (distance.x > 0)
                movement.x = -speed.x;
            else if (distance.x < 0)
                movement.x = speed.x;
        }
        else if (Math.abs(distance.y) > minDistance) {
            if (distance.y > 0)
                movement.y = -speed.y;
            else if (distance.y < 0)
                movement.y = speed.y;
        }
        // We use this movement to set our quest entity movement's offset
        this.getQuestEntityMovement().setOffset(movement);
    };
    QuestEntity.prototype.heal = function (hp) {
        this.setHp(this.getHp() + hp);
    };
    QuestEntity.prototype.hit = function (questEntity, damage, reason) {
        // BUGS
        if (Bugs.getQuestBugLevel() >= 1)
            damage *= Random.between(1, 3);
        if (this.berserk == false)
            questEntity.inflictDamage(damage, reason);
        else
            questEntity.inflictDamage(damage * 2, reason);
    };
    QuestEntity.prototype.inflictDamage = function (damage, reason) {
        // We save the damage reason
        this.lastDamageReason = reason;
        // If we're destructible, we get the damage
        if (this.destructible) {
            // If we're not a turtle
            if (this.turtle == false)
                this.setHp(this.getHp() - damage);
            else
                this.setHp(this.getHp() - Math.ceil(damage / 2));
        }
    };
    QuestEntity.prototype.isOutOfArea = function () {
        // If the entity if too much out of the area, we return true
        if (this.globalPosition.x < -this.getQuest().getLeftLimit())
            return true;
        if (this.globalPosition.y < -this.getQuest().getTopLimit())
            return true;
        if (this.globalPosition.x > this.quest.getRealQuestSize().x + this.getQuest().getRightLimit())
            return true;
        if (this.globalPosition.y > this.quest.getRealQuestSize().y + this.getQuest().getBottomLimit())
            return true;
        // Else we return false
        return false;
    };
    QuestEntity.prototype.jump = function (jumpDuration, jumpSpeed) {
        if (jumpSpeed === void 0) { jumpSpeed = 1; }
        // BUGS
        if (Bugs.getQuestBugLevel() >= 2)
            jumpSpeed = Random.between(1, 5);
        // If we're not already jumping or controlled falling and we would collide by going down (which means we're on the ground), we jump (we also jump without checking all that if we are able to jump in mid-air)
        if ((this.jumping == false && this.controlledFalling == false && this.checkCollision(new Pos(0, 1))) || this.canJumpInMidAir()) {
            this.jumping = true;
            this.jumpDuration = jumpDuration;
            this.jumpSpeed = jumpSpeed;
            return true;
        }
        return false;
    };
    QuestEntity.prototype.move = function (pos, force) {
        if (force === void 0) { force = false; }
        // BUGS
        if (Bugs.getQuestBugLevel() >= 3 || (Bugs.getQuestBugLevel() >= 2 && Random.oneChanceOutOf(3)) || (Bugs.getQuestBugLevel() >= 1 && Random.oneChanceOutOf(5))) {
            pos.x += Random.between(1, 3) - 2;
            pos.y += Random.between(1, 3) - 2;
        }
        // If we're not a turtle or this isn't a pure horizontal movement (turtles only care about horizontal movement)
        if (this.turtle == false || pos.y != 0)
            return this.setGlobalPosition(this.globalPosition.plus(pos), force);
        else {
            // We check the duration
            if (this.turtleDuration > 0) {
                this.turtleDuration -= 1;
            }
            else
                this.stopTurtle();
            // If the movement is >= 2
            if (this.turtleLastMovement >= 2) {
                this.turtleLastMovement = 0; // We reset the movement
                return this.setGlobalPosition(this.globalPosition.plus(pos), force); // We move
            }
            else {
                this.turtleLastMovement += 1;
                return false;
            }
        }
    };
    QuestEntity.prototype.moveWormsLike = function (pos) {
        // If we can move normally
        if (this.checkCollision(pos) == false) {
            // If we can't move two steps below but we can move on step below, then we move one step below (if we're not jumping or controlled falling)
            if (this.checkCollision(pos.plus(new Pos(0, 2))) == true && this.checkCollision(pos.plus(new Pos(0, 1))) == false && this.jumping == false && this.controlledFalling == false) {
                return this.move(pos.plus(new Pos(0, 1)));
            }
            else {
                return this.move(pos);
            }
        }
        else if (this.checkCollision(pos.plus(new Pos(0, -1))) == false && this.jumping == false && this.controlledFalling == false) {
            // We move one step above
            return this.move(pos.plus(new Pos(0, -1)));
        }
        // Else we don't move
        return false;
    };
    QuestEntity.prototype.removeQuestEntityWeapons = function () {
        this.questEntityWeapons = [];
    };
    QuestEntity.prototype.setGlobalPosition = function (pos, force) {
        if (force === void 0) { force = false; }
        var oldPosition = this.globalPosition;
        this.globalPosition = pos;
        // Check for collisions : restore the old position and return false if the movement would cause a collision
        if (force == false && this.checkCollision()) {
            this.globalPosition = oldPosition;
            return false;
        }
        // Return true
        return true;
    };
    QuestEntity.prototype.shouldDie = function () {
        // Return true if we are destructible and have 0 hp or we're already dead
        if ((this.destructible == true && this.hp <= 0) || this.dead == true)
            return true;
        return false;
    };
    QuestEntity.prototype.stop = function (stoppedDuration) {
        // If we're not already stopped
        if (this.stopped == false) {
            this.stopped = true;
            this.stoppedDuration = stoppedDuration;
            return true;
        }
        return false;
    };
    QuestEntity.prototype.stopBerserk = function () {
        this.berserk = false;
    };
    QuestEntity.prototype.stopTurtle = function () {
        this.turtle = false;
    };
    QuestEntity.prototype.teleport = function (pos) {
        return this.setGlobalPosition(pos);
    };
    QuestEntity.prototype.testNewGlobalPosition = function (pos) {
        var oldPosition = this.globalPosition;
        this.globalPosition = pos;
        // If there's a collision, restore the old position and return false
        if (this.checkCollision()) {
            this.globalPosition = oldPosition;
            return false;
        }
        // Else, restore the old position and return true
        this.globalPosition = oldPosition;
        return true;
    };
    QuestEntity.prototype.update = function () {
        // We handle berserk mode
        if (this.berserk) {
            if (this.berserkDuration > 0) {
                this.berserkDuration -= 1;
            }
            else {
                this.stopBerserk();
            }
        }
        // We handle animation
        this.handleAnimation();
        // We handle gravity, and then movement if gravity had no effect
        this.noMovementLastUpdate = true;
        if (this.handleGravity() == false)
            this.handleMovement();
        // We handle combat
        this.handleCombat();
    };
    // Default behaviour of this function : displaying a simple death message in the quest log
    QuestEntity.prototype.willDie = function () {
        this.getQuest().getGame().getQuestLog().addMessage(new QuestLogMessage(this.getDeathMessage()));
    };
    // Public getters
    QuestEntity.prototype.getBerserk = function () {
        return this.berserk;
    };
    QuestEntity.prototype.getCbc = function () {
        return this.cbc;
    };
    QuestEntity.prototype.getDead = function () {
        return this.dead;
    };
    QuestEntity.prototype.getDestructible = function () {
        return this.destructible;
    };
    QuestEntity.prototype.getGlobalPosition = function () {
        return this.globalPosition;
    };
    QuestEntity.prototype.getHealthBar = function () {
        return this.healthBar;
    };
    QuestEntity.prototype.getHp = function () {
        return this.hp;
    };
    QuestEntity.prototype.getIsASpell = function () {
        return this.isASpell;
    };
    QuestEntity.prototype.getJumping = function () {
        return this.jumping;
    };
    QuestEntity.prototype.getLastDamageReason = function () {
        return this.lastDamageReason;
    };
    QuestEntity.prototype.getLastQuestEntitySpellCaster = function () {
        return this.questEntitySpellCasters[this.questEntitySpellCasters.length - 1];
    };
    QuestEntity.prototype.getLastQuestEntityWeapon = function () {
        return this.questEntityWeapons[this.questEntityWeapons.length - 1];
    };
    QuestEntity.prototype.getMaxHp = function () {
        return this.maxHp;
    };
    QuestEntity.prototype.getNaming = function () {
        return this.naming;
    };
    QuestEntity.prototype.getNoMovementLastUpdate = function () {
        return this.noMovementLastUpdate;
    };
    QuestEntity.prototype.getOutOfArea = function () {
        return this.outOfArea;
    };
    QuestEntity.prototype.getQuest = function () {
        return this.quest;
    };
    QuestEntity.prototype.getQuestEntityAnimation = function () {
        return this.questEntityAnimation;
    };
    QuestEntity.prototype.getQuestEntityMovement = function () {
        return this.questEntityMovement;
    };
    QuestEntity.prototype.getQuestEntityWeapons = function () {
        return this.questEntityWeapons;
    };
    QuestEntity.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    QuestEntity.prototype.getRenderAreaPosition = function () {
        return this.renderAreaPosition;
    };
    QuestEntity.prototype.getTeam = function () {
        return this.team;
    };
    QuestEntity.prototype.getTurtle = function () {
        return this.turtle;
    };
    // Public setters
    QuestEntity.prototype.setCanBeForcedToMove = function (canBeForcedToMove) {
        this.canBeForcedToMove = canBeForcedToMove;
    };
    QuestEntity.prototype.setCbc = function (cbc) {
        this.cbc = cbc;
    };
    QuestEntity.prototype.setDead = function (dead) {
        this.dead = dead;
    };
    QuestEntity.prototype.setDestructible = function (value) {
        this.destructible = value;
    };
    QuestEntity.prototype.setHealthBar = function (healthBar) {
        this.healthBar = healthBar;
    };
    QuestEntity.prototype.setHp = function (hp) {
        // BUGS
        if (Bugs.getQuestBugLevel() >= 2)
            hp *= Random.between(1, 5);
        this.hp = hp;
        if (this.hp > this.maxHp)
            this.hp = this.maxHp;
        if (this.hp < 0)
            this.hp = 0;
        this.tryToUpdateHealthBar();
    };
    QuestEntity.prototype.setIsASpell = function (isASpell) {
        this.isASpell = isASpell;
    };
    QuestEntity.prototype.setMaxHp = function (maxHp) {
        // BUGS
        if (Bugs.getQuestBugLevel() >= 4)
            maxHp *= Random.between(1, 5);
        this.maxHp = maxHp;
        this.tryToUpdateHealthBar();
    };
    QuestEntity.prototype.setOutOfArea = function (outOfArea) {
        this.outOfArea = outOfArea;
    };
    QuestEntity.prototype.setQuest = function (quest) {
        this.quest = quest;
    };
    QuestEntity.prototype.setQuestEntityAnimation = function (questEntityAnimation) {
        // We set the animation
        this.questEntityAnimation = questEntityAnimation;
        // We update for the first time if not null
        if (this.questEntityAnimation != null)
            this.questEntityAnimation.draw(this.renderArea);
    };
    QuestEntity.prototype.setQuestEntityMovement = function (questEntityMovement) {
        this.questEntityMovement = questEntityMovement;
    };
    QuestEntity.prototype.setRenderArea = function (renderArea) {
        this.renderArea = renderArea;
    };
    QuestEntity.prototype.setTeam = function (questEntityTeam) {
        this.team = questEntityTeam;
    };
    QuestEntity.prototype.setTransparency = function (transparency) {
        this.transparency = transparency;
    };
    // Private methods
    QuestEntity.prototype.handleAnimation = function () {
        if (this.questEntityAnimation != null) {
            this.questEntityAnimation.update();
            if (this.questEntityAnimation.shouldUpdateRenderAreaAtThisFrame()) {
                this.renderArea.resetAllButSize();
                this.questEntityAnimation.draw(this.renderArea);
            }
        }
    };
    QuestEntity.prototype.handleCombat = function () {
        // We iterate over weapons and use them
        for (var i = 0; i < this.questEntityWeapons.length; i++) {
            this.questEntityWeapons[i].handleCombat();
        }
        // We iterate over spellc asters and use them
        for (var i = 0; i < this.questEntitySpellCasters.length; i++) {
            this.questEntitySpellCasters[i].tryToCast();
        }
    };
    QuestEntity.prototype.handleGravity = function () {
        // If we're jumping, we handle jumping
        if (this.jumping == true) {
            // Decrease the jump duration
            this.jumpDuration -= 1;
            // If this is the last jumping frame, we stop jumping and don't jump at this frame
            if (this.jumpDuration <= 0) {
                this.jumping = false;
                this.controlledFalling = true;
            }
            else {
                // If we don't manage to jump, stop jumping
                if (this.move(new Pos(0, -this.jumpSpeed)) == false) {
                    this.jumping = false;
                    this.controlledFalling = true;
                }
            }
            // Return false so that we can move while jumping
            return false;
        }
        else {
            // If we're not affected by anti-gravity and gravity isn't disabled in the whole quest
            if (this.antiGravity == false && this.getQuest().getGravityDisabled() == false) {
                if (this.questEntityMovement != null && this.questEntityMovement.getGravity()) {
                    if (this.move(new Pos(0, 1))) {
                        if (this.controlledFalling == false)
                            return true; // If we weren't controlling our falling, then we return true because we can't move
                    }
                    else
                        this.controlledFalling = false; // If we hit the ground above, no mroe controlled falling
                }
            }
            else {
                this.antiGravityDuration -= 1;
                if (this.antiGravityDuration <= 0)
                    this.antiGravity = false;
            }
        }
        // Gravity had no effect
        return false;
    };
    QuestEntity.prototype.handleMovement = function () {
        // If we're not stopped
        if (this.stopped == false) {
            if (this.questEntityMovement != null) {
                this.questEntityMovement.update();
                if (this.questEntityMovement.shouldMoveAtThisFrame()) {
                    // If worms like movement is activated and we're not under anti-gravity and worms like movement isn't disabled by the quest
                    if (this.questEntityMovement.getWormsLike() && this.antiGravity == false && this.getQuest().getWormsLikeDisabled() == false) {
                        if (this.moveWormsLike(this.questEntityMovement.getCurrentFrameMovement()))
                            this.noMovementLastUpdate = false;
                    }
                    else {
                        if (this.move(this.questEntityMovement.getCurrentFrameMovement()))
                            this.noMovementLastUpdate = false;
                    }
                }
            }
        }
        else {
            this.stoppedDuration -= 1;
            if (this.stoppedDuration <= 0)
                this.stopped = false;
        }
    };
    QuestEntity.prototype.tryToUpdateHealthBar = function () {
        // Update our health bar if we have one
        if (this.healthBar != null)
            this.healthBar.update();
    };
    return QuestEntity;
})();
///<reference path="QuestEntity.ts"/>
var BigShark = (function (_super) {
    __extends(BigShark, _super);
    // Constructor
    function BigShark(quest, pos) {
        _super.call(this, quest, pos, new Naming("A shark", "a shark"), new RenderArea(47, 10), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(14, 0), new Pos(2, 1)), new CollisionBox(this, new Pos(13, 1), new Pos(2, 1)), new CollisionBox(this, new Pos(12, 2), new Pos(4, 1)), new CollisionBox(this, new Pos(41, 2), new Pos(5, 1)), new CollisionBox(this, new Pos(11, 3), new Pos(7, 1)), new CollisionBox(this, new Pos(35, 3), new Pos(11, 1)), new CollisionBox(this, new Pos(2, 4), new Pos(40, 1)), new CollisionBox(this, new Pos(0, 5), new Pos(40, 1)), new CollisionBox(this, new Pos(1, 6), new Pos(44, 1)), new CollisionBox(this, new Pos(3, 7), new Pos(43, 1)), new CollisionBox(this, new Pos(15, 8), new Pos(3, 1)), new CollisionBox(this, new Pos(16, 9), new Pos(1, 1))), new QuestEntityMovement(new Pos(-1, 0)));
        // By default, finType is null
        this.finType = null;
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(200);
        this.setHp(200);
        // Set the ascii art
        this.getRenderArea().drawArray(Database.getAscii("places/quests/theSea/bigShark"));
        // Set the transparency
        this.setTransparency(new RenderTransparency(" ", "%"));
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("Its sharp teeth", "its sharp teeth"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(49, 12))), Random.between(30, 42)));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setFixedDelay(1);
    }
    // draw()
    BigShark.prototype.draw = function (renderArea) {
        // Mother class draw method
        _super.prototype.draw.call(this, renderArea);
        // Add the fin color if we have a special fin type
        if (this.finType != null) {
            switch (this.finType) {
                case BigSharkFinType.RED:
                    this.drawFinColor(renderArea, ColorType.BIGSHARK_FIN_RED);
                    break;
                case BigSharkFinType.GREEN:
                    this.drawFinColor(renderArea, ColorType.BIGSHARK_FIN_GREEN);
                    break;
                case BigSharkFinType.PURPLE:
                    this.drawFinColor(renderArea, ColorType.BIGSHARK_FIN_PURPLE);
                    break;
            }
        }
    };
    // willDie()
    BigShark.prototype.willDie = function () {
        this.getQuest().getGame().getQuestLog().addMessage(new QuestLogMessage(this.getDeathMessage() + " (and found " + Algo.pluralFormat(this.getQuest().foundCandies(500 + Random.upTo(30) * 35), " candy", " candies") + ")", this.getQuest().getCandiesFoundMessage()));
        if (this.finType != null) {
            switch (this.finType) {
                case BigSharkFinType.RED:
                    this.getQuest().foundGridOrEqItem(new QuestItemFound(this.getQuest(), "gridItemPossessedRedSharkFin", "You found a red shark fin", "You gain a red shark fin"));
                    break;
                case BigSharkFinType.GREEN:
                    this.getQuest().foundGridOrEqItem(new QuestItemFound(this.getQuest(), "gridItemPossessedGreenSharkFin", "You found a green shark fin", "You gain a green shark fin"));
                    break;
                case BigSharkFinType.PURPLE:
                    this.getQuest().foundGridOrEqItem(new QuestItemFound(this.getQuest(), "gridItemPossessedPurpleSharkFin", "You found a purple shark fin", "You gain a purple shark fin"));
                    break;
            }
        }
    };
    // Public methods
    BigShark.prototype.hasFin = function (finType) {
        this.finType = finType;
    };
    // Private methods
    BigShark.prototype.drawFinColor = function (renderArea, colorType) {
        // If the fin color wouldn't be outside of the quest
        if (this.getGlobalPosition().x + this.getRenderAreaPosition().x + this.getQuest().getGlobalDrawingOffset().x + 11 >= 0 &&
            this.getGlobalPosition().x + this.getRenderAreaPosition().x + this.getQuest().getGlobalDrawingOffset().x + 18 <= 99) {
            // We draw it
            renderArea.addBackgroundColor(this.getGlobalPosition().x + this.getQuest().getRealQuestPosition().x + this.getRenderAreaPosition().x + this.getQuest().getGlobalDrawingOffset().x + 14, this.getGlobalPosition().x + this.getQuest().getRealQuestPosition().x + this.getRenderAreaPosition().x + this.getQuest().getGlobalDrawingOffset().x + 15, this.getGlobalPosition().y + this.getQuest().getRealQuestPosition().y + this.getRenderAreaPosition().y + this.getQuest().getGlobalDrawingOffset().y + 0, new Color(colorType));
            renderArea.addBackgroundColor(this.getGlobalPosition().x + this.getQuest().getRealQuestPosition().x + this.getRenderAreaPosition().x + this.getQuest().getGlobalDrawingOffset().x + 13, this.getGlobalPosition().x + this.getQuest().getRealQuestPosition().x + this.getRenderAreaPosition().x + this.getQuest().getGlobalDrawingOffset().x + 15, this.getGlobalPosition().y + this.getQuest().getRealQuestPosition().y + this.getRenderAreaPosition().y + this.getQuest().getGlobalDrawingOffset().y + 1, new Color(colorType));
            renderArea.addBackgroundColor(this.getGlobalPosition().x + this.getQuest().getRealQuestPosition().x + this.getRenderAreaPosition().x + this.getQuest().getGlobalDrawingOffset().x + 12, this.getGlobalPosition().x + this.getQuest().getRealQuestPosition().x + this.getRenderAreaPosition().x + this.getQuest().getGlobalDrawingOffset().x + 16, this.getGlobalPosition().y + this.getQuest().getRealQuestPosition().y + this.getRenderAreaPosition().y + this.getQuest().getGlobalDrawingOffset().y + 2, new Color(colorType));
            renderArea.addBackgroundColor(this.getGlobalPosition().x + this.getQuest().getRealQuestPosition().x + this.getRenderAreaPosition().x + this.getQuest().getGlobalDrawingOffset().x + 11, this.getGlobalPosition().x + this.getQuest().getRealQuestPosition().x + this.getRenderAreaPosition().x + this.getQuest().getGlobalDrawingOffset().x + 18, this.getGlobalPosition().y + this.getQuest().getRealQuestPosition().y + this.getRenderAreaPosition().y + this.getQuest().getGlobalDrawingOffset().y + 3, new Color(colorType));
        }
    };
    return BigShark;
})(QuestEntity);
var BigSharkFinType;
(function (BigSharkFinType) {
    BigSharkFinType[BigSharkFinType["RED"] = 0] = "RED";
    BigSharkFinType[BigSharkFinType["GREEN"] = 1] = "GREEN";
    BigSharkFinType[BigSharkFinType["PURPLE"] = 2] = "PURPLE";
})(BigSharkFinType || (BigSharkFinType = {}));
///<reference path="QuestEntity.ts"/>
var QuestEntitySpell = (function (_super) {
    __extends(QuestEntitySpell, _super);
    // Constructor
    function QuestEntitySpell(quest, pos, naming, renderArea, renderAreaPosition, cbc, questEntityMovement, questEntityAnimation) {
        if (renderArea === void 0) { renderArea = null; }
        if (renderAreaPosition === void 0) { renderAreaPosition = new Pos(0, 0); }
        if (cbc === void 0) { cbc = null; }
        if (questEntityMovement === void 0) { questEntityMovement = null; }
        if (questEntityAnimation === void 0) { questEntityAnimation = null; }
        _super.call(this, quest, pos, naming, renderArea, renderAreaPosition, cbc, questEntityMovement, questEntityAnimation);
        // Colors
        this.colors = [];
        // Set isASpell
        this.setIsASpell(true);
    }
    // Public methods
    QuestEntitySpell.prototype.addColor = function (color) {
        this.colors.push(color);
    };
    QuestEntitySpell.prototype.draw = function (renderArea) {
        // Call the mother class draw method
        _super.prototype.draw.call(this, renderArea);
        // Draw the colors
        for (var i = 0; i < this.colors.length; i++) {
            this.colors[i].draw(renderArea, this.getQuest().getRealQuestPosition().plus(this.getGlobalPosition()).plus(this.getQuest().getGlobalDrawingOffset()));
        }
    };
    QuestEntitySpell.prototype.removeColors = function () {
        this.colors = [];
    };
    return QuestEntitySpell;
})(QuestEntity);
///<reference path="QuestEntitySpell.ts"/>
var Blackhole = (function (_super) {
    __extends(Blackhole, _super);
    // Constructor
    function Blackhole(quest, pos, damage, questEntityDamageReason) {
        // Call the mother class constructor
        _super.call(this, quest, pos, new Naming("A blackhole", "a blackhole"));
        // Set from parameters
        this.damage = damage;
        this.questEntityDamageReason = questEntityDamageReason;
        // Create the collision box collection
        this.cbcDamage = new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -3), new Pos(2, 1)), new CollisionBox(this, new Pos(-3, -2), new Pos(6, 1)), new CollisionBox(this, new Pos(-4, -1), new Pos(8, 1)), new CollisionBox(this, new Pos(-5, 0), new Pos(10, 1)), new CollisionBox(this, new Pos(-4, 1), new Pos(8, 1)), new CollisionBox(this, new Pos(-3, 2), new Pos(6, 1)), new CollisionBox(this, new Pos(-1, 3), new Pos(2, 1)));
        // Set the timer
        this.timer = 30;
        // Set the colors for the first time
        this.reAddColors();
    }
    // Public methods
    Blackhole.prototype.update = function () {
        // Lower the timer
        this.timer -= 1;
        // Re add the colors
        this.reAddColors();
        // Inflict damage to any entity under us
        for (var i = 0; i < this.getQuest().getEntities().length; i++) {
            // If it is destructible
            if (this.getQuest().getEntities()[i].getDestructible()) {
                // If it has a collision box collection
                if (this.getQuest().getEntities()[i].getCbc() != null) {
                    // If this collision box collection collides with ours
                    if (this.getQuest().getEntities()[i].getCbc().collidesWith(this.cbcDamage)) {
                        this.getQuest().getEntities()[i].inflictDamage(this.damage, this.questEntityDamageReason);
                    }
                }
            }
        }
        // If the timer is too low, we're dead!
        if (this.timer <= 0)
            this.setDead(true);
        // Call the mother class update method
        _super.prototype.update.call(this);
    };
    // Private methods
    Blackhole.prototype.addColorsFirstLayer = function (colorType) {
        this.addColor(new QuestEntitySpellColor(this.getQuest(), new Pos(-1, 0), new Pos(2, 1), new Color(colorType, true)));
    };
    Blackhole.prototype.addColorsSecondLayer = function (colorType) {
        this.addColor(new QuestEntitySpellColor(this.getQuest(), new Pos(-2, -1), new Pos(4, 1), new Color(colorType, true)));
        this.addColor(new QuestEntitySpellColor(this.getQuest(), new Pos(-2, +1), new Pos(4, 1), new Color(colorType, true)));
        this.addColor(new QuestEntitySpellColor(this.getQuest(), new Pos(-2, 0), new Pos(1, 1), new Color(colorType, true)));
        this.addColor(new QuestEntitySpellColor(this.getQuest(), new Pos(+1, 0), new Pos(1, 1), new Color(colorType, true)));
    };
    Blackhole.prototype.addColorsThirdLayer = function (colorType) {
        this.addColor(new QuestEntitySpellColor(this.getQuest(), new Pos(-1, -3), new Pos(2, 1), new Color(colorType, true)));
        this.addColor(new QuestEntitySpellColor(this.getQuest(), new Pos(-3, -2), new Pos(6, 1), new Color(colorType, true)));
        this.addColor(new QuestEntitySpellColor(this.getQuest(), new Pos(-4, -1), new Pos(2, 1), new Color(colorType, true)));
        this.addColor(new QuestEntitySpellColor(this.getQuest(), new Pos(+2, -1), new Pos(2, 1), new Color(colorType, true)));
        this.addColor(new QuestEntitySpellColor(this.getQuest(), new Pos(-5, 0), new Pos(3, 1), new Color(colorType, true)));
        this.addColor(new QuestEntitySpellColor(this.getQuest(), new Pos(+2, 0), new Pos(3, 1), new Color(colorType, true)));
        this.addColor(new QuestEntitySpellColor(this.getQuest(), new Pos(-4, +1), new Pos(2, 1), new Color(colorType, true)));
        this.addColor(new QuestEntitySpellColor(this.getQuest(), new Pos(+2, +1), new Pos(2, 1), new Color(colorType, true)));
        this.addColor(new QuestEntitySpellColor(this.getQuest(), new Pos(-3, +2), new Pos(6, 1), new Color(colorType, true)));
        this.addColor(new QuestEntitySpellColor(this.getQuest(), new Pos(-1, +3), new Pos(2, 1), new Color(colorType, true)));
    };
    Blackhole.prototype.reAddColors = function () {
        // Remove the colors
        this.removeColors();
        // Re add them
        switch (this.timer) {
            case 30:
                this.addColorsFirstLayer(ColorType.BLACKHOLE_GREY240);
                break;
            case 29:
                this.addColorsFirstLayer(ColorType.BLACKHOLE_GREY220);
                this.addColorsSecondLayer(ColorType.BLACKHOLE_GREY240);
                break;
            case 28:
                this.addColorsFirstLayer(ColorType.BLACKHOLE_GREY200);
                this.addColorsSecondLayer(ColorType.BLACKHOLE_GREY220);
                this.addColorsThirdLayer(ColorType.BLACKHOLE_GREY240);
                break;
            case 27:
                this.addColorsFirstLayer(ColorType.BLACKHOLE_GREY180);
                this.addColorsSecondLayer(ColorType.BLACKHOLE_GREY200);
                this.addColorsThirdLayer(ColorType.BLACKHOLE_GREY220);
                break;
            case 26:
                this.addColorsFirstLayer(ColorType.BLACKHOLE_GREY160);
                this.addColorsSecondLayer(ColorType.BLACKHOLE_GREY180);
                this.addColorsThirdLayer(ColorType.BLACKHOLE_GREY200);
                break;
            case 25:
                this.addColorsFirstLayer(ColorType.BLACKHOLE_GREY140);
                this.addColorsSecondLayer(ColorType.BLACKHOLE_GREY160);
                this.addColorsThirdLayer(ColorType.BLACKHOLE_GREY180);
                break;
            case 24:
                this.addColorsFirstLayer(ColorType.BLACKHOLE_GREY120);
                this.addColorsSecondLayer(ColorType.BLACKHOLE_GREY140);
                this.addColorsThirdLayer(ColorType.BLACKHOLE_GREY160);
                break;
            case 23:
                this.addColorsFirstLayer(ColorType.BLACKHOLE_GREY100);
                this.addColorsSecondLayer(ColorType.BLACKHOLE_GREY120);
                this.addColorsThirdLayer(ColorType.BLACKHOLE_GREY140);
                break;
            case 22:
                this.addColorsFirstLayer(ColorType.BLACKHOLE_GREY80);
                this.addColorsSecondLayer(ColorType.BLACKHOLE_GREY100);
                this.addColorsThirdLayer(ColorType.BLACKHOLE_GREY120);
                break;
            case 21:
                this.addColorsFirstLayer(ColorType.BLACKHOLE_GREY60);
                this.addColorsSecondLayer(ColorType.BLACKHOLE_GREY80);
                this.addColorsThirdLayer(ColorType.BLACKHOLE_GREY100);
                break;
            case 20:
                this.addColorsFirstLayer(ColorType.BLACKHOLE_GREY40);
                this.addColorsSecondLayer(ColorType.BLACKHOLE_GREY60);
                this.addColorsThirdLayer(ColorType.BLACKHOLE_GREY80);
                break;
            case 19:
                this.addColorsFirstLayer(ColorType.BLACKHOLE_GREY20);
                this.addColorsSecondLayer(ColorType.BLACKHOLE_GREY40);
                this.addColorsThirdLayer(ColorType.BLACKHOLE_GREY60);
                break;
            default:
                this.addColorsFirstLayer(Random.fromArray([ColorType.BLACKHOLE_GREY20, ColorType.BLACKHOLE_GREY40, ColorType.BLACKHOLE_GREY60]));
                this.addColorsSecondLayer(Random.fromArray([ColorType.BLACKHOLE_GREY20, ColorType.BLACKHOLE_GREY40, ColorType.BLACKHOLE_GREY60]));
                this.addColorsThirdLayer(Random.fromArray([ColorType.BLACKHOLE_GREY20, ColorType.BLACKHOLE_GREY40, ColorType.BLACKHOLE_GREY60]));
                break;
        }
    };
    return Blackhole;
})(QuestEntitySpell);
var QuestEntityWeapon = (function () {
    // Constructor
    function QuestEntityWeapon(quest, questEntity, naming, cbc, damage) {
        if (cbc === void 0) { cbc = new CollisionBoxCollection(); }
        if (damage === void 0) { damage = 0; }
        this.closeCombatDelay = new QuestEntityWeaponDelay();
        this.quest = quest;
        this.questEntity = questEntity;
        this.naming = naming;
        this.damage = damage;
        this.cbc = cbc;
    }
    // Public methods
    QuestEntityWeapon.prototype.getRealDamage = function () {
        return this.damage;
    };
    QuestEntityWeapon.prototype.getRealDamageText = function () {
        return this.damage.toString();
    };
    QuestEntityWeapon.prototype.getSpeedText = function () {
        return this.closeCombatDelay.getText();
    };
    QuestEntityWeapon.prototype.handleCombat = function () {
        // If we can attack with close combat at this frame
        if (this.getRealDamage() > 0 && this.closeCombatDelay.tryToAttack()) {
            // We iterate over all entities
            for (var i = 0; i < this.quest.getEntities().length; i++) {
                // If we're not iterating over the entity we are used by
                if (this.quest.getEntities()[i] != this.questEntity) {
                    // If the entities are from different teams
                    if (this.quest.getEntities()[i].getTeam() != this.questEntity.getTeam()) {
                        // If we collide with this entity
                        if (this.collidesWith(this.quest.getEntities()[i])) {
                            // We hit it
                            this.hit(this.quest.getEntities()[i]);
                            // We warn the delay
                            this.closeCombatDelay.theWeaponAttacked();
                        }
                    }
                }
            }
        }
    };
    // Public getters
    QuestEntityWeapon.prototype.getCloseCombatDelay = function () {
        return this.closeCombatDelay;
    };
    QuestEntityWeapon.prototype.getNaming = function () {
        return this.naming;
    };
    // Private methods
    QuestEntityWeapon.prototype.collidesWith = function (questEntity) {
        // If we both have a collision box collection, we return the result of the collision test
        if (this.cbc != null && questEntity.getCbc() != null)
            return this.cbc.collidesWith(questEntity.getCbc());
        // Else, we return false, there can't be any collision
        return false;
    };
    QuestEntityWeapon.prototype.hit = function (questEntity) {
        this.questEntity.hit(questEntity, this.getRealDamage(), new QuestEntityDamageReason(QuestEntityDamageReasonWhoType.ENTITY, QuestEntityDamageReasonWhatType.WEAPON)
            .setQuestEntity(this.questEntity)
            .setQuestEntityWeapon(this));
    };
    return QuestEntityWeapon;
})();
///<reference path="QuestEntityWeapon.ts"/>
var Bludgeon = (function (_super) {
    __extends(Bludgeon, _super);
    function Bludgeon() {
        _super.apply(this, arguments);
    }
    // Public methods
    Bludgeon.prototype.getRealDamage = function () {
        return Random.between(15, 25);
    };
    Bludgeon.prototype.getRealDamageText = function () {
        return "15-25";
    };
    return Bludgeon;
})(QuestEntityWeapon);
var Item = (function () {
    // Constructor
    function Item(savingName, databaseName, databaseDescriptionName, ascii) {
        // We set the variables
        this.savingName = savingName;
        this.databaseName = databaseName;
        this.databaseDescriptionName = databaseDescriptionName;
        this.ascii = ascii;
        // We register the savingName
        Saving.registerBool(this.savingName, false);
    }
    // Public methods
    Item.prototype.foundCandies = function (player, quest, howMany) {
        return howMany;
    };
    Item.prototype.hit = function (player, quest, questEntity, damage, reason) {
        return damage;
    };
    Item.prototype.inflictDamage = function (player, quest, damage, reason) {
        return damage;
    };
    Item.prototype.isPossessed = function () {
        return Saving.loadBool(this.savingName);
    };
    // Public getters
    Item.prototype.getAscii = function () {
        return this.ascii;
    };
    Item.prototype.getDatabaseDescriptionName = function () {
        return this.databaseDescriptionName;
    };
    Item.prototype.getDatabaseName = function () {
        return this.databaseName;
    };
    Item.prototype.getSavingName = function () {
        return this.savingName;
    };
    Item.prototype.getSpecialAbility = function () {
        return null;
    };
    return Item;
})();
///<reference path="Item.ts"/>
var EqItem = (function (_super) {
    __extends(EqItem, _super);
    function EqItem() {
        _super.apply(this, arguments);
    }
    // Public methods    
    EqItem.prototype.update = function (player, quest) {
    };
    // Public getters
    EqItem.prototype.getQuestEntityWeapon = function (quest, player) {
        return new QuestEntityWeapon(quest, player, new Naming("???", "???"));
    };
    return EqItem;
})(Item);
///<reference path="EqItem.ts"/>
var BootsOfIntrospection = (function (_super) {
    __extends(BootsOfIntrospection, _super);
    // Constructor
    function BootsOfIntrospection() {
        _super.call(this, "eqItemBootsBootsOfIntrospection", "eqItemBootsBootsOfIntrospectionName", "eqItemBootsBootsOfIntrospectionDescription", "eqItems/boots/bootsOfIntrospection");
    }
    return BootsOfIntrospection;
})(EqItem);
///<reference path="Place.ts"/>
var Quest = (function (_super) {
    __extends(Quest, _super);
    // Constructor
    function Quest(game, specialInstruction) {
        if (specialInstruction === void 0) { specialInstruction = null; }
        _super.call(this, game);
        // Array of quest entities
        this.entities = [];
        // Render area
        this.renderArea = new RenderArea();
        this.globalDrawingOffset = new Pos(0, 0); // Global offset applied to all entities (very useful when dealing with a scrolling quest like the hole for example)
        // Drops
        this.candiesFound = new Resource();
        this.chocolateBarsFound = new Resource();
        this.itemsFound = [];
        // Is the quest ended? (and did we win?)
        this.questEnded = false;
        this.questEndedAndWeWon = false;
        // Player spells
        this.playerSpells = [];
        this.playerSpellsHotkeys = [];
        // Countdowns
        this.playerSpellsCountdown = 0;
        this.playerPotionsCountdown = 0;
        // Is gravity / worms like disabled?
        this.gravityDisabled = false;
        this.wormsLikeDisabled = false;
        // How many P potions did we use since the beginning of the quest?
        this.howManyPPotions = 0;
        // Set the special instruction
        this.specialInstruction = specialInstruction;
        // Reset the player
        this.getGame().resetPlayer();
        // Create player spells
        this.createPlayerSpells();
        // Set the real quest position
        this.realQuestPosition = new Pos(0, 2);
        // And the size to add to the real quest size
        this.sizeToAddToTheRealQuestSize = new Pos(0, 12);
        // If there is a special instruction, change the real quest position
        if (this.specialInstruction != null) {
            this.realQuestPosition.add(new Pos(0, 1));
        }
        // If there is at least a spell, change the real quest position
        if (this.playerSpells.length != 0) {
            this.realQuestPosition.add(new Pos(0, this.playerSpellsHeight));
        }
        // Add two delimiters in the quest log
        this.getGame().getQuestLog().addDelimiter();
        // Create the player collision boxes entity
        this.playerCollisionBoxes = new Wall(this, new Pos(0, 0));
        // Set the quest slowed down variable at the game level (and the quest speed up too)
        this.getGame().setQuestSlowedDown(false);
        this.getGame().setQuestSpeedUp(0);
    }
    // Public methods
    Quest.prototype.addPlayerCollisionBoxes = function (top, right, bottom, left) {
        // We remove boxes
        this.playerCollisionBoxes.removeBoxes();
        // And we re-add them
        if (top)
            this.playerCollisionBoxes.addBox(new Pos(-1, -1), new Pos(this.getRealQuestSize().x + 2, 1));
        if (right)
            this.playerCollisionBoxes.addBox(new Pos(this.getRealQuestSize().x, -1), new Pos(1, this.getRealQuestSize().y + 2));
        if (bottom)
            this.playerCollisionBoxes.addBox(new Pos(-1, this.getRealQuestSize().y), new Pos(this.getRealQuestSize().x + 2, 1));
        if (left)
            this.playerCollisionBoxes.addBox(new Pos(-1, -1), new Pos(1, this.getRealQuestSize().y + 2));
    };
    Quest.prototype.addEntity = function (entity) {
        // Add the entity
        this.entities.push(entity);
        // If it collides, remove it and return false (+ BUGS)
        if (this.entities[this.entities.length - 1].checkCollision() && Bugs.getQuestBugLevel() < 4) {
            this.entities.splice(this.entities.length - 1, 1);
            return false;
        }
        // Else, successfully added, we return true
        return true;
    };
    Quest.prototype.addExitQuestButton = function (callbackCollection, buttonText) {
        this.addBackToButton(this.renderArea, callbackCollection, Database.getText(buttonText), Database.getTranslatedText(buttonText), buttonText, 0, ((this.renderArea.getWidth() - 100) - this.getGap()) / 2 + (50 - Database.getText(buttonText).length / 2));
    };
    Quest.prototype.castPlayerAcidRain = function (areaPosition, areaSize, maxLeftDistanceFromPlayer, maxRightDistanceFromPlayer) {
        if (areaPosition === void 0) { areaPosition = null; }
        if (areaSize === void 0) { areaSize = null; }
        if (maxLeftDistanceFromPlayer === void 0) { maxLeftDistanceFromPlayer = 50; }
        if (maxRightDistanceFromPlayer === void 0) { maxRightDistanceFromPlayer = 50; }
        // We set the position & size of the area of the acid rain
        if (areaPosition == null)
            areaPosition = new Pos(0, 0);
        if (areaSize == null)
            areaSize = new Pos(this.getRealQuestSize().x, this.getRealQuestSize().y);
        // Correct the position to fit with the max left and right distance from player
        if (areaPosition.x < this.getGame().getPlayer().getGlobalPosition().x - maxLeftDistanceFromPlayer)
            areaPosition.x = this.getGame().getPlayer().getGlobalPosition().x - maxLeftDistanceFromPlayer;
        if (areaPosition.x + areaSize.x > this.getGame().getPlayer().getGlobalPosition().x + maxRightDistanceFromPlayer)
            areaSize.x = this.getGame().getPlayer().getGlobalPosition().x + maxRightDistanceFromPlayer - areaPosition.x;
        // Add the acid drops in the area
        for (var i = areaPosition.x; i < areaPosition.x + areaSize.x; i++) {
            if (Random.oneChanceOutOf((this.getGame().isEquipped("hat", "eqItemHatSorceressHat") ? 3 : 5))) {
                this.addEntity(this.createPlayerAcidDrop(new Pos(i, areaPosition.y - Random.upTo(5))));
            }
        }
        // Add a message to the log
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You cast an acid rain!"));
    };
    Quest.prototype.castPlayerAntiGravityPotion = function () {
        this.getGame().getPlayer().beginAntiGravity((this.getGame().isEquipped("hat", "eqItemHatSorceressHat") ? 50 : 30));
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You drink an anti gravity potion!"));
    };
    Quest.prototype.castPlayerBlackDemons = function () {
        // X position where the demons will start
        var xPosition = 0;
        // Y position of the beginning of the demon column
        var yBeginningPosition = 0;
        // Y position of the end of the demon column
        var yEndingPosition = this.getRealQuestSize().y;
        // We try to add demons from the beginning to the end, every five characters
        for (var i = yBeginningPosition; i < yEndingPosition; i++) {
            if (i % 5 == 0)
                this.addEntity(new PlayerSummonedDemon(this, new Pos(xPosition, i), (this.getGame().isEquipped("hat", "eqItemHatSorceressHat") ? 80 : 50)));
        }
        // Add a message to the log
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You summoned black demons!"));
    };
    Quest.prototype.castPlayerBlackhole = function () {
        // Array which will contain the indices (in the entities array) of all possible enemies
        var indices = [];
        // The blackhole position
        var position;
        // Fill the indices array
        for (var i = 0; i < this.getEntities().length; i++) {
            // If this entity is destructible and is from a different team then the player
            if (this.getEntities()[i].getDestructible() && this.getEntities()[i].getTeam() != this.getGame().getPlayer().getTeam()) {
                // We add its index
                indices.push(i);
            }
        }
        // We get the position of the blackhole from the position of a random destructible and not in the player's team entity, or if there's isn't any, from the player's position
        if (indices.length > 0) {
            position = this.getEntities()[indices[Random.between(0, indices.length - 1)]].getRenderAreaCenter();
        }
        else {
            position = this.getGame().getPlayer().getRenderAreaCenter();
        }
        // We cast the blackhole on the position we just set
        this.addEntity(new Blackhole(this, position, 100, this.getGame().getPlayer().getAndPossiblyCreateSpellCastingDamageReason(new Naming("A blackhole", "a blackhole"))));
        // We add the message
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You cast the black hole spell!"));
    };
    Quest.prototype.castPlayerBerserkPotion = function () {
        this.getGame().getPlayer().beginBerserk((this.getGame().isEquipped("hat", "eqItemHatSorceressHat") ? 120 : 80));
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You drink a berserk potion!"));
    };
    Quest.prototype.castPlayerCloningPotion = function () {
        // The clone to be added
        var clone = null;
        // Create a different clone depnding on the character type
        switch (this.getGame().getPlayer().getCharacterType()) {
            case PlayerCharacterType.CANDYBOX:
            case PlayerCharacterType.CANDYBOX_SQUEEZED:
                clone = new PlayerCloneCandyBox(this, this.getGame().getPlayer().getGlobalPosition().plus(new Pos(0, -1)));
                break;
            case PlayerCharacterType.MEDIUM:
            case PlayerCharacterType.MEDIUM_SQUEEZED:
                clone = new PlayerCloneMedium(this, this.getGame().getPlayer().getGlobalPosition().plus(new Pos(0, -4)));
                break;
        }
        // If we didn't manage to add this clone (this could fail because it may not have enough space to be added)
        if (this.addEntity(clone) == false) {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You drink a cloning potion but there's not enough space for a clone to appear."));
            return; // We return
        }
        // Else, config the clone as a player (this config method is made to be overriden by the daughter classes)
        this.configPlayerOrClone(clone);
        // Add the message
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You drink a cloning potion!"));
    };
    Quest.prototype.castPlayerEraseMagic = function () {
        // Will be true if at least one spell was erased
        var magicErased = false;
        // Set dead to all the spells
        for (var i = 0; i < this.getEntities().length; i++) {
            if (this.getEntities()[i].getIsASpell()) {
                this.getEntities()[i].setDead(true);
                magicErased = true;
            }
        }
        // If some spell was erase, we successfully casted the spell
        if (magicErased)
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You cast an erase magic spell!"));
        else
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You failed to cast an erase magic spell : there's no magic to erase."));
    };
    Quest.prototype.castPlayerFireball = function (movement) {
        if (movement === void 0) { movement = new Pos(2, 0); }
        // Create the fireball
        var fireball = new Fireball(this, this.getGame().getPlayer().getSpellCastingPosition(), new Naming("A fireball", "a fireball"), new Color(ColorType.PLAYER_FIREBALL), new Pos((this.getGame().isEquipped("hat", "eqItemHatSorceressHat") ? 6 : 4), (this.getGame().isEquipped("hat", "eqItemHatSorceressHat") ? 3 : 2)), 45 * (Saving.loadBool("gridItemPossessedRedSharkFin") ? 3 : 1), this.getGame().getPlayer().getAndPossiblyCreateSpellCastingDamageReason(new Naming("A fireball", "a fireball")));
        // No target
        fireball.setTargetTypeNoTarget(movement);
        // Add the entity
        this.addEntity(fireball);
        // Add a message to the log
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You cast a fireball!"));
    };
    Quest.prototype.castPlayerHealthPotion = function () {
        this.getGame().getPlayer().heal((this.getGame().isEquipped("hat", "eqItemHatSorceressHat") ? 200 : 100));
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You drink a health potion!"));
    };
    Quest.prototype.castPlayerJump = function () {
        // If we don't have the feather
        if (Saving.loadBool("gridItemPossessedFeather") == false)
            this.getGame().getPlayer().jump(3);
        else
            this.getGame().getPlayer().jump(6);
    };
    Quest.prototype.castPlayerObsidianWall = function () {
        // X position of the wall
        var xPosition = this.getGame().getPlayer().getSpellCastingPosition().x;
        // Beginning of the wall
        var yBeginningPosition = 0;
        // End of the wall
        var yEndingPosition = this.getRealQuestSize().y;
        // We try to add bricks from the beginning to the end
        for (var i = yBeginningPosition; i < yEndingPosition; i++) {
            this.addEntity(new ObsidianBrick(this, new Pos(xPosition, i), (this.getGame().isEquipped("hat", "eqItemHatSorceressHat") ? 300 : 200)));
        }
        // Add a message to the log
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You cast an obsidian wall!"));
    };
    Quest.prototype.castPlayerPPotion = function () {
        // Variables which will be used for calculations
        var hp;
        // Additional message, depends on the effect
        var additionalMessage = null;
        // If the player is a turtle
        if (this.getGame().getPlayer().getTurtle()) {
            // We're not a turtle anymore
            this.getGame().getPlayer().stopTurtle();
            // We lose half of our health points
            hp = Math.ceil(this.getGame().getPlayer().getHp() / 2);
            this.getGame().getPlayer().heal(-hp);
            // Set the message
            additionalMessage = "You lose " + hp + " health points.";
        }
        else if (this.getGame().getPlayer().getHp() < (this.getGame().getPlayer().getMaxHp() * 8 / 100)) {
            // Choose between the following
            switch (Random.between(0, 8)) {
                case 0:
                    this.getGame().getPlayer().heal(200);
                    additionalMessage = "You gain 200 health points.";
                    break; // Heal 200 hp
                case 1:
                    this.getGame().getPlayer().heal(400);
                    additionalMessage = "You gain 400 health points.";
                    break; // Heal 400 hp
                case 2:
                    this.getGame().getPlayer().heal(600);
                    additionalMessage = "You gain 600 health points.";
                    break; // Heal 600 hp
                case 3:
                    hp = this.getGame().getPlayer().getMaxHp() * 50 / 100;
                    this.getGame().getPlayer().heal(hp);
                    additionalMessage = "You gain " + hp + " health points.";
                    break; // Heal 50%
                case 4:
                    hp = this.getGame().getPlayer().getMaxHp() * 65 / 100;
                    this.getGame().getPlayer().heal(hp);
                    additionalMessage = "You gain " + hp + " health points.";
                    break; // Heal 65%
                case 5:
                    hp = this.getGame().getPlayer().getMaxHp() * 80 / 100;
                    this.getGame().getPlayer().heal(hp);
                    additionalMessage = "You gain " + hp + " health points.";
                    break; // Heal 80%
                case 6:
                    this.getGame().getPlayer().heal(10);
                    additionalMessage = "You gain 10 health points.";
                    break; // Wow, not very effective : heal 10hp
                case 7:
                    this.getGame().getPlayer().heal(7);
                    additionalMessage = "You gain 7 health points.";
                    break; // Wow, not very effective : heal 7hp
                case 8:
                    this.getGame().getPlayer().heal(3);
                    additionalMessage = "You gain 3 health points.";
                    break; // Wow, not very effective : heal 3hp
            }
        }
        else {
            // Normal effect
            if (Random.oneChanceOutOf(Math.ceil((this.howManyPPotions + 1) / 2))) {
                // 20%/30% of our health points
                hp = this.getGame().getPlayer().getMaxHp() * (Random.flipACoin() ? 20 : 30) / 100;
                // We lose those health points
                if (Random.oneChanceOutOf(3)) {
                    this.getGame().getPlayer().heal(-hp);
                    additionalMessage = "You lose " + hp + " health points.";
                }
                else {
                    this.getGame().getPlayer().heal(hp);
                    additionalMessage = "You gain " + hp + " health points.";
                }
            }
            else if (Random.oneChanceOutOf(Math.ceil((this.howManyPPotions + 1) / 6))) {
                switch (Random.between(0, 3)) {
                    case 0:
                        this.getGame().getPlayer().stop(Random.between(30, 100));
                        additionalMessage = "You can't move anymore.";
                        break;
                    case 1:
                        this.getGame().getPlayer().beginTurtle(Random.between(30, 100));
                        additionalMessage = "Now you're a turtle!";
                        break;
                    case 2:
                        this.getGame().getPlayer().setHp(this.getGame().getPlayer().getMaxHp());
                        additionalMessage = "You recover all your health.";
                        break;
                    case 3:
                        this.getGame().getPlayer().setHp(10);
                        additionalMessage = "You only have 10 health points now. Great.";
                        break;
                }
            }
            else {
                this.getGame().getQuestLog().addMessage(new QuestLogMessage("You drink a P potion! Something strange is happening."));
                switch (Random.between(0, 2)) {
                    case 0:
                        this.castPlayerAcidRain();
                        this.castPlayerFireball();
                        this.castPlayerTeleport();
                        break;
                    case 1:
                        this.castPlayerAcidRain();
                        this.castPlayerAcidRain();
                        this.castPlayerAcidRain();
                        this.castPlayerTeleport();
                        break;
                    case 2:
                        this.castPlayerFireball();
                        this.castPlayerTeleport();
                        this.castPlayerFireball();
                        this.castPlayerTeleport();
                        this.castPlayerFireball();
                        this.castPlayerTeleport();
                        this.castPlayerFireball();
                        break;
                }
                this.getGame().getQuestLog().addMessage(new QuestLogMessage("Wait. What did you just do?"));
            }
        }
        // Increase the number of used P potions
        this.howManyPPotions += 1;
        // Add a message to the log
        if (additionalMessage != null)
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You drink a P potion! " + additionalMessage));
    };
    Quest.prototype.castPlayerThornsShield = function () {
        // Create the thorns positions array, which will contain all the positions where we want to add thorns
        var positions = this.getGame().getPlayer().getThornsPositionsArray();
        // Add the thorns
        for (var i = 0; i < positions.length; i++) {
            // Create the thorn
            var thorn = new Fireball(this, this.getGame().getPlayer().getGlobalPosition().plus(positions[i]), new Naming("A magical thorn", "a magical thorn"), new Color(ColorType.PLAYER_THORN), new Pos(2, 1), (this.getGame().isEquipped("hat", "eqItemHatSorceressHat") ? 40 : 20), this.getGame().getPlayer().getAndPossiblyCreateSpellCastingDamageReason(new Naming("A magical thorn", "a magical thorn")));
            // Add the entity
            this.addEntity(thorn);
        }
        // Add a message to the log
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You cast a thorns shield!"));
    };
    Quest.prototype.castPlayerTurtlePotion = function () {
        this.getGame().getPlayer().beginTurtle((this.getGame().isEquipped("hat", "eqItemHatSorceressHat") ? 120 : 80));
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You drink a turtle potion!"));
    };
    Quest.prototype.castPlayerSqueeze = function () {
        if (this.getGame().getPlayer().getQuestEntityMovement() != null)
            this.getGame().getPlayer().squeeze();
    };
    Quest.prototype.castPlayerTeleport = function (where, teleportArea) {
        if (where === void 0) { where = null; }
        if (teleportArea === void 0) { teleportArea = null; }
        var teleportSucceeded = false;
        var teleportPosition;
        // If there's a special position to teleport the player, but no teleport area (which means we want to teleport it to this precise point only)
        if (where != null && teleportArea == null) {
            // If we manage to teleport here
            if (this.getGame().getPlayer().teleport(where))
                teleportSucceeded = true;
        }
        else {
            // Find where the teleport area will begin
            if (where == null)
                where = new Pos(0, 0);
            // Find the size of the teleport area
            if (teleportArea == null)
                teleportArea = new Pos(this.getRealQuestSize().x - 1, this.getRealQuestSize().y - 1);
            // We try to teleport 10 times in the teleport area, if one time succeed then it's okay, else the teleport fails
            for (var i = 0; i < 10; i++) {
                teleportPosition = where.plus(Random.fromPosition(teleportArea));
                // If we're not trying to teleport where we already are and the teleport succeed
                if (teleportPosition != this.getGame().getPlayer().getGlobalPosition() && this.getGame().getPlayer().teleport(teleportPosition)) {
                    teleportSucceeded = true;
                    break;
                }
            }
        }
        // Show a message depending on teleportSucceeded
        if (teleportSucceeded) {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You cast a teleport spell!"));
        }
        else {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You failed to cast the teleport spell. Magic works in mysterious ways..."));
        }
    };
    Quest.prototype.castPlayerTimeSlowing = function () {
        // We invert questSlowedDown
        this.getGame().setQuestSlowedDown(!this.getGame().getQuestSlowedDown());
    };
    Quest.prototype.castPlayerXPotion = function () {
        this.getGame().goToYourself();
    };
    Quest.prototype.configPlayerOrClone = function (entity) {
    };
    Quest.prototype.drawAroundQuest = function () {
        // Draw the player spells
        this.drawPlayerSpells();
        // Draw the special instruction
        this.drawSpecialInstruction();
        // Draw the quest log
        this.drawQuestLog();
    };
    Quest.prototype.drawEntities = function () {
        for (var i = 0; i < this.entities.length; i++) {
            // Let the entity draw itself
            this.entities[i].draw(this.renderArea);
            // Should we draw a health bar ?
            if (this.entities[i].getHealthBar() != null)
                this.entities[i].getHealthBar().draw(this.renderArea);
        }
    };
    Quest.prototype.endQuest = function (win) {
        // If the player won the quest
        if (win) {
            // Handle candies drops
            // We add a message to the log to tell about the candies we found
            this.getGame().getQuestLog().addMessage(new QuestLogMessage(this.getCandiesDropMessage()));
            // We give him/her the candies found during the quest
            this.candiesFound.transferTo(this.getGame().getCandies());
            // Handle chocolate bars drops
            if (this.chocolateBarsFound.getCurrent() > 0) {
                // We add a message to the log to tell about the chocolate bars we found
                this.getGame().getQuestLog().addMessage(new QuestLogMessage(this.getChocolateBarsDropMessage(), null, true));
                // We give him/her the chocolate bars found during the quest
                this.chocolateBarsFound.transferTo(this.getGame().getChocolateBars());
            }
            // Handle items drops
            for (var i = 0; i < this.itemsFound.length; i++) {
                // We show the drop message
                this.itemsFound[i].get();
                // We give him/her the item
                this.getGame().gainItem(this.itemsFound[i].getSavingName());
            }
            // We won
            this.questEndedAndWeWon = true;
        }
        // The quest ended !
        this.questEnded = true;
    };
    Quest.prototype.foundCandies = function (howMany) {
        // We check all eqItems in case they want to change how many candies were found
        for (var savingName in this.getGame().getSelectedEqItems()) {
            howMany = this.getGame().getSelectedEqItems()[savingName].foundCandies(this.getGame().getPlayer(), this, howMany);
        }
        // We add the candies found
        this.candiesFound.add(howMany);
        // We return the number of candies found
        return howMany;
    };
    Quest.prototype.foundChocolateBars = function (howMany) {
        // We add the chocolate bars found
        this.chocolateBarsFound.add(howMany);
        // We return the number of chocolate bars found
        return howMany;
    };
    Quest.prototype.foundGridOrEqItem = function (itemFound) {
        // If we already have this item, we return false
        if (Saving.loadBool(itemFound.getSavingName()) == true)
            return false;
        // If we already found this item during this quest, we return false
        for (var i = 0; i < this.itemsFound.length; i++) {
            if (itemFound.getSavingName() == this.itemsFound[i].getSavingName())
                return false;
        }
        // We add the item to our found array, tell it that we found it, and return true
        this.itemsFound.push(itemFound);
        this.itemsFound[this.itemsFound.length - 1].found();
        return true;
    };
    Quest.prototype.forceMovingAllEntities = function (movement) {
        for (var i = 0; i < this.entities.length; i++) {
            this.entities[i].forceMoving(movement);
        }
    };
    Quest.prototype.getCandiesDropMessage = function () {
        return "You gain " + Algo.pluralFormat(this.candiesFound.getCurrent(), " candy", " candies") + ".";
    };
    Quest.prototype.getCandiesFoundMessage = function () {
        return "(" + this.candiesFound.getCurrentAsString() + " found so far)";
    };
    Quest.prototype.getChocolateBarsDropMessage = function () {
        return "You gain " + Algo.pluralFormat(this.chocolateBarsFound.getCurrent(), " chocolate bar", " chocolate bars") + ".";
    };
    Quest.prototype.increasePlayerPotionsCountdown = function (howMuch) {
        this.playerPotionsCountdown += howMuch;
    };
    Quest.prototype.increasePlayerSpellsCountdown = function (howMuch) {
        this.playerSpellsCountdown += howMuch;
    };
    Quest.prototype.lowerCountdowns = function () {
        // Lower spells countdown
        if (this.playerSpellsCountdown > 0)
            this.playerSpellsCountdown -= 1;
        // Lower potions countdown
        if (this.playerPotionsCountdown > 0)
            this.playerPotionsCountdown -= 1;
    };
    Quest.prototype.postDraw = function () {
        this.getGame().updatePlace();
    };
    Quest.prototype.preDraw = function () {
        // Reset the area
        this.renderArea.resetAllButSize();
    };
    Quest.prototype.resizeQuest = function (width, height, forcedRealQuestSize) {
        if (forcedRealQuestSize === void 0) { forcedRealQuestSize = null; }
        // Set the real quest drawing size
        this.realQuestDrawingSize = new Pos(width, height);
        // Set the real quest size
        if (forcedRealQuestSize == null)
            this.realQuestSize = new Pos(width, height);
        else
            this.realQuestSize = forcedRealQuestSize;
        // Resize the area
        this.renderArea.resize(this.realQuestPosition.x + width + this.sizeToAddToTheRealQuestSize.x, this.realQuestPosition.y + height + this.sizeToAddToTheRealQuestSize.y); // We add ten for the quest log !
    };
    Quest.prototype.update = function () { };
    Quest.prototype.updateEntities = function () {
        // We store the current length before calling update stuff
        var length = this.entities.length;
        // Call the update function on each entity
        for (var i = 0; i < length; i++) {
            this.entities[i].update();
        }
        // Iterate over entities for removal (the only thing they can't do by themselves..)
        for (var i = 0; i < this.entities.length; i++) {
            // If the entity should die, we remove it and we make the appropriate callback
            if (this.entities[i].shouldDie()) {
                this.entities[i].willDie();
                this.entities[i].setDead(true);
                this.entities.splice(i, 1);
                i--;
            }
            else if (this.entities[i].isOutOfArea()) {
                this.entities[i].setOutOfArea(true);
                this.entities.splice(i, 1);
                i--;
            }
        }
        // Lower countdowns
        this.lowerCountdowns();
    };
    Quest.prototype.willBeDisplayed = function () {
        // Some some stuff needed because we start questing
        this.getGame().setWeAreQuesting(true);
        this.getGame().getQuestCallbackCollection().addCallback(this.update.bind(this));
        // Add some hotkeys
        for (var i = 0; i < this.playerSpellsHotkeys.length; i++) {
            this.getGame().addHotkey(this.playerSpellsHotkeys[i]);
        }
    };
    Quest.prototype.willBeClosed = function () {
        this.getGame().setWeAreQuesting(false);
    };
    // Public getters
    Quest.prototype.getBottomLimit = function () {
        return 20;
    };
    Quest.prototype.getCandiesFound = function () {
        return this.candiesFound;
    };
    Quest.prototype.getChocolateBarsFound = function () {
        return this.chocolateBarsFound;
    };
    Quest.prototype.getEntities = function () {
        return this.entities;
    };
    Quest.prototype.getGap = function () {
        // We find the perfect gap so that the player would be in the center
        var gap = (this.renderArea.getWidth() - 100) - (this.getGame().getPlayer().getGlobalPosition().x - 50) * 2;
        // We possibly correct this gap to keep the quest in the center if the player is in the left or right of the quest
        if (gap > (this.renderArea.getWidth() - 100))
            gap = (this.renderArea.getWidth() - 100);
        if (gap < -(this.renderArea.getWidth() - 100))
            gap = -(this.renderArea.getWidth() - 100);
        // We return the possibly corrected gap
        return gap;
    };
    Quest.prototype.getGlobalDrawingOffset = function () {
        return this.globalDrawingOffset;
    };
    Quest.prototype.getGravityDisabled = function () {
        return this.gravityDisabled;
    };
    Quest.prototype.getLastEntity = function () {
        return this.entities[this.entities.length - 1];
    };
    Quest.prototype.getLeftLimit = function () {
        return 20;
    };
    Quest.prototype.getPlayerCollisionBoxes = function () {
        return this.playerCollisionBoxes;
    };
    Quest.prototype.getPlayerPotionsCountdown = function () {
        return this.playerPotionsCountdown;
    };
    Quest.prototype.getPlayerSpellsCountdown = function () {
        return this.playerSpellsCountdown;
    };
    Quest.prototype.getQuestEnded = function () {
        return this.questEnded;
    };
    Quest.prototype.getQuestEndedAndWeWon = function () {
        return this.questEndedAndWeWon;
    };
    Quest.prototype.getRealQuestDrawingSize = function () {
        return this.realQuestDrawingSize;
    };
    Quest.prototype.getRealQuestPosition = function () {
        return this.realQuestPosition;
    };
    Quest.prototype.getRealQuestSize = function () {
        return this.realQuestSize;
    };
    Quest.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    Quest.prototype.getRightLimit = function () {
        return 20;
    };
    Quest.prototype.getTopLimit = function () {
        return 20;
    };
    Quest.prototype.getWormsLikeDisabled = function () {
        return this.wormsLikeDisabled;
    };
    // Public setters
    Quest.prototype.setGlobalDrawingOffset = function (globalDrawingOffset) {
        this.globalDrawingOffset = globalDrawingOffset;
    };
    Quest.prototype.setGravityDisabled = function (gravityDisabled) {
        this.gravityDisabled = gravityDisabled;
    };
    Quest.prototype.setWormsLikeDisabled = function (wormsLikeDisabled) {
        this.wormsLikeDisabled = wormsLikeDisabled;
    };
    // Private methods
    Quest.prototype.addPlayerSpell = function (playerSpell) {
        this.playerSpells.push(playerSpell);
        this.playerSpellsHotkeys.push(playerSpell.getHotkey());
    };
    Quest.prototype.createPlayerAcidDrop = function (position) {
        var acidDrop = new Fireball(this, position, new Naming("An acid drop", "an acid drop"), new Color(ColorType.PLAYER_ACID_DROP), new Pos(1, 1), 8, this.getGame().getPlayer().getAndPossiblyCreateSpellCastingDamageReason(new Naming("An acid drop", "an acid drop")));
        // No target
        acidDrop.setTargetTypeNoTarget(new Pos(0, 1));
        // Return the acid drop
        return acidDrop;
    };
    Quest.prototype.createPlayerSpells = function () {
        // Add the spells
        if (Saving.loadBool("gridItemPossessedBeginnersGrimoire")) {
            this.addPlayerSpell(new QuestPlayerSpell(this, "questPlayerSpellAcidRainButton", new Pos(0, 0), "Acid rain", new Color(ColorType.QUEST_BUTTON_ACID_RAIN), new CallbackCollection(this.castPlayerAcidRain.bind(this)), QuestPlayerSpellCountdownType.SPELLS, this.getMagicCountdownTime(), 0, "a"));
            this.addPlayerSpell(new QuestPlayerSpell(this, "questPlayerSpellFireballButton", new Pos(11, 0), "Fireball", new Color(ColorType.QUEST_BUTTON_FIREBALL), new CallbackCollection(this.castPlayerFireball.bind(this)), QuestPlayerSpellCountdownType.SPELLS, this.getMagicCountdownTime(), 0, "f"));
            this.addPlayerSpell(new QuestPlayerSpell(this, "questPlayerSpellTeleportButton", new Pos(21, 0), "Teleport", new Color(ColorType.QUEST_BUTTON_TELEPORT), new CallbackCollection(this.castPlayerTeleport.bind(this)), QuestPlayerSpellCountdownType.SPELLS, this.getMagicCountdownTime(), 0, "t"));
        }
        if (Saving.loadBool("gridItemPossessedAdvancedGrimoire")) {
            this.addPlayerSpell(new QuestPlayerSpell(this, "questPlayerSpellEraseMagicButton", new Pos(33, 0), "Erase magic", new Color(ColorType.QUEST_BUTTON_ERASE_MAGIC), new CallbackCollection(this.castPlayerEraseMagic.bind(this)), QuestPlayerSpellCountdownType.SPELLS, this.getMagicCountdownTime(), 0, "e"));
            this.addPlayerSpell(new QuestPlayerSpell(this, "questPlayerSpellThornsShieldButton", new Pos(46, 0), "Thorns shield", new Color(ColorType.QUEST_BUTTON_THORNS_SHIELD), new CallbackCollection(this.castPlayerThornsShield.bind(this)), QuestPlayerSpellCountdownType.SPELLS, this.getMagicCountdownTime(), 6, " "));
        }
        if (Saving.loadBool("gridItemPossessedBlackMagicGrimoire")) {
            this.addPlayerSpell(new QuestPlayerSpell(this, "questPlayerSpellObsidianWallButton", new Pos(63, 0), "Obsidian wall", new Color(ColorType.QUEST_BUTTON_OBSIDIAN_WALL), new CallbackCollection(this.castPlayerObsidianWall.bind(this)), QuestPlayerSpellCountdownType.SPELLS, this.getMagicCountdownTime(), 0, "o"));
            this.addPlayerSpell(new QuestPlayerSpell(this, "questPlayerSpellBlackDemonsButton", new Pos(78, 0), "Black demons", new Color(ColorType.QUEST_BUTTON_BLACK_DEMONS), new CallbackCollection(this.castPlayerBlackDemons.bind(this)), QuestPlayerSpellCountdownType.SPELLS, this.getMagicCountdownTime(), 6, "d"));
        }
        // Add the potions
        if (Saving.loadBool("questPlayerSpellHealthPotionHasSpell"))
            this.addPlayerSpell(new QuestPlayerSpell(this, "questPlayerSpellHealthPotionButton", new Pos(0, 2), "Health", new Color(ColorType.QUEST_BUTTON_HEALTH_POTION), new CallbackCollection(this.castPlayerHealthPotion.bind(this)), QuestPlayerSpellCountdownType.POTIONS, this.getMagicCountdownTime(), 0, "h", "questPlayerSpellHealthPotionQuantity"));
        if (Saving.loadBool("questPlayerSpellTurtlePotionHasSpell"))
            this.addPlayerSpell(new QuestPlayerSpell(this, "questPlayerSpellTurtlePotionButton", new Pos(13, 2), "Turtle", new Color(ColorType.QUEST_BUTTON_TURTLE_POTION), new CallbackCollection(this.castPlayerTurtlePotion.bind(this)), QuestPlayerSpellCountdownType.POTIONS, this.getMagicCountdownTime(), 2, "r", "questPlayerSpellTurtlePotionQuantity"));
        if (Saving.loadBool("questPlayerSpellAntiGravityPotionHasSpell"))
            this.addPlayerSpell(new QuestPlayerSpell(this, "questPlayerSpellAntiGravityPotionButton", new Pos(26, 2), "Anti gravity", new Color(ColorType.QUEST_BUTTON_ANTI_GRAVITY_POTION), new CallbackCollection(this.castPlayerAntiGravityPotion.bind(this)), QuestPlayerSpellCountdownType.POTIONS, this.getMagicCountdownTime(), 5, "g", "questPlayerSpellAntiGravityPotionQuantity"));
        if (Saving.loadBool("questPlayerSpellBerserkPotionHasSpell"))
            this.addPlayerSpell(new QuestPlayerSpell(this, "questPlayerSpellBerserkPotionButton", new Pos(45, 2), "Berserk", new Color(ColorType.QUEST_BUTTON_BERSERK_POTION), new CallbackCollection(this.castPlayerBerserkPotion.bind(this)), QuestPlayerSpellCountdownType.POTIONS, this.getMagicCountdownTime(), 0, "b", "questPlayerSpellBerserkPotionQuantity"));
        if (Saving.loadBool("questPlayerSpellCloningPotionHasSpell"))
            this.addPlayerSpell(new QuestPlayerSpell(this, "questPlayerSpellCloningPotionButton", new Pos(59, 2), "Cloning", new Color(ColorType.QUEST_BUTTON_CLONING_POTION), new CallbackCollection(this.castPlayerCloningPotion.bind(this)), QuestPlayerSpellCountdownType.POTIONS, this.getMagicCountdownTime(), 0, "c", "questPlayerSpellCloningPotionQuantity"));
        if (Saving.loadBool("questPlayerSpellPPotionHasSpell"))
            this.addPlayerSpell(new QuestPlayerSpell(this, "questPlayerSpellPPotionButton", new Pos(73, 2), "P", new Color(ColorType.QUEST_BUTTON_P_POTION), new CallbackCollection(this.castPlayerPPotion.bind(this)), QuestPlayerSpellCountdownType.POTIONS, this.getMagicCountdownTime(), 0, "p", "questPlayerSpellPPotionQuantity"));
        if (Saving.loadBool("questPlayerSpellXPotionHasSpell"))
            this.addPlayerSpell(new QuestPlayerSpell(this, "questPlayerSpellXPotionButton", new Pos(81, 2), "X", new Color(ColorType.QUEST_BUTTON_X_POTION), new CallbackCollection(this.castPlayerXPotion.bind(this)), QuestPlayerSpellCountdownType.POTIONS, this.getMagicCountdownTime(), 0, "x", "questPlayerSpellXPotionQuantity"));
        // Add the capacities granted by objects
        if (Saving.loadBool("gridItemPossessedTimeRing"))
            this.addPlayerSpell(new QuestPlayerSpell(this, "questPlayerSpellTimeSlowingButton", new Pos(0, 4), "Time slowing", new Color(ColorType.QUEST_BUTTON_SOME_OBJECT), new CallbackCollection(this.castPlayerTimeSlowing.bind(this)), QuestPlayerSpellCountdownType.ITEM_CAPACITIES, 0, 8, "w"));
        if (Saving.loadBool("gridItemPossessedPogoStick"))
            this.addPlayerSpell(new QuestPlayerSpell(this, "questPlayerSpellJumpButton", new Pos(14, 4), "Jump", new Color(ColorType.QUEST_BUTTON_SOME_OBJECT), new CallbackCollection(this.castPlayerJump.bind(this)), QuestPlayerSpellCountdownType.ITEM_CAPACITIES, 0, 0, "j"));
        if (Saving.loadBool("gridItemPossessedSponge"))
            this.addPlayerSpell(new QuestPlayerSpell(this, "questPlayerSpellSqueezeButton", new Pos(20, 4), "Squeeze", new Color(ColorType.QUEST_BUTTON_SOME_OBJECT), new CallbackCollection(this.castPlayerSqueeze.bind(this)), QuestPlayerSpellCountdownType.ITEM_CAPACITIES, 0, 0, "s"));
        // Add the special spell granted by the purple shark fin
        if (Saving.loadBool("gridItemPossessedPurpleSharkFin"))
            this.addPlayerSpell(new QuestPlayerSpell(this, "questPlayerSpell", new Pos(38, 4), "Black hole spell (purple shark fin) (once per quest)", new Color(ColorType.QUEST_BLACKHOLE_SPELL), new CallbackCollection(this.castPlayerBlackhole.bind(this)), QuestPlayerSpellCountdownType.BLACKHOLE, 1, 4, "k"));
        // Set the player spells height from the max height found in all the spells added
        this.playerSpellsHeight = 0;
        for (var i = 0; i < this.playerSpells.length; i++) {
            if (this.playerSpells[i].getButtonPosition().y > this.playerSpellsHeight)
                this.playerSpellsHeight = this.playerSpells[i].getButtonPosition().y;
        }
        this.playerSpellsHeight += 1; // Add one because for example if the highest spell is at 0 we need a 1 height
        this.playerSpellsHeight += 1; // Add one to make a clear separation with the real quest
    };
    Quest.prototype.drawPlayerSpells = function () {
        // If there's at least one player spell
        if (this.playerSpells.length > 0) {
            var baseXPosition = ((this.renderArea.getWidth() - 100) - this.getGap()) / 2;
            // Draw the spells
            for (var i = 0; i < this.playerSpells.length; i++) {
                this.playerSpells[i].draw(this.renderArea, new Pos(baseXPosition, 2));
            }
            // Draw the spell countdown
            if (this.playerSpellsCountdown > 0) {
                this.renderArea.drawString("(" + Math.ceil(this.playerSpellsCountdown / 10).toString() + " sec)", baseXPosition + 92, 2);
                this.renderArea.addColor(baseXPosition + 92, baseXPosition + 100, 2, new Color(ColorType.QUEST_COUNTDOWN));
            }
            // Draw the potion countdown
            if (this.playerPotionsCountdown > 0) {
                this.renderArea.drawString("(" + Math.ceil(this.playerPotionsCountdown / 10).toString() + " sec)", baseXPosition + 92, 4);
                this.renderArea.addColor(baseXPosition + 92, baseXPosition + 100, 4, new Color(ColorType.QUEST_COUNTDOWN));
            }
        }
    };
    Quest.prototype.drawQuestLog = function () {
        this.getGame().getQuestLog().draw(this.renderArea, new Pos(((this.renderArea.getWidth() - 100) - this.getGap()) / 2, this.renderArea.getHeight() - 12));
    };
    Quest.prototype.drawSpecialInstruction = function () {
        if (this.specialInstruction != null) {
            this.renderArea.drawString(this.specialInstruction, this.realQuestPosition.x, this.realQuestPosition.y - 1);
            this.renderArea.addBold(this.realQuestPosition.x, this.realQuestPosition.x + this.specialInstruction.length, this.realQuestPosition.y - 1);
        }
    };
    Quest.prototype.getMagicCountdownTime = function () {
        var time = 0;
        // If we have the sorceress hat, the base time is 50
        if (this.getGame().isEquipped("hat", "eqItemHatSorceressHat"))
            time = 50;
        else
            time = 80;
        // Reduce the time thanks to the magic gift
        time -= time * (Saving.loadNumber("gameGiftMagic") * 15 / 100);
        // Set the time to 0 if it is < 0 (which shouldn't happen anyway, but you know, since some people will probably modify the game variables by themselves it's better if we try to avoid bugs)
        if (time < 0)
            time = 0;
        // Return the time
        return time;
    };
    return Quest;
})(Place);
///<reference path="Quest.ts"/>
var Bridge = (function (_super) {
    __extends(Bridge, _super);
    // Constructor
    function Bridge(game) {
        _super.call(this, game);
        // Resize the quest
        this.resizeQuest(138, 32);
        // Add collision boxes around
        this.addPlayerCollisionBoxes(true, false, false, true);
        // Add the player
        this.getGame().getPlayer().loadCandyBoxCharacter(this);
        this.getGame().getPlayer().setGlobalPosition(new Pos(0, 17));
        this.configPlayerOrClone(this.getGame().getPlayer());
        this.addEntity(this.getGame().getPlayer());
        // Add a wall at the bridge position
        this.addBridgeFloor();
        // Add the troll
        this.addTroll();
        // Add the message
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You're trying to cross the bridge. A huge troll is blocking your way!"));
    }
    // Public methods
    Bridge.prototype.configPlayerOrClone = function (entity) {
        entity.setQuestEntityMovement(new QuestEntityMovement(new Pos(1, 0)));
        entity.getQuestEntityMovement().setGravity(true);
        entity.getQuestEntityMovement().setWormsLike(true);
    };
    Bridge.prototype.endQuest = function (win) {
        // We add some messages
        if (win) {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You managed to cross the bridge!"));
            Saving.saveBool("mainMapDoneBridge", true); // The bridge is done
        }
        else {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You didn't manage to cross the bridge."));
        }
        // We call the endQuest method of our mother class
        _super.prototype.endQuest.call(this, win);
    };
    Bridge.prototype.update = function () {
        if (this.getQuestEnded() == false) {
            // Test if the player won the quest, if so, end the quest and return
            if (this.thePlayerWon()) {
                this.endQuest(true);
                return;
            }
            // Test if the player is dead, if so, end the quest and return
            if (this.getGame().getPlayer().shouldDie()) {
                this.endQuest(false);
                return;
            }
            // Update entities
            this.updateEntities();
        }
        // Draw
        this.preDraw();
        this.getRenderArea().drawArray(Database.getAscii("places/quests/bridge/bridge"), this.getRealQuestPosition().x, this.getRealQuestPosition().y + 17);
        this.drawEntities();
        this.drawAroundQuest();
        if (this.getQuestEnded() == false)
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestNoKeeping");
        else if (this.getQuestEndedAndWeWon() == false)
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestNoKeepingBecauseLose");
        else
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestKeeping");
        this.postDraw();
    };
    // Private methods
    Bridge.prototype.addBridgeFloor = function () {
        // Create the wall
        var wall = new Wall(this, new Pos(0, 18));
        // Add boxes
        wall.addBox(new Pos(0, 0), new Pos(138, 2));
        wall.addBox(new Pos(3, 2), new Pos(10, 1));
        wall.addBox(new Pos(6, 3), new Pos(4, 11));
        wall.addBox(new Pos(64, 2), new Pos(10, 1));
        wall.addBox(new Pos(67, 3), new Pos(4, 11));
        wall.addBox(new Pos(126, 2), new Pos(10, 1));
        wall.addBox(new Pos(129, 3), new Pos(4, 11));
        // Add the wall to the quest
        this.addEntity(wall);
    };
    Bridge.prototype.addTroll = function () {
        var troll = new Troll(this, new Pos(100, 8));
        troll.setQuestEntityMovement(new QuestEntityMovement(new Pos(-1, 0), 12));
        troll.setHealthBar(new QuestEntityHealthBar(troll, new Pos(100, 1), new Pos(0, 0), QuestEntityHealthBarPositionType.FIXED_ON_PAGE, true, true, BarType.HEALTH));
        this.addEntity(troll);
    };
    Bridge.prototype.thePlayerWon = function () {
        // If the player is at the right of the desert, we return true
        if (this.getGame().getPlayer().getGlobalPosition().x >= 138)
            return true;
        // Else we return false
        return false;
    };
    return Bridge;
})(Quest);
var Bugs;
(function (Bugs) {
    // Variables
    var graphicalBugLevel = 0;
    var questBugLevel = 0;
    var ultimateBugLevel = 0;
    // Various functions
    function changeRandomCharacter(str) {
        var index = Random.between(0, str.length - 1);
        return str.substr(0, index) + getRandomCharacter() + str.substr(index + 1);
    }
    Bugs.changeRandomCharacter = changeRandomCharacter;
    function getRandomCharacter() {
        return Random.fromArray(["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
            "#", "_", "/", "-", "+", "*", "^", ";", ",", ".", ":", "!", "§", "$", "£", "ù", "è", "à", "@", ")", "(", "|", "]", "}", "{", "(",
            "~", "é", "<", ">", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "%", "`", "'", "ç"]);
    }
    Bugs.getRandomCharacter = getRandomCharacter;
    // Getters
    function getGraphicalBugLevel() {
        return graphicalBugLevel;
    }
    Bugs.getGraphicalBugLevel = getGraphicalBugLevel;
    function getQuestBugLevel() {
        return questBugLevel;
    }
    Bugs.getQuestBugLevel = getQuestBugLevel;
    function getUltimateBugLevel() {
        return ultimateBugLevel;
    }
    Bugs.getUltimateBugLevel = getUltimateBugLevel;
    // Setters    
    function setGraphicalBugLevel(graphicalBugLevel_) {
        graphicalBugLevel = graphicalBugLevel_;
    }
    Bugs.setGraphicalBugLevel = setGraphicalBugLevel;
    function setQuestBugLevel(questBugLevel_) {
        questBugLevel = questBugLevel_;
    }
    Bugs.setQuestBugLevel = setQuestBugLevel;
    function setUltimateBugLevel(ultimateBugLevel_) {
        ultimateBugLevel = ultimateBugLevel_;
    }
    Bugs.setUltimateBugLevel = setUltimateBugLevel;
})(Bugs || (Bugs = {}));
///<reference path="QuestEntity.ts"/>
var Camazotz = (function (_super) {
    __extends(Camazotz, _super);
    // Constructor
    function Camazotz(quest, pos) {
        _super.call(this, quest, pos, new Naming("Camazotz, the bat god", "Camazotz, the bat god"), new RenderArea(22, 8), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(8, 1), new Pos(6, 2)), new CollisionBox(this, new Pos(2, 3), new Pos(18, 1)), new CollisionBox(this, new Pos(1, 4), new Pos(20, 1)), new CollisionBox(this, new Pos(0, 5), new Pos(22, 1)), new CollisionBox(this, new Pos(9, 6), new Pos(4, 1)), new CollisionBox(this, new Pos(10, 7), new Pos(2, 1))), new QuestEntityMovement());
        // Set the drop a demon timer default value
        this.resetDropADemonTimer();
        // Set the default distance from the player
        this.distanceFromPlayer = 5;
        // Set the default tryToMoveAgainTimer
        this.tryToMoveAgainTimer = 0;
        // Set gravity
        this.getQuestEntityMovement().setGravity(false);
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(5000);
        this.setHp(5000);
        // Set the ascii art and the transparent character
        this.getRenderArea().drawArray(Database.getAscii("places/quests/hell/camazotz"));
        this.setTransparency(new RenderTransparency(" ", "%"));
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("Its claws", "its claws"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, 0), new Pos(24, 9))), 300));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setBetweenDelay(20, 100); // This delay because Camazotz is quite busy throwing enemies to the player
    }
    // update()
    Camazotz.prototype.update = function () {
        // Handle the movement towards the player
        this.handleMovementTowardsPlayer();
        // Handle demon dropping
        this.handleDropADemon();
        // Call the mother class update method
        _super.prototype.update.call(this);
    };
    // willeDie()
    Camazotz.prototype.willDie = function () {
        this.getQuest().getGame().getQuestLog().addMessage(new QuestLogMessage(this.getDeathMessage() + " (and found " + Algo.pluralFormat(this.getQuest().foundCandies(1000000), " candy", " candies") + ")", this.getQuest().getCandiesFoundMessage()));
    };
    // Private methods
    Camazotz.prototype.dropADemon = function () {
        // Create the demon
        var demon = new Demon(this.getQuest(), this.getGlobalPosition().plus(new Pos(8, 8)));
        // Set the health bar
        demon.setHealthBar(new QuestEntityHealthBar(demon, new Pos(6, 1)));
        // Add the demon
        this.getQuest().addEntity(demon);
    };
    Camazotz.prototype.handleDropADemon = function () {
        // If it's time to add one
        if (this.dropADemonTimer < 0) {
            // Drop a demon and reset the timer
            this.dropADemon();
            this.resetDropADemonTimer();
        }
        else {
            // Decrese the timer
            this.dropADemonTimer -= 1;
        }
    };
    Camazotz.prototype.handleMovementTowardsPlayer = function () {
        // If we try to move
        if (this.tryToMoveAgainTimer <= 0) {
            // We go towards the player
            this.goTowards(this.getGlobalPosition(), this.getQuest().getGame().getPlayer().getGlobalPosition().plus(new Pos(this.distanceFromPlayer, 0)), 2, new Pos(2, 0), true);
            // We'll try to move again in 3 frames
            this.tryToMoveAgainTimer = 3;
        }
        else {
            this.tryToMoveAgainTimer -= 1;
        }
    };
    Camazotz.prototype.resetDropADemonTimer = function () {
        this.dropADemonTimer = Random.between(8, 12);
    };
    return Camazotz;
})(QuestEntity);
///<reference path="QuestEntity.ts"/>
var Camel = (function (_super) {
    __extends(Camel, _super);
    // Constructor
    function Camel(quest, pos) {
        _super.call(this, quest, pos, new Naming("A camel", "a camel"), new RenderArea(7, 2), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 0), new Pos(6, 1)), new CollisionBox(this, new Pos(2, 1), new Pos(5, 1))), new QuestEntityMovement());
        // Set gravity
        this.getQuestEntityMovement().setGravity(true);
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(7);
        this.setHp(7);
        // Set the ascii art and the transparent character
        this.getRenderArea().drawArray(Database.getAscii("places/quests/desert/camel"));
        this.setTransparency(new RenderTransparency(" "));
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("Its long neck", "its long neck"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, 0), new Pos(3, 3))), 5));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setBetweenDelay(5, 7);
    }
    // Public methods
    Camel.prototype.willDie = function () {
        this.getQuest().getGame().getQuestLog().addMessage(new QuestLogMessage(this.getDeathMessage() + " (and found " + Algo.pluralFormat(this.getQuest().foundCandies(5 + Random.upTo(5)), " candy", " candies") + ")", this.getQuest().getCandiesFoundMessage()));
    };
    return Camel;
})(QuestEntity);
///<reference path="Resource.ts"/>
var StatusBarResource = (function (_super) {
    __extends(StatusBarResource, _super);
    // Constructor
    function StatusBarResource(game, savingPrefix) {
        _super.call(this, savingPrefix);
        this.game = game;
    }
    // Public setters
    StatusBarResource.prototype.setCurrent = function (n, reCalcPlayerMaxHp) {
        if (reCalcPlayerMaxHp === void 0) { reCalcPlayerMaxHp = false; }
        _super.prototype.setCurrent.call(this, n);
        if (reCalcPlayerMaxHp)
            this.game.getPlayer().reCalcMaxHp();
        else
            this.game.updateStatusBar();
    };
    return StatusBarResource;
})(Resource);
///<reference path="StatusBarResource.ts"/>
var Candies = (function (_super) {
    __extends(Candies, _super);
    // Constructor
    function Candies(game, savingPrefix) {
        _super.call(this, game, savingPrefix);
    }
    // Public methods
    Candies.prototype.getCurrentAsString = function (totalSize) {
        if (totalSize === void 0) { totalSize = 10; }
        var n = this.getCurrent();
        var size = totalSize;
        var base = "";
        var prefix = "";
        var suffix = "";
        var comment = "";
        // We set the base or return right now in some special cases
        if (n < 0)
            return "What, negative candies?!";
        else if (n == 1)
            return "You have 1 candy";
        else {
            if (n == 1337)
                base = "leet";
            else
                base = Algo.numberToStringButNicely(n);
        }
        // How much space do we still have ?
        size = totalSize - base.length;
        // We set the suffix
        if (size >= 8) {
            suffix = " candies";
            // We add a prefix
            // How much space do we still have ?
            size = totalSize - base.length - suffix.length;
            // We set the prefix
            if (size >= 9)
                prefix = "You have ";
            else if (size >= 3)
                prefix = "-> ";
        }
        else if (size >= 4)
            suffix = " cnd";
        else if (size >= 2)
            suffix = " c";
        // How much space do we still have ?
        size = totalSize - base.length - prefix.length - suffix.length;
        // We possibly set a comment
        if (n == 42 && size >= 4)
            comment = " \\o/";
        else if ((n == 65535 || n == 314159) && size >= 1)
            comment = "!";
        return prefix + base + suffix + comment;
    };
    return Candies;
})(StatusBarResource);
///<reference path="StatusBarResource.ts"/>
var CandiesEaten = (function (_super) {
    __extends(CandiesEaten, _super);
    // Constructor
    function CandiesEaten(game, savingPrefix) {
        _super.call(this, game, savingPrefix);
    }
    // Public methods
    CandiesEaten.prototype.getCurrentAsString = function () {
        var n = this.getCurrent();
        if (n < 0)
            return "You have eaten negative candies ?!";
        else if (n == 1)
            return "You have eaten 1 candy";
        else {
            return "You have eaten " + Algo.numberToStringButNicely(n) + " candies";
        }
    };
    // Public setters
    CandiesEaten.prototype.setCurrent = function (n) {
        _super.prototype.setCurrent.call(this, n, true);
    };
    return CandiesEaten;
})(StatusBarResource);
///<reference path="Resource.ts"/>
Saving.registerBool("candiesThrownGotChocolateBar", false);
var CandiesThrown = (function (_super) {
    __extends(CandiesThrown, _super);
    // Constructor
    function CandiesThrown(game, savingPrefix) {
        _super.call(this, savingPrefix);
        // Smileys
        this.smileys = [new CandiesThrownSmileyFirstLine("."),
            new CandiesThrownSmileyFirstLine("..."),
            new CandiesThrownSmileyFirstLine("...?"),
            new CandiesThrownSmileyFirstLine("...? :|"),
            new CandiesThrownSmileyFirstLine("...? :/"),
            new CandiesThrownSmileyFirstLine("...? :("),
            new CandiesThrownSmileyFirstLine("...? :["),
            new CandiesThrownSmileyFirstLine("...? :{"),
            new CandiesThrownSmileyFirstLine("...? :'("),
            new CandiesThrownSmileyFirstLine("...? (;_;)"),
            new CandiesThrownSmileyFirstLine("...?  (;_;)"),
            new CandiesThrownSmileyFirstLine("...?   (;_;)"),
            new CandiesThrownSmileyFirstLine("...?    (;_;)"),
            new CandiesThrownSmileyFirstLine("...?   (;_;)"),
            new CandiesThrownSmileyFirstLine("...?  (;_;)"),
            new CandiesThrownSmileyFirstLine("...? (;_;)"),
            new CandiesThrownSmileyFirstLine("...? (;__;)"),
            new CandiesThrownSmileyFirstLine("...? (;___;)"),
            new CandiesThrownSmileyFirstLine("...? (;__;)"),
            new CandiesThrownSmileyFirstLine("...? (;_;)"),
            new CandiesThrownSmileyFirstLine("...? (;.;)"),
            new CandiesThrownSmileyFirstLine("...? (:.:)"),
            new CandiesThrownSmileyFirstLine("...? (:_:)"),
            new CandiesThrownSmileyFirstLine("...? (;_;)"),
            new CandiesThrownSmileyFirstLine("...?(;_;)"),
            new CandiesThrownSmileyFirstLine("...? (;_;)"),
            new CandiesThrownSmileyFirstLine("...?(;_;)"),
            new CandiesThrownSmileyFirstLine("...? (;_;)"),
            new CandiesThrownSmileyFirstLine("...?(;_;)"),
            new CandiesThrownSmileyFirstLine("...? (;_;)"),
            new CandiesThrownSmileyFirstLine("...? (;_;) come"),
            new CandiesThrownSmileyFirstLine("...? (;_;) come on"),
            new CandiesThrownSmileyFirstLine("...? (-_-) come on"),
            new CandiesThrownSmileyFirstLine("...? (-_-)"),
            new CandiesThrownSmileyFirstLine("...? (-_-) why are you throwing candies like that?"),
            new CandiesThrownSmileyFirstLine("...? (o_o)"),
            new CandiesThrownSmileyFirstLine("...? (o_o) I'm gonna destroy something if you don't stop!!"),
            new CandiesThrownSmileyFirstLine("...? (o_o)"),
            new CandiesThrownSmileyFirstLine("...?  (o_o)"),
            new CandiesThrownSmileyFirstLine("...?   (o_o)"),
            new CandiesThrownSmileyFirstLine("...?    (o_o)"),
            new CandiesThrownSmileyFirstLine("...?     (o_o)"),
            new CandiesThrownSmileyFirstLine("...?      (o_o)"),
            new CandiesThrownSmileyFirstLine("...?       (o_o)"),
            new CandiesThrownSmileyFirstLine("...?       (O_O)"),
            new CandiesThrownSmileyFirstLine("...?      (O_O)"),
            new CandiesThrownSmileyFirstLine("...?     (O_O)"),
            new CandiesThrownSmileyFirstLine("...?    (O_O)"),
            new CandiesThrownSmileyFirstLine("...?   (O_O)"),
            new CandiesThrownSmileyFirstLine("...?  (O_O)"),
            new CandiesThrownSmileyFirstLine("...? (O_O)"),
            new CandiesThrownSmileyFirstLine("...?(O_O)"),
            new CandiesThrownSmileyFirstLine("...(O_O)"),
            new CandiesThrownSmileyFirstLine("..(O_O)"),
            new CandiesThrownSmileyFirstLine(".(O_O)"),
            new CandiesThrownSmileyFirstLine("(O_O)"),
            new CandiesThrownSmileyFirstLine(" (O_O)"),
            new CandiesThrownSmileyFirstLine(" (o_o)"),
            new CandiesThrownSmileyFirstLine(" (o_o)"),
            new CandiesThrownSmileyFirstLine(" (o_o)"),
            new CandiesThrownSmileyFirstLine(" (o_o)"),
            new CandiesThrownSmileyFirstLine(" (o_o) stop!!"),
            new CandiesThrownSmileyFirstLine(" (o_o)"),
            new CandiesThrownSmileyFirstLine(" (o_o)"),
            new CandiesThrownSmileyFirstLine(" (;_;)"),
            new CandiesThrownSmileyFirstLine(" (;_;) well."),
            new CandiesThrownSmileyFirstLine(" (;_;) I guess I'll just leave, then."),
            new CandiesThrownSmileyFirstLine("  (;_;)"),
            new CandiesThrownSmileyFirstLine("   (;_;)"),
            new CandiesThrownSmileyFirstLine("    (;_;)"),
            new CandiesThrownSmileyFirstLine("     (;_;)"),
            new CandiesThrownSmileyFirstLine("      (;_;)"),
            new CandiesThrownSmileyFirstLine("       (;_;)"),
            new CandiesThrownSmileyFirstLine("        (;_;)"),
            new CandiesThrownSmileyFirstLine("         (;_;)"),
            new CandiesThrownSmileyFirstLine("          (;_;)"),
            new CandiesThrownSmileyFirstLine("           (;_;)"),
            new CandiesThrownSmileyFirstLine("            (;_;)"),
            new CandiesThrownSmileyFirstLine("             (;_;)"),
            new CandiesThrownSmileyFirstLine("              (;_;)"),
            new CandiesThrownSmileyFirstLine("               (;_;)"),
            new CandiesThrownSmileyFirstLine("                (;_;)"),
            new CandiesThrownSmileyFirstLine("                 (;_;)"),
            new CandiesThrownSmileyFirstLine("                  (;_;)"),
            new CandiesThrownSmileyFirstLine("                   (;_;)"),
            new CandiesThrownSmileyFirstLine("                    (;_;)"),
            new CandiesThrownSmileyFirstLine("                     (;_;)"),
            new CandiesThrownSmileyFirstLine("                      (;_;)"),
            new CandiesThrownSmileyFirstLine("                      (;_;)|"),
            new CandiesThrownSmileyFirstLine("                      (o_o)|"),
            new CandiesThrownSmileyFirstLine("                 crap (o_o)|"),
            new CandiesThrownSmileyFirstLine("               a wall (o_o)|"),
            new CandiesThrownSmileyFirstLine("                      (._.)|"),
            new CandiesThrownSmileyFirstLine("     I'm trapped here (._.)|"),
            new CandiesThrownSmileyFirstLine("    maybe...          (._.)|"),
            new CandiesThrownSmileyFirstLine("    maybe I could dig (._.)|"),
            new CandiesThrownSmileyFirstLine("    dig in the ground (._.)|"),
            new CandiesThrownSmileyFirstLine("                      (._.)|"),
            new CandiesThrownSmileyFirstLine("                *dig* (._.)|"),
            new CandiesThrownSmileyFirstLine("                    (._.)|"),
            new CandiesThrownSmileyFirstLine("              *dig* (._.)|"),
            new CandiesThrownSmileyFirstLine("                    (._.)|"),
            new CandiesThrownSmileyFirstLine("              *dig* (._.)|"),
            new CandiesThrownSmileyFirstLine("                    (._.)|"),
            new CandiesThrownSmileyFirstLine("              *dig* (._.)|"),
            new CandiesThrownSmileyFirstLine("                    (._.)|"),
            new CandiesThrownSmileyFirstLine("              *dig* (._.)|"),
            new CandiesThrownSmileyCave("(O_O)", new Pos(57, 1)),
            new CandiesThrownSmileyCave("(O_O)", new Pos(57, 2)),
            new CandiesThrownSmileyCave("(O_O)", new Pos(57, 3)),
            new CandiesThrownSmileyCave("(O_O)", new Pos(57, 4)),
            new CandiesThrownSmileyCave("(O_O)", new Pos(57, 5)),
            new CandiesThrownSmileyCave("(O_O)", new Pos(57, 6)),
            new CandiesThrownSmileyCave("(O_O)", new Pos(57, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(57, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(57, 7)).addObject(new CandiesThrownSmileyCaveObject("wow.", new Pos(52, 5))),
            new CandiesThrownSmileyCave("(._.)", new Pos(57, 7)).addObject(new CandiesThrownSmileyCaveObject("I didn't expect that.", new Pos(35, 5))),
            new CandiesThrownSmileyCave("(._.)", new Pos(57, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(55, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(53, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(51, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(49, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(47, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(45, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(45, 7)).addObject(new CandiesThrownSmileyCaveObject("what's this place?", new Pos(39, 5))),
            new CandiesThrownSmileyCave("(._.)", new Pos(45, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(43, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(41, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(39, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(37, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(35, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(33, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(33, 7)).addObject(new CandiesThrownSmileyCaveObject("it looks like a cave", new Pos(26, 5))),
            new CandiesThrownSmileyCave("(._.)", new Pos(33, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(31, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(29, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(27, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(25, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(23, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(21, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(19, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(19, 7)).addObject(new CandiesThrownSmileyCaveObject("oh! there's a chest over there!", new Pos(8, 5))),
            new CandiesThrownSmileyCave("(._.)", new Pos(19, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(17, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(15, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(13, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(11, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(9, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(7, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(5, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(4, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(4, 7)).addObject(new CandiesThrownSmileyCaveObject("I guess I should open it", new Pos(3, 5))),
            new CandiesThrownSmileyCave("(._.)", new Pos(4, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(4, 7)).openChest(),
            new CandiesThrownSmileyCave("(._.)", new Pos(4, 7)).addObject(new CandiesThrownSmileyCaveObject("!!!", new Pos(5, 5))).openChest(),
            new CandiesThrownSmileyCave("(._.)", new Pos(4, 7)).addObject(new CandiesThrownSmileyCaveObject("I found a chocolate bar!", new Pos(3, 5))),
            new CandiesThrownSmileyCave("(._.)", new Pos(4, 7)).addObject(new CandiesThrownSmileyCaveObject("...", new Pos(3, 5))),
            new CandiesThrownSmileyCave("(._.)", new Pos(4, 7)).addObject(new CandiesThrownSmileyCaveObject("hey, listen", new Pos(3, 5))),
            new CandiesThrownSmileyCave("(._.)", new Pos(4, 7)).addObject(new CandiesThrownSmileyCaveObject("I'll give you the chocolate bar", new Pos(3, 5))),
            new CandiesThrownSmileyCave("(._.)", new Pos(4, 7)).addObject(new CandiesThrownSmileyCaveObject("if you swear to stop throwing candies", new Pos(3, 5))),
            new CandiesThrownSmileyCave("(._.)", new Pos(4, 7)).addObject(new CandiesThrownSmileyCaveObject("okay?", new Pos(3, 5))),
            new CandiesThrownSmileyCave("(._.)", new Pos(4, 7)).addObject(new CandiesThrownSmileyCaveObject("throw 10 last candies to let me know if you agree", new Pos(3, 5))),
            new CandiesThrownSmileyCave("(._.)", new Pos(4, 7)).addObject(new CandiesThrownSmileyCaveObject("good. here's the bar. no more throwing!!", new Pos(3, 5))),
            new CandiesThrownSmileyCave("(._.)", new Pos(4, 7)),
            new CandiesThrownSmileyCave("(._.)", new Pos(4, 7)).addObject(new CandiesThrownSmileyCaveObject("Hey?!", new Pos(3, 5))),
            new CandiesThrownSmileyCave("(;_;)", new Pos(4, 7)).addObject(new CandiesThrownSmileyCaveObject("You're still throwing candies!", new Pos(3, 5))),
            new CandiesThrownSmileyCave("(;_;)", new Pos(4, 7)).addObject(new CandiesThrownSmileyCaveObject("Candies are precious, you know.", new Pos(3, 5))),
            new CandiesThrownSmileyCave("(;_;)", new Pos(4, 7)).addObject(new CandiesThrownSmileyCaveObject("...", new Pos(5, 5))),
            new CandiesThrownSmileyCave("(;_;)", new Pos(4, 7)).addObject(new CandiesThrownSmileyCaveObject("I'm out of here.", new Pos(3, 5))),
            new CandiesThrownSmileyCave("(;_;)", new Pos(4, 7)).addObject(new CandiesThrownSmileyCaveObject("*dig*", new Pos(10, 7))),
            new CandiesThrownSmileyCave("(;_;)", new Pos(4, 7)),
            new CandiesThrownSmileyCave("(;_;)", new Pos(4, 7)).addObject(new CandiesThrownSmileyCaveObject("*dig*", new Pos(10, 7))),
            new CandiesThrownSmileyCave("(;_;)", new Pos(4, 7)),
            new CandiesThrownSmileyCave("(;_;)", new Pos(4, 7)).addObject(new CandiesThrownSmileyCaveObject("*dig*", new Pos(10, 7))),
            new CandiesThrownSmileyCave("(;_;)", new Pos(4, 7)),
            new CandiesThrownSmileyCave("(;_;)", new Pos(4, 7)).addObject(new CandiesThrownSmileyCaveObject("*dig*", new Pos(10, 7))),
            new CandiesThrownSmileyCave("(;_;)", new Pos(4, 8), CandiesThrownSmileyCaveStep.SECOND_ROOM),
            new CandiesThrownSmileyCave("(;_;)", new Pos(4, 9), CandiesThrownSmileyCaveStep.SECOND_ROOM),
            new CandiesThrownSmileyCave("(;_;)", new Pos(4, 10), CandiesThrownSmileyCaveStep.SECOND_ROOM),
            new CandiesThrownSmileyCave("(;_;)", new Pos(4, 11), CandiesThrownSmileyCaveStep.SECOND_ROOM),
            new CandiesThrownSmileyCave("(;_;)", new Pos(4, 12), CandiesThrownSmileyCaveStep.SECOND_ROOM),
            new CandiesThrownSmileyCave("(;_;)", new Pos(4, 13), CandiesThrownSmileyCaveStep.SECOND_ROOM),
            new CandiesThrownSmileyCave("(;_;)", new Pos(4, 14), CandiesThrownSmileyCaveStep.SECOND_ROOM),
            new CandiesThrownSmileyCave("(;_;)", new Pos(4, 15), CandiesThrownSmileyCaveStep.SECOND_ROOM),
            new CandiesThrownSmileyCave("(;_;)", new Pos(6, 15), CandiesThrownSmileyCaveStep.SECOND_ROOM),
            new CandiesThrownSmileyCave("(;_;)", new Pos(8, 15), CandiesThrownSmileyCaveStep.SECOND_ROOM),
            new CandiesThrownSmileyCave("(;_;)", new Pos(10, 15), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(;_;)", new Pos(12, 15), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(o_o)", new Pos(12, 15), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(o_o)", new Pos(12, 14), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(o_o)", new Pos(12, 13), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(o_o)", new Pos(12, 12), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(o_o)", new Pos(13, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(o_o)", new Pos(15, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(o_o)", new Pos(17, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(o_o)", new Pos(18, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(O_O)", new Pos(18, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(O_O)", new Pos(18, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM).addObject(new CandiesThrownSmileyCaveObject("this is...", new Pos(13, 9))),
            new CandiesThrownSmileyCave("(O_O)", new Pos(18, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM).addObject(new CandiesThrownSmileyCaveObject("a room...", new Pos(13, 9))),
            new CandiesThrownSmileyCave("(O_O)", new Pos(18, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM).addObject(new CandiesThrownSmileyCaveObject("FULL OF GIANT CANDIES!", new Pos(33, 9))),
            new CandiesThrownSmileyCave("(O_O)", new Pos(18, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(^_^)", new Pos(18, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(^_^)", new Pos(18, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM).addObject(new CandiesThrownSmileyCaveObject("well", new Pos(16, 9))),
            new CandiesThrownSmileyCave("(^_^)", new Pos(18, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM).addObject(new CandiesThrownSmileyCaveObject("don't worry about the candies you threw", new Pos(6, 7))),
            new CandiesThrownSmileyCave("(^_^)", new Pos(18, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM).addObject(new CandiesThrownSmileyCaveObject("just let me eat those candies and you're forgiven", new Pos(6, 7))),
            new CandiesThrownSmileyCave("(^_^)", new Pos(18, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM).addObject(new CandiesThrownSmileyCaveObject("<3", new Pos(17, 9))),
            new CandiesThrownSmileyCave("(^_^)", new Pos(20, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(^_^)", new Pos(22, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(^_^)", new Pos(22, 10), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(^_^)", new Pos(23, 9), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(^_^)", new Pos(25, 9), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(^_^)", new Pos(27, 9), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(^_^)", new Pos(29, 9), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(^_^)", new Pos(31, 9), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(^_^)", new Pos(33, 9), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(^_^)", new Pos(34, 10), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(^_^)", new Pos(34, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(^_^)", new Pos(36, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(^_^)", new Pos(38, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(^_^)", new Pos(40, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(^_^)", new Pos(42, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(^_^)", new Pos(43, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM),
        ];
        // *nom* *nom* smileys
        this.nomNomSmileys = [new CandiesThrownSmileyCave("(^_^)", new Pos(43, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM),
            new CandiesThrownSmileyCave("(^_^)", new Pos(43, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM).addObject(new CandiesThrownSmileyCaveObject("*nom*", new Pos(40, 9))),
            new CandiesThrownSmileyCave("(^_^)", new Pos(43, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM).addObject(new CandiesThrownSmileyCaveObject("*nom*", new Pos(41, 9))),
            new CandiesThrownSmileyCave("(^_^)", new Pos(43, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM).addObject(new CandiesThrownSmileyCaveObject("*nom*", new Pos(42, 9))),
            new CandiesThrownSmileyCave("(^_^)", new Pos(43, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM).addObject(new CandiesThrownSmileyCaveObject("*nom*", new Pos(43, 9))),
            new CandiesThrownSmileyCave("(^_^)", new Pos(43, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM).addObject(new CandiesThrownSmileyCaveObject("*nom*", new Pos(44, 9))),
            new CandiesThrownSmileyCave("(^_^)", new Pos(43, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM).addObject(new CandiesThrownSmileyCaveObject("*nom*", new Pos(45, 9))),
            new CandiesThrownSmileyCave("(^_^)", new Pos(43, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM).addObject(new CandiesThrownSmileyCaveObject("*nom*", new Pos(46, 9))),
            new CandiesThrownSmileyCave("(^_^)", new Pos(43, 11), CandiesThrownSmileyCaveStep.THIRD_ROOM).addObject(new CandiesThrownSmileyCaveObject("*nom* *nom*", new Pos(40, 9))),
        ];
        // Index of the *nom* *nom* smiley we show
        this.nomNomSmileyIndex = 0;
        this.game = game;
    }
    // Public methods
    CandiesThrown.prototype.add = function (n) {
        // We save the return value
        var returnValue = _super.prototype.add.call(this, n);
        // If it's time to get this chocolate bar, we get it
        if (Saving.loadBool("candiesThrownGotChocolateBar") == false && Math.floor(this.getCurrent() / 10) - 1 == 162) {
            this.game.getChocolateBars().add(1);
            Saving.saveBool("candiesThrownGotChocolateBar", true);
        }
        // We choose a random *nom* *nom* smiley index in case we're at this step of the animation
        this.nomNomSmileyIndex = Random.between(0, this.nomNomSmileys.length - 1);
        // We return the return value
        return returnValue;
    };
    CandiesThrown.prototype.draw = function (renderArea, x, y) {
        var n = this.getCurrent();
        var smileyIndex;
        var base;
        // Set the base
        if (n < 0)
            base = "You threw negative candies ?!";
        else if (n == 1)
            base = "You threw 1 candy on the ground";
        else {
            base = "You threw " + Algo.numberToStringButNicely(n) + " candies on the ground";
        }
        // Get the index of the smiley we should add
        smileyIndex = Math.floor(n / 10) - 1;
        // Add a smiley from the smileys array if the index is correct
        if (smileyIndex >= 0 && smileyIndex < this.smileys.length) {
            // Draw the smiley and return the correct y gap
            return this.smileys[smileyIndex].draw(renderArea, x, y, base);
        }
        else if (smileyIndex < 0) {
            // We just draw the base and return 0
            renderArea.drawString(base, x, y);
            return 0;
        }
        else {
            // Draw the smiley and return the correct y gap
            return this.nomNomSmileys[this.nomNomSmileyIndex].draw(renderArea, x, y, base);
        }
    };
    return CandiesThrown;
})(Resource);
var CandiesThrownSmiley = (function () {
    // Constructor
    function CandiesThrownSmiley() {
    }
    // Public methods
    CandiesThrownSmiley.prototype.draw = function (renderArea, x, y, base) {
        // We're in the mother class, so we just draw nothing and return 0
        return 0;
    };
    return CandiesThrownSmiley;
})();
///<reference path="CandiesThrownSmiley.ts"/>
var CandiesThrownSmileyCave = (function (_super) {
    __extends(CandiesThrownSmileyCave, _super);
    // Constructor
    function CandiesThrownSmileyCave(smiley, smileyPosition, step) {
        if (step === void 0) { step = CandiesThrownSmileyCaveStep.FIRST_ROOM; }
        _super.call(this);
        // Various objects (can be speeches, for example)
        this.objects = [];
        // Is the chest open ? (closed by default)
        this.chestOpened = false;
        this.smiley = smiley;
        this.smileyPosition = smileyPosition;
        this.step = step;
    }
    // draw()
    CandiesThrownSmileyCave.prototype.draw = function (renderArea, x, y, base) {
        // Draw the base
        renderArea.drawString(base, x, y);
        // Draw the cave's walls, depending on the step
        renderArea.drawVerticalLine("|", 0, y + 2, y + 8); // Left wall
        renderArea.drawVerticalLine("|", 62, y, y + 8); // Right wall
        renderArea.drawHorizontalLine("_", 0, 57, y + 1); // Roof
        renderArea.drawString("|", 56, y + 1); // Additional character
        switch (this.step) {
            // Only third room
            case CandiesThrownSmileyCaveStep.THIRD_ROOM:
                renderArea.drawHorizontalLine("-", 12, 62, y + 16); // Floor
                renderArea.drawVerticalLine("|", 62, y + 9, y + 16); // Right wall
                renderArea.drawArray(Database.getAscii("general/candyRoom"), 12, y + 9); // Content of the room
            // Second & third room
            case CandiesThrownSmileyCaveStep.SECOND_ROOM:
                // Floor of the first room (we must make it in two pieces because there's a hole!)
                renderArea.drawHorizontalLine("-", 1, 4, y + 8); // Left
                renderArea.drawHorizontalLine("-", 9, 62, y + 8); // Right
                // Rest of the room
                renderArea.drawVerticalLine("|", 0, y + 9, y + 16); // Left wall
                renderArea.drawVerticalLine("|", 11, y + 9, y + 14); // Right wall
                renderArea.drawHorizontalLine("-", 1, 12, y + 16); // Floor
                break;
            // Only first room
            case CandiesThrownSmileyCaveStep.FIRST_ROOM:
                renderArea.drawHorizontalLine("-", 1, 62, y + 8); // Floor
                break;
        }
        // Draw the chest
        renderArea.drawString("|_|", 1, y + 7);
        if (this.chestOpened == false)
            renderArea.drawString("_", 2, y + 6);
        else
            renderArea.drawString("(", 1, y + 6);
        // Draw the smiley
        renderArea.drawString(this.smiley, x + this.smileyPosition.x, y + this.smileyPosition.y);
        // Draw objects
        for (var i = 0; i < this.objects.length; i++) {
            renderArea.drawString(this.objects[i].getStr(), x + this.objects[i].getPosition().x, y + this.objects[i].getPosition().y);
        }
        // Return the cave's height
        switch (this.step) {
            case CandiesThrownSmileyCaveStep.FIRST_ROOM:
                return 8;
                break;
            case CandiesThrownSmileyCaveStep.SECOND_ROOM:
            case CandiesThrownSmileyCaveStep.THIRD_ROOM:
                return 16;
                break;
        }
    };
    // Public methods used to add or change stuff (always return ourselves)
    CandiesThrownSmileyCave.prototype.addObject = function (object) {
        this.objects.push(object);
        return this;
    };
    CandiesThrownSmileyCave.prototype.openChest = function () {
        this.chestOpened = true;
        return this;
    };
    return CandiesThrownSmileyCave;
})(CandiesThrownSmiley);
var CandiesThrownSmileyCaveObject = (function () {
    // Constructor
    function CandiesThrownSmileyCaveObject(str, position) {
        this.str = str;
        this.position = position;
    }
    // Public getters
    CandiesThrownSmileyCaveObject.prototype.getPosition = function () {
        return this.position;
    };
    CandiesThrownSmileyCaveObject.prototype.getStr = function () {
        return this.str;
    };
    return CandiesThrownSmileyCaveObject;
})();
var CandiesThrownSmileyCaveStep;
(function (CandiesThrownSmileyCaveStep) {
    CandiesThrownSmileyCaveStep[CandiesThrownSmileyCaveStep["FIRST_ROOM"] = 0] = "FIRST_ROOM";
    CandiesThrownSmileyCaveStep[CandiesThrownSmileyCaveStep["SECOND_ROOM"] = 1] = "SECOND_ROOM";
    CandiesThrownSmileyCaveStep[CandiesThrownSmileyCaveStep["THIRD_ROOM"] = 2] = "THIRD_ROOM";
})(CandiesThrownSmileyCaveStep || (CandiesThrownSmileyCaveStep = {}));
///<reference path="CandiesThrownSmiley.ts"/>
var CandiesThrownSmileyFirstLine = (function (_super) {
    __extends(CandiesThrownSmileyFirstLine, _super);
    // Constructor
    function CandiesThrownSmileyFirstLine(line) {
        _super.call(this);
        this.line = line;
    }
    // draw()
    CandiesThrownSmileyFirstLine.prototype.draw = function (renderArea, x, y, base) {
        renderArea.drawString(base + this.line, x, y);
        return 0;
    };
    return CandiesThrownSmileyFirstLine;
})(CandiesThrownSmiley);
///<reference path="Place.ts"/>
Saving.registerBool("candyBoxBoxOpened", false);
var CandyBox = (function (_super) {
    __extends(CandyBox, _super);
    // Constructor
    function CandyBox(game) {
        _super.call(this, game);
        this.renderArea = new RenderArea();
        this.eatButtonShown = false;
        this.throwButtonShown = false;
        this.requestFeatureButtonShown = false;
        // Resize the area
        this.renderArea.resize(100, 40);
        // Update
        this.update();
    }
    // willBeDisplayed()
    CandyBox.prototype.willBeDisplayed = function () {
        // We check right now
        this.checkCandies();
        // And we add the callback
        this.getGame().getCandies().getCallbackCollection().addCallback(this.checkCandies.bind(this));
        // We add hotkeys
        this.getGame().addHotkey(new Hotkey("e", new CallbackCollection(this.clickedEatCandiesButton.bind(this))));
        this.getGame().addHotkey(new Hotkey("t", new CallbackCollection(this.clickedThrowCandiesButton.bind(this))));
    };
    // Public methods
    CandyBox.prototype.update = function () {
        // Y gap for everything below the throwing candies stuff (because the throwing candies stuff can be extended a lot)
        var yGapForEverythingBelowTheThrowingCandiesStuff = 0;
        // Erase everything
        this.renderArea.resetAllButSize();
        // Draw the box
        if (Saving.loadBool("lonelyHouseTakeTheBoxDone")) {
            if (Saving.loadBool("candyBoxBoxOpened") == true)
                this.renderArea.drawArray(Database.getAscii("general/openBox"), 68, 4);
            else
                this.renderArea.drawArray(Database.getAscii("general/box"), 68, 4);
        }
        // If we possess the talking candy
        if (Saving.loadBool("gridItemPossessedTalkingCandy") == true) {
            // Draw the ascii art
            this.renderArea.drawArray(Database.getAscii("gridItems/talkingCandy"), 68, 37);
            // If we don't have the box yet
            if (Saving.loadBool("lonelyHouseTakeTheBoxDone") == false) {
                // Draw the speech
                this.renderArea.drawSpeech(Database.getText("talkingCandySpeechNoBox"), 30, 72, 98, "candyBoxTalkingCandySpeech", Database.getTranslatedText("talkingCandySpeechNoBox"));
            }
            else {
                // If the talking candy already opened the box
                if (Saving.loadBool("candyBoxBoxOpened")) {
                    // Draw the speech
                    this.renderArea.drawSpeech(Database.getText("talkingCandySpeech2"), 34, 72, 98, "candyBoxTalkingCandySpeech", Database.getTranslatedText("talkingCandySpeech2"));
                }
                else {
                    // Draw the speech
                    this.renderArea.drawSpeech(Database.getText("talkingCandySpeech1"), 30, 72, 98, "candyBoxTalkingCandySpeech", Database.getTranslatedText("talkingCandySpeech1"));
                    // Add the button
                    this.renderArea.addAsciiRealButton(Database.getText("talkingCandyButton"), 80, 37, "candyBoxTalkingCandyButton", Database.getTranslatedText("talkingCandyButton"));
                    this.renderArea.addLinkCall(".candyBoxTalkingCandyButton", new CallbackCollection(this.openBox.bind(this)));
                }
            }
        }
        // Eat all the candies
        if (this.eatButtonShown) {
            this.renderArea.addAsciiRealButton(Database.getText("candyBoxEatCandiesButton"), 0, 1, "candyBoxEatCandiesButton", Database.getTranslatedText("candyBoxEatCandiesButton"), false, 0);
            this.renderArea.addLinkCall(".candyBoxEatCandiesButton", new CallbackCollection(this.clickedEatCandiesButton.bind(this)));
            if (this.getGame().getCandiesEaten().getCurrent() != 0)
                this.renderArea.drawString(this.getGame().getCandiesEaten().getCurrentAsString(), 0, 3);
        }
        // Throw 10 candies
        if (this.throwButtonShown) {
            this.renderArea.addAsciiRealButton(Database.getText("candyBoxThrowCandiesButton"), 0, 6, "candyBoxThrowCandiesButton", Database.getTranslatedText("candyBoxThrowCandiesButton"), false, 0);
            this.renderArea.addLinkCall(".candyBoxThrowCandiesButton", new CallbackCollection(this.clickedThrowCandiesButton.bind(this)));
            if (this.getGame().getCandiesThrown().getCurrent() != 0) {
                yGapForEverythingBelowTheThrowingCandiesStuff = this.getGame().getCandiesThrown().draw(this.renderArea, 0, 8); // Set the yGap..
            }
        }
        // Request feature
        if (this.requestFeatureButtonShown) {
            if (Saving.loadBool("statusBarUnlocked") == false) {
                this.renderArea.addAsciiRealButton(Database.getText("candyBoxRequestStatusBarUnlocked"), 0, 11 + yGapForEverythingBelowTheThrowingCandiesStuff, "candyBoxRequestStatusBarUnlockedButton", Database.getTranslatedText("candyBoxRequestStatusBarUnlocked"), true);
                this.renderArea.addLinkCall(".candyBoxRequestStatusBarUnlockedButton", new CallbackCollection(this.requestStatusBarUnlocked.bind(this)));
            }
            else if (Saving.loadBool("statusBarUnlockedCfg") == false) {
                this.renderArea.addAsciiRealButton(Database.getText("candyBoxRequestStatusBarUnlockedCfg"), 0, 11 + yGapForEverythingBelowTheThrowingCandiesStuff, "candyBoxRequestStatusBarUnlockedCfgButton", Database.getTranslatedText("candyBoxRequestStatusBarUnlockedCfg"), true);
                this.renderArea.addLinkCall(".candyBoxRequestStatusBarUnlockedCfgButton", new CallbackCollection(this.requestStatusBarUnlockedCfg.bind(this)));
                this.renderArea.drawString(Database.getText("candyBoxRequestStatusBarUnlockedComment"), 0, 14 + yGapForEverythingBelowTheThrowingCandiesStuff);
                this.renderArea.drawString(Database.getTranslatedText("candyBoxRequestStatusBarUnlockedComment"), 0, 15 + yGapForEverythingBelowTheThrowingCandiesStuff, true);
            }
            else if (Saving.loadBool("statusBarUnlockedSave") == false) {
                this.renderArea.addAsciiRealButton(Database.getText("candyBoxRequestStatusBarUnlockedSave"), 0, 11 + yGapForEverythingBelowTheThrowingCandiesStuff, "candyBoxRequestStatusBarUnlockedSaveButton", Database.getTranslatedText("candyBoxRequestStatusBarUnlockedSave"), true);
                this.renderArea.addLinkCall(".candyBoxRequestStatusBarUnlockedSaveButton", new CallbackCollection(this.requestStatusBarUnlockedSave.bind(this)));
                this.renderArea.drawString(Database.getText("candyBoxRequestStatusBarUnlockedCfgComment1"), 0, 14 + yGapForEverythingBelowTheThrowingCandiesStuff);
                this.renderArea.drawString(Database.getText("candyBoxRequestStatusBarUnlockedCfgComment2"), 0, 15 + yGapForEverythingBelowTheThrowingCandiesStuff);
                this.renderArea.drawString(Database.getTranslatedText("candyBoxRequestStatusBarUnlockedCfgComment1"), 0, 16 + yGapForEverythingBelowTheThrowingCandiesStuff, true);
                this.renderArea.drawString(Database.getTranslatedText("candyBoxRequestStatusBarUnlockedCfgComment2"), 0, 17 + yGapForEverythingBelowTheThrowingCandiesStuff, true);
            }
            else if (Saving.loadBool("statusBarUnlockedHealthBar") == false) {
                this.renderArea.addAsciiRealButton(Database.getText("candyBoxRequestStatusBarUnlockedHealthBar"), 0, 11 + yGapForEverythingBelowTheThrowingCandiesStuff, "candyBoxRequestStatusBarUnlockedHealthBarButton", Database.getTranslatedText("candyBoxRequestStatusBarUnlockedHealthBar"), true);
                this.renderArea.addLinkCall(".candyBoxRequestStatusBarUnlockedHealthBarButton", new CallbackCollection(this.requestStatusBarUnlockedHealthBar.bind(this)));
                this.renderArea.drawString(Database.getText("candyBoxRequestStatusBarUnlockedSaveComment"), 0, 14 + yGapForEverythingBelowTheThrowingCandiesStuff);
                this.renderArea.drawString(Database.getTranslatedText("candyBoxRequestStatusBarUnlockedSaveComment"), 0, 15 + yGapForEverythingBelowTheThrowingCandiesStuff, true);
            }
            else if (Saving.loadBool("statusBarUnlockedMap") == false) {
                this.renderArea.addAsciiRealButton(Database.getText("candyBoxRequestStatusBarUnlockedMap"), 0, 11 + yGapForEverythingBelowTheThrowingCandiesStuff, "candyBoxRequestStatusBarUnlockedMapButton", Database.getTranslatedText("candyBoxRequestStatusBarUnlockedMap"), true);
                this.renderArea.addLinkCall(".candyBoxRequestStatusBarUnlockedMapButton", new CallbackCollection(this.requestStatusBarUnlockedMap.bind(this)));
                this.renderArea.drawString(Database.getText("candyBoxRequestStatusBarUnlockedHealthBarComment"), 0, 14 + yGapForEverythingBelowTheThrowingCandiesStuff);
                this.renderArea.drawString(Database.getTranslatedText("candyBoxRequestStatusBarUnlockedHealthBarComment"), 0, 15 + yGapForEverythingBelowTheThrowingCandiesStuff, true);
            }
        }
    };
    // getRenderArea()
    CandyBox.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // Private methods
    CandyBox.prototype.checkCandies = function () {
        // Possibly show the eat button
        if (this.eatButtonShown == false) {
            if (this.getGame().getCandies().getMax() > 0) {
                this.eatButtonShown = true;
                this.update();
                this.getGame().updatePlace();
            }
        }
        // Possibly show the throw button
        if (this.throwButtonShown == false) {
            if (this.getGame().getCandies().getMax() >= 10) {
                this.throwButtonShown = true;
                this.update();
                this.getGame().updatePlace();
            }
        }
        // Possibly show the request feature button
        if (this.requestFeatureButtonShown == false) {
            // If we have enough candies & the last feature isn't unlocked yet
            if (this.getGame().getCandies().getMax() >= 30 && Saving.loadBool("statusBarUnlockedMap") == false) {
                this.requestFeatureButtonShown = true;
                this.update();
                this.getGame().updatePlace();
            }
        }
    };
    CandyBox.prototype.clickedEatCandiesButton = function () {
        if (this.getGame().getCandies().getCurrent() >= 1) {
            this.getGame().getCandies().transferTo(this.getGame().getCandiesEaten());
            this.update();
            this.getGame().updatePlace();
        }
    };
    CandyBox.prototype.clickedThrowCandiesButton = function () {
        if (this.getGame().getCandies().getCurrent() >= 10) {
            this.getGame().getCandies().transferTo(this.getGame().getCandiesThrown(), 10);
            this.update();
            this.getGame().updatePlace();
        }
    };
    CandyBox.prototype.openBox = function () {
        // The box is now opened
        Saving.saveBool("candyBoxBoxOpened", true);
        // The tabs are unlocked
        Saving.saveBool("statusBarUnlockedInsideYourBox", true);
        Saving.saveBool("statusBarUnlockedTheComputer", true);
        Saving.saveBool("statusBarUnlockedTheArena", true);
        this.getGame().updateStatusBar(true);
        // Update
        this.update();
        this.getGame().updatePlace();
    };
    CandyBox.prototype.requestStatusBarUnlocked = function () {
        if (this.getGame().getCandies().getCurrent() >= 30) {
            this.getGame().getCandies().transferTo(this.getGame().getCandiesUsedToRequestFeatures(), 30);
            Saving.saveBool("statusBarUnlocked", true);
            this.getGame().updateStatusBar(true);
            this.update();
            this.getGame().updatePlace();
        }
    };
    CandyBox.prototype.requestStatusBarUnlockedCfg = function () {
        if (this.getGame().getCandies().getCurrent() >= 5) {
            this.getGame().getCandies().transferTo(this.getGame().getCandiesUsedToRequestFeatures(), 5);
            Saving.saveBool("statusBarUnlockedCfg", true);
            this.getGame().updateStatusBar(true);
            this.update();
            this.getGame().updatePlace();
        }
    };
    CandyBox.prototype.requestStatusBarUnlockedHealthBar = function () {
        if (this.getGame().getCandies().getCurrent() >= 5) {
            this.getGame().getCandies().transferTo(this.getGame().getCandiesUsedToRequestFeatures(), 5);
            Saving.saveBool("statusBarUnlockedHealthBar", true);
            this.getGame().updateStatusBar(true);
            this.update();
            this.getGame().updatePlace();
        }
    };
    CandyBox.prototype.requestStatusBarUnlockedMap = function () {
        if (this.getGame().getCandies().getCurrent() >= 10) {
            this.getGame().getCandies().transferTo(this.getGame().getCandiesUsedToRequestFeatures(), 10);
            Saving.saveBool("statusBarUnlockedMap", true);
            this.getGame().updateStatusBar(true);
            this.update();
            this.getGame().updatePlace();
        }
    };
    CandyBox.prototype.requestStatusBarUnlockedSave = function () {
        if (this.getGame().getCandies().getCurrent() >= 5) {
            this.getGame().getCandies().transferTo(this.getGame().getCandiesUsedToRequestFeatures(), 5);
            Saving.saveBool("statusBarUnlockedSave", true);
            this.getGame().updateStatusBar(true);
            this.update();
            this.getGame().updatePlace();
        }
    };
    return CandyBox;
})(Place);
var CandyMerchantItem = (function () {
    // Constructor
    function CandyMerchantItem(game, savingBool, asciiName, asciiPosition, merchantSpeech, price, buttonText, buttonName) {
        this.game = game;
        this.savingBool = savingBool;
        this.asciiName = asciiName;
        this.asciiPosition = asciiPosition;
        this.merchantSpeech = merchantSpeech;
        this.price = price;
        this.buttonText = buttonText;
        this.buttonName = buttonName;
    }
    // Public methods
    CandyMerchantItem.prototype.buy = function () {
        // We tell the saving system that this item is bought
        Saving.saveBool(this.savingBool, true);
    };
    CandyMerchantItem.prototype.canBeBought = function () {
        // If it's already bought, we return false
        if (this.isBought())
            return false;
        return true;
    };
    CandyMerchantItem.prototype.canBeClicked = function () {
        // If it's already bought, we return false
        if (this.isBought())
            return false;
        return true;
    };
    CandyMerchantItem.prototype.canBeShown = function () {
        // If it's already bought, we return false
        if (this.isBought())
            return false;
        return true;
    };
    CandyMerchantItem.prototype.isBought = function () {
        return Saving.loadBool(this.savingBool);
    };
    // Public getters
    CandyMerchantItem.prototype.getAsciiName = function () {
        return this.asciiName;
    };
    CandyMerchantItem.prototype.getAsciiPosition = function () {
        return this.asciiPosition;
    };
    CandyMerchantItem.prototype.getButtonName = function () {
        return this.buttonName;
    };
    CandyMerchantItem.prototype.getButtonText = function () {
        return this.buttonText;
    };
    CandyMerchantItem.prototype.getGame = function () {
        return this.game;
    };
    CandyMerchantItem.prototype.getMerchantSpeech = function () {
        return this.merchantSpeech;
    };
    CandyMerchantItem.prototype.getPrice = function () {
        return this.price;
    };
    return CandyMerchantItem;
})();
///<reference path="CandyMerchantItem.ts"/>
var CandyMerchantItem_ChocolateBar = (function (_super) {
    __extends(CandyMerchantItem_ChocolateBar, _super);
    function CandyMerchantItem_ChocolateBar() {
        _super.apply(this, arguments);
    }
    // When we buy, we get one chocolate bar
    CandyMerchantItem_ChocolateBar.prototype.buy = function () {
        _super.prototype.buy.call(this);
        this.getGame().getChocolateBars().add(1);
    };
    return CandyMerchantItem_ChocolateBar;
})(CandyMerchantItem);
///<reference path="CandyMerchantItem.ts"/>
var CandyMerchantItem_LeatherBoots = (function (_super) {
    __extends(CandyMerchantItem_LeatherBoots, _super);
    function CandyMerchantItem_LeatherBoots() {
        _super.apply(this, arguments);
    }
    // The item can't be shown if the inventory isn't shown yet
    CandyMerchantItem_LeatherBoots.prototype.canBeShown = function () {
        if (_super.prototype.canBeShown.call(this) == false)
            return false;
        if (Saving.loadBool("statusBarUnlockedInventory") == false)
            return false;
        return true;
    };
    return CandyMerchantItem_LeatherBoots;
})(CandyMerchantItem);
///<reference path="CandyMerchantItem.ts"/>
var CandyMerchantItem_LeatherGloves = (function (_super) {
    __extends(CandyMerchantItem_LeatherGloves, _super);
    function CandyMerchantItem_LeatherGloves() {
        _super.apply(this, arguments);
    }
    // The item can't be shown if the inventory isn't shown yet
    CandyMerchantItem_LeatherGloves.prototype.canBeShown = function () {
        if (_super.prototype.canBeShown.call(this) == false)
            return false;
        if (Saving.loadBool("statusBarUnlockedInventory") == false)
            return false;
        return true;
    };
    return CandyMerchantItem_LeatherGloves;
})(CandyMerchantItem);
///<reference path="CandyMerchantItem.ts"/>
var CandyMerchantItem_Lollipop = (function (_super) {
    __extends(CandyMerchantItem_Lollipop, _super);
    function CandyMerchantItem_Lollipop() {
        _super.apply(this, arguments);
    }
    // When we buy, we get one lollipop
    CandyMerchantItem_Lollipop.prototype.buy = function () {
        _super.prototype.buy.call(this);
        this.getGame().getLollipops().add(1);
    };
    return CandyMerchantItem_Lollipop;
})(CandyMerchantItem);
///<reference path="CandyMerchantItem.ts"/>
var CandyMerchantItem_MerchantHat = (function (_super) {
    __extends(CandyMerchantItem_MerchantHat, _super);
    function CandyMerchantItem_MerchantHat() {
        _super.apply(this, arguments);
    }
    // When we buy, we get the merchant hat
    CandyMerchantItem_MerchantHat.prototype.buy = function () {
        _super.prototype.buy.call(this);
        this.getGame().gainItem("eqItemHatMerchantHat");
    };
    // The item can't be clicked if the inventory isn't shown yet
    CandyMerchantItem_MerchantHat.prototype.canBeClicked = function () {
        if (_super.prototype.canBeClicked.call(this) == false)
            return false;
        if (Saving.loadBool("statusBarUnlockedInventory") == false)
            return false;
        return true;
    };
    return CandyMerchantItem_MerchantHat;
})(CandyMerchantItem);
///<reference path="CandyMerchantItem.ts"/>
var CandyMerchantItem_TimeRing = (function (_super) {
    __extends(CandyMerchantItem_TimeRing, _super);
    function CandyMerchantItem_TimeRing() {
        _super.apply(this, arguments);
    }
    // When we buy, we get the time ring
    CandyMerchantItem_TimeRing.prototype.buy = function () {
        _super.prototype.buy.call(this);
        this.getGame().gainItem("gridItemPossessedTimeRing");
    };
    // The item can't be shown if the inventory isn't shown yet
    CandyMerchantItem_TimeRing.prototype.canBeShown = function () {
        if (_super.prototype.canBeShown.call(this) == false)
            return false;
        if (Saving.loadBool("statusBarUnlockedInventory") == false)
            return false;
        return true;
    };
    return CandyMerchantItem_TimeRing;
})(CandyMerchantItem);
///<reference path="Place.ts"/>
Saving.registerBool("castleKilledNougatMonster", false);
var Castle = (function (_super) {
    __extends(Castle, _super);
    // Constructor
    function Castle(game) {
        _super.call(this, game);
        // The render area
        this.renderArea = new RenderArea();
        this.renderArea.resizeFromArray(Database.getAscii("places/castle/map"), 0, 5);
        this.update();
    }
    // getRenderArea()
    Castle.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // Private methods   
    Castle.prototype.drawBigRoom = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("castleBigRoomButton", x, x + 1, y, x, x + 1, y + 1);
        // Comment
        this.renderArea.addFullComment(x - 9, y, Database.getText("castleBigRoomComment"), Database.getTranslatedText("castleBigRoomComment"), "castleBigRoomComment");
        // Interactions
        this.renderArea.addLinkOver(".castleBigRoomButton, .castleBigRoomComment", ".castleBigRoomComment");
        this.renderArea.addLinkCall(".castleBigRoomButton", new CallbackCollection(this.goToBigRoom.bind(this)));
    };
    Castle.prototype.drawCastleEntrance = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiNinjaButtons("castleCastleEntranceButton", x, x + 2, y);
        // Comment
        this.renderArea.addFullComment(x + 1, y + 1, Database.getText("castleCastleEntranceComment"), Database.getTranslatedText("castleCastleEntranceComment"), "castleCastleEntranceComment");
        // Interactions
        this.renderArea.addLinkOver(".castleCastleEntranceButton, .castleCastleEntranceComment", ".castleCastleEntranceComment");
    };
    Castle.prototype.drawNougatMonster = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("castleNougatMonsterButton", x + 1, x + 8, y, x, x + 10, y + 1, x, x + 10, y + 2, x + 1, x + 8, y + 3);
        // Comment
        this.renderArea.addFullComment(x + 5, y - 2, Database.getText("castleNougatMonsterComment"), Database.getTranslatedText("castleNougatMonsterComment"), "castleNougatMonsterComment");
        // Interactions
        this.renderArea.addLinkOver(".castleNougatMonsterButton, .castleNougatMonsterComment", ".castleNougatMonsterComment");
        this.renderArea.addLinkCall(".castleNougatMonsterButton", new CallbackCollection(this.goToNougatMonster.bind(this)));
    };
    Castle.prototype.drawRoom1 = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("castleRoom1Button", x, x + 1, y, x, x + 1, y + 1);
        // Comment
        this.renderArea.addFullComment(x - 6, y, Database.getText("castleARoomComment"), Database.getTranslatedText("castleARoomComment"), "castleRoom1Comment");
        // Interactions
        this.renderArea.addLinkOver(".castleRoom1Button, .castleRoom1Comment", ".castleRoom1Comment");
        this.renderArea.addLinkCall(".castleRoom1Button, .castleRoom1Comment", new CallbackCollection(this.goToRoom1.bind(this)));
    };
    Castle.prototype.drawRoom2 = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("castleRoom2Button", x, x + 1, y, x, x + 1, y + 1);
        // Comment
        this.renderArea.addFullComment(x - 6, y, Database.getText("castleADarkRoomComment"), Database.getTranslatedText("castleADarkRoomComment"), "castleRoom2Comment");
        // Interactions
        this.renderArea.addLinkOver(".castleRoom2Button, .castleRoom2Comment", ".castleRoom2Comment");
        this.renderArea.addLinkCall(".castleRoom2Button, .castleRoom2Comment", new CallbackCollection(this.goToRoom2.bind(this)));
    };
    Castle.prototype.drawRoom3 = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("castleRoom3Button", x, x + 1, y, x, x + 1, y + 1);
        // Comment
        this.renderArea.addFullComment(x - 6, y, Database.getText("castleARoomComment"), Database.getTranslatedText("castleARoomComment"), "castleRoom3Comment");
        // Interactions
        this.renderArea.addLinkOver(".castleRoom3Button, .castleRoom3Comment", ".castleRoom3Comment");
        this.renderArea.addLinkCall(".castleRoom3Button, .castleRoom3Comment", new CallbackCollection(this.goToRoom3.bind(this)));
    };
    Castle.prototype.drawStairs = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("castleStairsButton", x, x + 4, y, x, x + 4, y + 1, x, x + 4, y + 2, x, x + 4, y + 3, x, x + 4, y + 4);
        // Comment
        this.renderArea.addFullComment(x + 10, y + 2, Database.getText("castleStairsComment"), Database.getTranslatedText("castleStairsComment"), "castleStairsComment");
        // Interactions
        this.renderArea.addLinkOver(".castleStairsButton, .castleStairsComment", ".castleStairsComment");
        this.renderArea.addLinkCall(".castleStairsButton", new CallbackCollection(this.goToStairs.bind(this)));
    };
    Castle.prototype.drawTowerEntrance = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("castleTowerEntranceButton", x, x + 1, y, x, x + 1, y + 1);
        // Comment
        this.renderArea.addFullComment(x + 12, y, Database.getText("castleTowerEntranceComment"), Database.getTranslatedText("castleTowerEntranceComment"), "castleTowerEntranceComment");
        // Interactions
        this.renderArea.addLinkOver(".castleTowerEntranceButton, .castleTowerEntranceComment", ".castleTowerEntranceComment");
        this.renderArea.addLinkCall(".castleTowerEntranceButton", new CallbackCollection(this.goToTowerEntrance.bind(this)));
    };
    Castle.prototype.goToBigRoom = function () {
        this.getGame().setPlace(new CastleBigRoom(this.getGame()));
    };
    Castle.prototype.goToNougatMonster = function () {
        this.getGame().setPlace(new GiantNougatMonsterQuest(this.getGame()));
    };
    Castle.prototype.goToRoom1 = function () {
        this.getGame().setPlace(new CastleRoom1(this.getGame()));
    };
    Castle.prototype.goToRoom2 = function () {
        this.getGame().setPlace(new CastleRoom2(this.getGame()));
    };
    Castle.prototype.goToRoom3 = function () {
        this.getGame().setPlace(new CastleRoom3(this.getGame()));
    };
    Castle.prototype.goToStairs = function () {
        this.getGame().setPlace(new Dragon(this.getGame()));
    };
    Castle.prototype.goToTowerEntrance = function () {
        this.getGame().setPlace(new CastleTower(this.getGame()));
    };
    Castle.prototype.update = function () {
        // Erase everything
        this.renderArea.resetAllButSize();
        // Back to the map button
        this.addBackToMainMapButton(this.renderArea, "castleBackToTheMapButton");
        // Draw the ascii
        this.renderArea.drawArray(Database.getAscii("places/castle/map"), 0, 3);
        // Draw various stuff
        this.drawCastleEntrance(43, 36);
        this.drawBigRoom(57, 19);
        this.drawRoom1(15, 27);
        this.drawRoom2(15, 21);
        this.drawRoom3(15, 15);
        this.drawNougatMonster(68, 15);
        this.drawStairs(32, 3);
        if (Saving.loadBool("castleKilledNougatMonster")) {
            this.drawTowerEntrance(84, 16);
        }
    };
    return Castle;
})(Place);
///<reference path="Place.ts"/>
var CastleRoom = (function (_super) {
    __extends(CastleRoom, _super);
    // Constructor
    function CastleRoom(game) {
        _super.call(this, game);
    }
    // Special method used to add a button to go back to the castle
    CastleRoom.prototype.addBackToTheCastleButton = function (renderArea, otherClass) {
        this.addBackToButton(renderArea, new CallbackCollection(this.getGame().goToCastle.bind(this.getGame())), Database.getText("buttonBackToTheCastle"), Database.getTranslatedText("buttonBackToTheCastle"), otherClass);
    };
    return CastleRoom;
})(Place);
///<reference path="CastleRoom.ts"/>
// Is the hoven happy? He is if he cooked something at least once
Saving.registerBool("castleBigRoomHovenHappy", false);
var CastleBigRoom = (function (_super) {
    __extends(CastleBigRoom, _super);
    // Constructor
    function CastleBigRoom(game) {
        _super.call(this, game);
        // The render area
        this.renderArea = new RenderArea();
        // At first the hoven is waiting
        this.hovenWaiting = true;
        // Set the default speech, depending on if the hoven is happy or not
        if (Saving.loadBool("castleBigRoomHovenHappy") == false) {
            this.currentSpeech = "castleBigRoomHovenSpeechSad";
        }
        else {
            this.currentSpeech = "castleBigRoomHovenSpeechHappy";
        }
        // Resize the area and update
        this.renderArea.resize(160, 30);
        this.update();
    }
    // getRenderArea()
    CastleBigRoom.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // update()
    CastleBigRoom.prototype.update = function () {
        // Reset the area
        this.renderArea.resetAllButSize();
        // Add the button to go back to the castle
        this.addBackToTheCastleButton(this.renderArea, "castleBigRoomBackToTheCastleButton");
        // Draw the background
        this.drawBackground(0, 3);
        // Draw the speech
        this.drawSpeech(83, 10);
        // If the hoven is waiting, we add the button to give it the sweets
        if (this.hovenWaiting) {
            this.renderArea.addAsciiRealButton(Database.getText("castleBigRoomHovenLetHovenTakeButton"), 83, 19, "castleBigRoomLetHovenTakeButton", Database.getTranslatedText("castleBigRoomHovenLetHovenTakeButton"), true);
            this.renderArea.addLinkCall(".castleBigRoomLetHovenTakeButton", new CallbackCollection(this.letHovenTake.bind(this)));
        }
        else {
            this.renderArea.addAsciiRealButton(Database.getText("castleBigRoomHovenThanks"), 83, 19, "castleBigRoomThanksButton", Database.getTranslatedText("castleBigRoomHovenThanks"), true);
            this.renderArea.addLinkCall(".castleBigRoomThanksButton", new CallbackCollection(this.thanksHoven.bind(this)));
        }
    };
    // Private methods
    CastleBigRoom.prototype.drawBackground = function (x, y) {
        // Draw the background ascii art
        this.renderArea.drawArray(Database.getAscii("places/castle/bigRoom/background"), x, y);
        // If the hoven is happy, change its face
        if (Saving.loadBool("castleBigRoomHovenHappy")) {
            this.renderArea.drawString("^       ^", x + 61, y + 9);
            this.renderArea.drawString("         ", x + 61, y + 10);
            this.renderArea.drawString("  '-.-'  ", x + 61, y + 11);
        }
    };
    CastleBigRoom.prototype.drawSpeech = function (x, y) {
        this.renderArea.drawSpeech(Database.getText(this.currentSpeech), y, x, x + 30, "CastleBigRoomHovenSpeech", Database.getTranslatedText(this.currentSpeech));
    };
    CastleBigRoom.prototype.letHovenTake = function () {
        // If we have enough sweets
        if (this.getGame().getCandies().getCurrent() >= 100 && this.getGame().getChocolateBars().getCurrent() >= 1) {
            // We spend the sweets
            this.getGame().getCandies().add(-100);
            this.getGame().getChocolateBars().add(-1);
            // The hoven is now happy
            Saving.saveBool("castleBigRoomHovenHappy", true);
            // The hoven isn't waiting anymore
            this.hovenWaiting = false;
            // We set the new speech
            this.currentSpeech = "castleBigRoomHovenSpeechMadePainAuChocolat";
            // We add the pain au chocolat
            this.getGame().getPainsAuChocolat().add(1);
        }
        else {
            // If the hoven isn't happy
            if (Saving.loadBool("castleBigRoomHovenHappy") == false) {
                this.currentSpeech = "castleBigRoomHovenNotEnough";
            }
            else {
                this.currentSpeech = "castleBigRoomHovenSpeechHappyNotEnough";
            }
        }
        // We update
        this.update();
        this.getGame().updatePlace();
    };
    CastleBigRoom.prototype.thanksHoven = function () {
        // The hoven is now waiting
        this.hovenWaiting = true;
        // Set the new speech
        this.currentSpeech = "castleBigRoomHovenSpeechHappy";
        // Update
        this.update();
        this.getGame().updatePlace();
    };
    return CastleBigRoom;
})(CastleRoom);
///<reference path="Quest.ts"/>
var CastleEntrance = (function (_super) {
    __extends(CastleEntrance, _super);
    // Constructor
    function CastleEntrance(game) {
        _super.call(this, game);
        // Last knight added
        this.lastKnightAdded = null;
        // Resize the quest
        this.resizeQuest(149, 30);
        // Add collision boxes around
        this.addPlayerCollisionBoxes(true, false, true, true);
        // Add the player
        this.getGame().getPlayer().loadCandyBoxCharacter(this);
        this.getGame().getPlayer().setGlobalPosition(new Pos(0, 25));
        this.configPlayerOrClone(this.getGame().getPlayer());
        this.addEntity(this.getGame().getPlayer());
        // Add the walls
        this.addWalls();
        // Add the first knight
        this.addKnight(Random.between(80, 120));
        // Add the message
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You're trying to cross the castle's entrance."));
    }
    // Public methods
    CastleEntrance.prototype.castPlayerTeleport = function () {
        _super.prototype.castPlayerTeleport.call(this, new Pos(0, 0), new Pos(60, 20));
    };
    CastleEntrance.prototype.configPlayerOrClone = function (entity) {
        entity.setQuestEntityMovement(new QuestEntityMovement(new Pos(1, 0)));
        entity.getQuestEntityMovement().setGravity(true);
        entity.getQuestEntityMovement().setWormsLike(true);
    };
    CastleEntrance.prototype.endQuest = function (win) {
        // We add some messages
        if (win) {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You crossed the castle's entrance! You can now enter the castle."));
            Saving.saveBool("mainMapDoneCastleEntrance", true); // The castle entrance is done
        }
        else {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You died trying to cross the castle's entrance."));
        }
        // We call the endQuest method of our mother class
        _super.prototype.endQuest.call(this, win);
    };
    CastleEntrance.prototype.update = function () {
        if (this.getQuestEnded() == false) {
            // Test if the player won the quest, if so, end the quest and return
            if (this.thePlayerWon()) {
                this.endQuest(true);
                return;
            }
            // Test if the player is dead, if so, end the quest and return
            if (this.getGame().getPlayer().shouldDie()) {
                this.endQuest(false);
                return;
            }
            // Handle monsters
            this.handleKnights();
            // Update entities
            this.updateEntities();
        }
        // Draw
        this.preDraw();
        this.getRenderArea().drawArray(Database.getAscii("places/quests/castleEntrance/background"), this.getRealQuestPosition().x, this.getRealQuestPosition().y);
        this.drawEntities();
        this.getRenderArea().drawArray(Database.getAscii("places/quests/castleEntrance/front"), this.getRealQuestPosition().x + 104, this.getRealQuestPosition().y);
        this.drawAroundQuest();
        if (this.getQuestEnded() == false)
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestNoKeeping");
        else if (this.getQuestEndedAndWeWon() == false)
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestNoKeepingBecauseLose");
        else
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestKeeping");
        this.postDraw();
    };
    // Private methods
    CastleEntrance.prototype.addKnight = function (x) {
        if (x === void 0) { x = 149; }
        var knight = new Knight(this, new Pos(x, 20));
        knight.setHealthBar(new QuestEntityHealthBar(knight, new Pos(15, 1)));
        if (this.addEntity(knight))
            this.lastKnightAdded = knight;
    };
    CastleEntrance.prototype.addWalls = function () {
        // Create the wall entity
        var wall = new Wall(this, new Pos(0, 0));
        // Add the boxes
        wall.addBox(new Pos(0, 26), new Pos(200, 4));
        wall.addBox(new Pos(104, 6), new Pos(15, 15));
        wall.addBox(new Pos(104, 5), new Pos(16, 1));
        wall.addBox(new Pos(104, 4), new Pos(17, 1));
        wall.addBox(new Pos(106, 3), new Pos(16, 1));
        wall.addBox(new Pos(107, 2), new Pos(6, 1));
        wall.addBox(new Pos(116, 2), new Pos(7, 1));
        // Add the wall entity
        this.addEntity(wall);
    };
    CastleEntrance.prototype.handleKnights = function () {
        // If there's no last knight added or the last knight added is weak or on the left of the player, we add a new one
        if (this.lastKnightAdded == null ||
            (this.lastKnightAdded != null && this.lastKnightAdded.getHp() / this.lastKnightAdded.getMaxHp() < 0.4) ||
            (this.lastKnightAdded != null && this.lastKnightAdded.getGlobalPosition().x + 1 < this.getGame().getPlayer().getGlobalPosition().x)) {
            this.addKnight();
        }
    };
    CastleEntrance.prototype.thePlayerWon = function () {
        // If the player is at the right of the desert, we return true
        if (this.getGame().getPlayer().getGlobalPosition().x >= 149)
            return true;
        // Else we return false
        return false;
    };
    return CastleEntrance;
})(Quest);
///<reference path="Quest.ts"/>
var CastleRoom1 = (function (_super) {
    __extends(CastleRoom1, _super);
    // Constructor
    function CastleRoom1(game) {
        _super.call(this, game);
        // Resize the quest
        this.resizeQuest(100, 30);
        // Add collision boxes around
        this.addPlayerCollisionBoxes(true, true, true, true);
        // Add the player
        this.getGame().getPlayer().loadCandyBoxCharacter(this);
        this.getGame().getPlayer().setGlobalPosition(new Pos(97, 10));
        this.configPlayerOrClone(this.getGame().getPlayer());
        this.addEntity(this.getGame().getPlayer());
        // Add the walls
        this.addWalls();
        // Add the spikes
        this.addEntity(new Spikes(this, new Pos(7, 23), 88));
        // Add the message
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You enter one of the castle's room. Damn, it seems to be full of spikes!"));
    }
    // Public methods
    CastleRoom1.prototype.castPlayerTeleport = function () {
        _super.prototype.castPlayerTeleport.call(this, new Pos(96, 6), new Pos(2, 3));
    };
    CastleRoom1.prototype.configPlayerOrClone = function (entity) {
        entity.setQuestEntityMovement(new QuestEntityMovement(new Pos(-1, 0)));
        entity.getQuestEntityMovement().setGravity(true);
        entity.getQuestEntityMovement().setWormsLike(true);
    };
    CastleRoom1.prototype.endQuest = function (win) {
        // We add some messages
        if (win) {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You exit the room."));
        }
        // We call the endQuest method of our mother class
        _super.prototype.endQuest.call(this, win);
    };
    CastleRoom1.prototype.update = function () {
        if (this.getQuestEnded() == false) {
            // Test if the player is dead, if so end the quest (he won) and return
            if (this.getGame().getPlayer().shouldDie()) {
                this.endQuest(true); // true because we always win
                return;
            }
            // Update entities
            this.updateEntities();
        }
        // Draw
        this.preDraw();
        this.getRenderArea().drawArray(Database.getAscii("places/quests/castle/room1/background"), this.getRealQuestPosition().x, this.getRealQuestPosition().y);
        this.drawEntities();
        this.drawAroundQuest();
        this.addExitQuestButton(new CallbackCollection(this.endQuest.bind(this, true), this.getGame().goToCastle.bind(this.getGame())), "buttonExitQuestKeeping");
        this.postDraw();
    };
    // Private methods
    CastleRoom1.prototype.addWalls = function () {
        // Create the wall entity
        var wall = new Wall(this, new Pos(0, 0));
        // Add the boxes
        wall.addBox(new Pos(0, 0), new Pos(100, 3));
        wall.addBox(new Pos(0, 3), new Pos(7, 25));
        wall.addBox(new Pos(7, 24), new Pos(93, 4));
        wall.addBox(new Pos(95, 3), new Pos(5, 5));
        wall.addBox(new Pos(95, 11), new Pos(5, 16));
        // Add the wall entity
        this.addEntity(wall);
    };
    return CastleRoom1;
})(Quest);
///<reference path="CastleRoom.ts"/>
Saving.registerBool("castleRoom2LitFire", false);
Saving.registerBool("castleRoom2TookObject", false);
var CastleRoom2 = (function (_super) {
    __extends(CastleRoom2, _super);
    function CastleRoom2(game) {
        _super.call(this, game);
        // The render area
        this.renderArea = new RenderArea();
        // The smokes
        this.smokes = [];
        // If needed, we add smokes
        if (Saving.loadBool("castleRoom2LitFire") == true) {
            this.addSmokes();
        }
        this.renderArea.resize(100, 30);
        this.update();
    }
    // getRenderArea()
    CastleRoom2.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    CastleRoom2.prototype.willBeDisplayed = function () {
        this.getGame().getOneSecondCallbackCollection().addCallback(this.actionSmokes.bind(this));
    };
    // update()
    CastleRoom2.prototype.update = function () {
        // Reset the area
        this.renderArea.resetAllButSize();
        // Add the button to go back to the castle
        this.addBackToTheCastleButton(this.renderArea, "castleRoom2BackToTheCastleButton");
        // If the fire isn't lit yet
        if (Saving.loadBool("castleRoom2LitFire") == false) {
            // Draw the dark color
            this.drawDark(0, 3, 100, 27);
            // Add the button on the fire
            this.drawFireButton(42, 20);
        }
        else {
            // We draw the fire
            this.drawFire(42, 20);
            // If we didn't take the object yet
            if (Saving.loadBool("castleRoom2TookObject") == false) {
                this.drawObject(21, 12);
            }
        }
    };
    // Private methods
    CastleRoom2.prototype.actionSmokes = function () {
        // If there's at least one smoke
        if (this.smokes.length > 0) {
            // We make the smokes move
            for (var i = 0; i < this.smokes.length; i++) {
                this.smokes[i].move();
            }
            // We update on the page
            this.update();
            this.getGame().updatePlace();
        }
    };
    CastleRoom2.prototype.addSmokes = function () {
        this.smokes.push(new Smoke(45, Random.between(20, 21), 11, Random.between(3, 7), 0, 5));
        this.smokes.push(new Smoke(45, Random.between(20, 21), 11, Random.between(2, 6), 0, 5));
        this.smokes.push(new Smoke(45, Random.between(20, 21), 11, Random.between(2, 6), 0, 5));
        this.smokes.push(new Smoke(45, Random.between(20, 21), 11, Random.between(2, 6), 0, 5));
        this.smokes.push(new Smoke(45, Random.between(20, 21), 11, Random.between(2, 6), 0, 5));
    };
    CastleRoom2.prototype.drawDark = function (x, y, width, height) {
        for (var i = y; i < y + height; i++) {
            this.renderArea.addBackgroundColor(x, x + width, i, new Color(ColorType.CASTLE_DARK_ROOM, true));
        }
    };
    CastleRoom2.prototype.drawFire = function (x, y) {
        // Draw the fire ascii art
        this.renderArea.drawArray(Database.getAscii("places/castle/room2/fire"), x, y);
        // Draw the smokes
        for (var i = 0; i < this.smokes.length; i++) {
            this.smokes[i].draw(this.renderArea);
        }
    };
    CastleRoom2.prototype.drawFireButton = function (x, y) {
        // Add the button
        this.renderArea.addMultipleAsciiButtons("castleRoom2LightFireButton", x, x + 16, y, x, x + 16, y + 1, x, x + 16, y + 2, x, x + 16, y + 3, x, x + 16, y + 4, x, x + 16, y + 5);
        // Add the link
        this.renderArea.addLinkCall(".castleRoom2LightFireButton", new CallbackCollection(this.lightFire.bind(this)));
    };
    CastleRoom2.prototype.drawObject = function (x, y) {
        // Draw the ascii art
        this.renderArea.drawArray(Database.getAscii("places/castle/room2/pitchfork"), x, y);
        // Add the button
        this.renderArea.addMultipleAsciiButtons("castleRoom2TakeObjectButton", x + 6, x + 12, y, x + 5, x + 11, y + 1, x + 4, x + 10, y + 2, x + 3, x + 9, y + 3, x + 2, x + 8, y + 4, x + 1, x + 7, y + 5, x + 1, x + 5, y + 6, x, x + 4, y + 7);
        // Add the link
        this.renderArea.addLinkCall(".castleRoom2TakeObjectButton", new CallbackCollection(this.takeObject.bind(this)));
    };
    CastleRoom2.prototype.lightFire = function () {
        // Change the bool
        Saving.saveBool("castleRoom2LitFire", true);
        // Add the smokes
        this.addSmokes();
        // Update
        this.update();
        this.getGame().updatePlace();
    };
    CastleRoom2.prototype.takeObject = function () {
        // Set the bool
        Saving.saveBool("castleRoom2TookObject", true);
        // Take it
        this.getGame().gainItem("gridItemPossessedPitchfork");
        // Re-calc the farm production
        this.getGame().calcLollipopFarmProduction();
        // Update
        this.update();
        this.getGame().updatePlace();
    };
    return CastleRoom2;
})(CastleRoom);
///<reference path="Quest.ts"/>
var CastleRoom3 = (function (_super) {
    __extends(CastleRoom3, _super);
    // Constructor
    function CastleRoom3(game) {
        _super.call(this, game);
        // Resize the quest
        this.resizeQuest(100, 30);
        // Add collision boxes around
        this.addPlayerCollisionBoxes(true, true, true, true);
        // Add the player
        this.getGame().getPlayer().loadCandyBoxCharacter(this);
        this.getGame().getPlayer().setGlobalPosition(new Pos(97, 23));
        this.configPlayerOrClone(this.getGame().getPlayer());
        this.addEntity(this.getGame().getPlayer());
        // Add the walls
        this.addWalls();
        // Add the eggs
        this.addEggs();
        // Add the monster
        this.addMonster();
        // Add the chest
        this.addChest();
        // Add the message
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You enter one of the castle's room."));
    }
    // Public methods
    CastleRoom3.prototype.castPlayerTeleport = function () {
        _super.prototype.castPlayerTeleport.call(this, new Pos(96, 19), new Pos(2, 3));
    };
    CastleRoom3.prototype.configPlayerOrClone = function (entity) {
        entity.setQuestEntityMovement(new QuestEntityMovement(new Pos(-1, 0)));
        entity.getQuestEntityMovement().setGravity(true);
        entity.getQuestEntityMovement().setWormsLike(true);
    };
    CastleRoom3.prototype.endQuest = function (win) {
        // We add some messages
        if (win) {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You exit the room."));
        }
        // We call the endQuest method of our mother class
        _super.prototype.endQuest.call(this, win);
    };
    CastleRoom3.prototype.update = function () {
        if (this.getQuestEnded() == false) {
            // Test if the player is dead, if so end the quest (he won) and return
            if (this.getGame().getPlayer().shouldDie()) {
                this.endQuest(true); // true because we always win
                return;
            }
            // Update entities
            this.updateEntities();
        }
        // Draw
        this.preDraw();
        this.getRenderArea().drawArray(Database.getAscii("places/quests/castle/room3/background"), this.getRealQuestPosition().x, this.getRealQuestPosition().y);
        this.drawEntities();
        this.drawAroundQuest();
        this.addExitQuestButton(new CallbackCollection(this.endQuest.bind(this, true), this.getGame().goToCastle.bind(this.getGame())), "buttonExitQuestKeeping");
        this.postDraw();
    };
    // Private methods
    CastleRoom3.prototype.addChest = function () {
        this.addEntity(new Chest(this, new Pos(7, 23), true, new CallbackCollection(this.openChest.bind(this)), Saving.loadBool("gridItemPossessedL")));
    };
    CastleRoom3.prototype.addEggs = function () {
        this.addEntity(new Egg(this, new Pos(16, 23), new CallbackCollection(this.anEggDiedCallback.bind(this))));
        this.addEntity(new Egg(this, new Pos(18, 23), new CallbackCollection(this.anEggDiedCallback.bind(this))));
        this.addEntity(new Egg(this, new Pos(23, 23), new CallbackCollection(this.anEggDiedCallback.bind(this))));
        this.addEntity(new Egg(this, new Pos(25, 23), new CallbackCollection(this.anEggDiedCallback.bind(this))));
        this.addEntity(new Egg(this, new Pos(28, 23), new CallbackCollection(this.anEggDiedCallback.bind(this))));
        this.addEntity(new Egg(this, new Pos(30, 23), new CallbackCollection(this.anEggDiedCallback.bind(this))));
        this.addEntity(new Egg(this, new Pos(38, 23), new CallbackCollection(this.anEggDiedCallback.bind(this))));
        this.addEntity(new Egg(this, new Pos(41, 23), new CallbackCollection(this.anEggDiedCallback.bind(this))));
        this.addEntity(new Egg(this, new Pos(48, 23), new CallbackCollection(this.anEggDiedCallback.bind(this))));
        this.addEntity(new Egg(this, new Pos(52, 23), new CallbackCollection(this.anEggDiedCallback.bind(this))));
        this.addEntity(new Egg(this, new Pos(54, 23), new CallbackCollection(this.anEggDiedCallback.bind(this))));
        this.addEntity(new Egg(this, new Pos(57, 23), new CallbackCollection(this.anEggDiedCallback.bind(this))));
        this.addEntity(new Egg(this, new Pos(63, 23), new CallbackCollection(this.anEggDiedCallback.bind(this))));
        this.addEntity(new Egg(this, new Pos(68, 23), new CallbackCollection(this.anEggDiedCallback.bind(this))));
        this.addEntity(new Egg(this, new Pos(72, 23), new CallbackCollection(this.anEggDiedCallback.bind(this))));
        this.addEntity(new Egg(this, new Pos(78, 23), new CallbackCollection(this.anEggDiedCallback.bind(this))));
    };
    CastleRoom3.prototype.addMonster = function () {
        this.monster = new Monster(this, new Pos(67, 3));
        this.addEntity(this.monster);
    };
    CastleRoom3.prototype.addWalls = function () {
        // Create the wall entity
        var wall = new Wall(this, new Pos(0, 0));
        // Add the boxes
        wall.addBox(new Pos(0, 0), new Pos(100, 3));
        wall.addBox(new Pos(0, 3), new Pos(7, 25));
        wall.addBox(new Pos(7, 24), new Pos(93, 4));
        wall.addBox(new Pos(95, 3), new Pos(5, 18));
        // Add the wall entity
        this.addEntity(wall);
    };
    CastleRoom3.prototype.anEggDiedCallback = function () {
        // We warn the monster that an egg was destroyed
        this.monster.eggDestroyed();
    };
    CastleRoom3.prototype.openChest = function () {
        this.foundGridOrEqItem(new QuestItemFound(this, "gridItemPossessedL", "You opened a chest and found a strange stone.", "You gain a strange stone."));
    };
    return CastleRoom3;
})(Quest);
///<reference path="CastleRoom.ts"/>
Saving.registerBool("castleTowerFirstVisitDone", false); // True if we already visited the tower at least once
// The following bools are true if we placed the corresponding stones in the tower
Saving.registerBool("castleTowerPStoneDone", false);
Saving.registerBool("castleTowerLStoneDone", false);
Saving.registerBool("castleTowerAStoneDone", false);
Saving.registerBool("castleTowerYStoneDone", false);
// Another one
Saving.registerBool("castleTowerTookTalkingCandy", false);
var CastleTower = (function (_super) {
    __extends(CastleTower, _super);
    // Constructor
    function CastleTower(game) {
        _super.call(this, game);
        // The render area
        this.renderArea = new RenderArea();
        // Byt default, the interval ID is set to null
        this.intervalID = null;
        // Set the cut scene max timer
        this.cutSceneMaxTimer = 72;
        // If it's the first time we visit the tower, we change the bool, set the timer and start the interval
        if (Saving.loadBool("castleTowerFirstVisitDone") == false) {
            Saving.saveBool("castleTowerFirstVisitDone", true);
            this.cutSceneTimer = 0;
            this.intervalID = setInterval(this.actionInterval.bind(this), 100);
        }
        else {
            this.cutSceneTimer = this.cutSceneMaxTimer;
        }
        this.renderArea.resize(100, 38);
        this.update();
    }
    // getRenderArea()
    CastleTower.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // willStopBeingDisplayed()
    CastleTower.prototype.willStopBeingDisplayed = function () {
        // Clear the interval if the interval ID isn't null
        if (this.intervalID != null)
            clearInterval(this.intervalID);
    };
    // Private methods
    CastleTower.prototype.actionInterval = function () {
        // If the timer hasn't reached the max timer yet, we increase it and update
        if (this.cutSceneTimer < this.cutSceneMaxTimer) {
            this.cutSceneTimer += 1;
            this.update();
            this.getGame().updatePlace();
        }
    };
    CastleTower.prototype.clickedOnStone = function (ourSavingName) {
        // This stone is now in the tower
        Saving.saveBool(ourSavingName, true);
        // Update
        this.update();
        this.getGame().updatePlace();
    };
    CastleTower.prototype.drawBackground = function () {
        // Calculate the gap
        var gap = (this.cutSceneMaxTimer - this.cutSceneTimer);
        if (gap > 60)
            gap = 60;
        // Draw the background ascii art
        this.renderArea.drawArray(Database.getAscii("places/castle/tower/castleTower"), 5, 3 - gap);
    };
    CastleTower.prototype.drawTalkingCandy = function () {
        // If all the stones are in the tower AND we didn't already take the talking candy, we draw the key
        if (Saving.loadBool("castleTowerPStoneDone") && Saving.loadBool("castleTowerLStoneDone") && Saving.loadBool("castleTowerAStoneDone") && Saving.loadBool("castleTowerYStoneDone") && Saving.loadBool("castleTowerTookTalkingCandy") == false) {
            // Draw the ascii art
            this.renderArea.drawArray(Database.getAscii("places/castle/tower/talkingCandy"), 47, 22);
            // Draw the button
            this.renderArea.addMultipleAsciiButtons("castleTowerTalkingCandyButton", 47, 50, 22, 47, 50, 23);
            this.renderArea.addLinkCall(".castleTowerTalkingCandyButton", new CallbackCollection(this.takeTalkingCandy.bind(this)));
        }
    };
    CastleTower.prototype.drawStone = function (savingName, ourSavingName, asciiArtName, pos) {
        // If we have the stone but it isn't in the tower yet
        if (Saving.loadBool(savingName) == true && Saving.loadBool(ourSavingName) == false) {
            // We add the button to click on the stone
            this.renderArea.addMultipleAsciiButtons("castleTower" + savingName + "Button", pos.x + 3, pos.x + 8, pos.y, pos.x + 2, pos.x + 9, pos.y + 1, pos.x + 1, pos.x + 10, pos.y + 2, pos.x + 2, pos.x + 9, pos.y + 3, pos.x + 3, pos.x + 8, pos.y + 4);
            // Add the link
            this.renderArea.addLinkCall(".castleTower" + savingName + "Button", new CallbackCollection(this.clickedOnStone.bind(this, ourSavingName)));
        }
        else if (Saving.loadBool(savingName) == true && Saving.loadBool(ourSavingName) == true) {
            // We draw the stone ascii art on the specified position
            this.renderArea.drawArray(Database.getAscii(asciiArtName), pos.x, pos.y - 1);
        }
    };
    CastleTower.prototype.drawStones = function () {
        // Calculate the gap
        var gap = (this.cutSceneMaxTimer - this.cutSceneTimer);
        if (gap > 60)
            gap = 60;
        // Draw the stones
        this.drawStone("gridItemPossessedP", "castleTowerPStoneDone", "gridItems/p", new Pos(25, 26 - gap));
        this.drawStone("gridItemPossessedL", "castleTowerLStoneDone", "gridItems/l", new Pos(38, 26 - gap));
        this.drawStone("gridItemPossessedA", "castleTowerAStoneDone", "gridItems/a", new Pos(51, 26 - gap));
        this.drawStone("gridItemPossessedY", "castleTowerYStoneDone", "gridItems/y", new Pos(64, 26 - gap));
    };
    CastleTower.prototype.takeTalkingCandy = function () {
        // We take the candy
        Saving.saveBool("castleTowerTookTalkingCandy", true);
        // We gain the corresponding item
        this.getGame().gainItem("gridItemPossessedTalkingCandy");
        // We update
        this.update();
        this.getGame().updatePlace();
    };
    CastleTower.prototype.update = function () {
        // Erase everything
        this.renderArea.resetAllButSize();
        // Back to the map button
        this.addBackToTheCastleButton(this.renderArea, "castleTowerBackToTheCastleButton");
        // Draw the background
        this.drawBackground();
        // Draw the stones related stuff
        this.drawStones();
        // Draw the talking candy related stuff
        this.drawTalkingCandy();
    };
    return CastleTower;
})(CastleRoom);
///<reference path="Place.ts"/>
Saving.registerNumber("cauldronBookCurrentPage", 0);
var Cauldron = (function (_super) {
    __extends(Cauldron, _super);
    // Constructor
    function Cauldron(game) {
        _super.call(this, game);
        // The render area
        this.renderArea = new RenderArea();
        // Maximum page
        this.maxPage = 10;
        // The candies & lollipops in the input field
        this.candiesInput = "";
        this.lollipopsInput = "";
        // The comments next to candies and lollipops input fields (they're needed if the player types something which isn't a number, or which is a negative number)
        this.candiesInputComment = null;
        this.lollipopsInputComment = null;
        // What are we doing?
        this.currentAction = CauldronAction.NOTHING;
        // Current timer time
        this.timerTime = 0;
        // Action log
        this.actionLog = [null, null, null, null, null]; // We always remember the last five actions
        // The comment telling the player the potions he managed to brew
        this.potionsComment = null;
        // Array containing the flames we can see when heating up the cauldron
        this.flames = [];
        // Launch the interval and get the ID
        this.timerIntervalID = setInterval(this.actionInterval.bind(this), 1000);
        // Resize and update
        this.renderArea.resize(100, 57);
        this.update(true);
    }
    // getRenderArea()
    Cauldron.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // willBeDisplayed()
    Cauldron.prototype.willBeDisplayed = function () {
        // We add hotkeys
        this.getGame().addHotkey(new Hotkey("a", new CallbackCollection(this.putInCauldron.bind(this))));
        this.getGame().addHotkey(new Hotkey("m", new CallbackCollection(this.changeAction.bind(this, CauldronAction.MIXING))));
        this.getGame().addHotkey(new Hotkey("b", new CallbackCollection(this.changeAction.bind(this, CauldronAction.BOILING))));
        this.getGame().addHotkey(new Hotkey("s", new CallbackCollection(this.changeAction.bind(this, CauldronAction.NOTHING))));
        this.getGame().addHotkey(new Hotkey("p", new CallbackCollection(this.putIntoBottles.bind(this))));
        this.getGame().addHotkey(new Hotkey("left", new CallbackCollection(this.previousPage.bind(this))));
        this.getGame().addHotkey(new Hotkey("right", new CallbackCollection(this.nextPage.bind(this))));
    };
    // willStopBeingDisplayed()
    Cauldron.prototype.willStopBeingDisplayed = function () {
        clearInterval(this.timerIntervalID);
    };
    // Private methods
    Cauldron.prototype.actionInterval = function () {
        // Increase the time
        this.timerTime += 1;
        // If we're boiling, update the flames array
        if (this.currentAction == CauldronAction.BOILING) {
            this.updateFlamesArray();
        }
        // If we're not doing nothing, update
        if (this.currentAction != CauldronAction.NOTHING) {
            this.update();
            this.getGame().updatePlace();
        }
    };
    Cauldron.prototype.changeAction = function (newAction) {
        // If we're not already doing that
        if (this.currentAction != newAction) {
            // If the action which just stopped wasn't nothing
            if (this.currentAction != CauldronAction.NOTHING) {
                // Shift actions in the log
                for (var i = this.actionLog.length - 1; i > 0; i--) {
                    this.actionLog[i] = this.actionLog[i - 1];
                }
                // Set actionLog[0] to the action which just stopped
                this.actionLog[0] = new CauldronActionLogEntry(this.currentAction, this.timerTime, this.getGame().getCandiesInCauldron().getCurrent(), this.getGame().getLollipopsInCauldron().getCurrent());
            }
            // Now we're doing that
            this.currentAction = newAction;
            // Reset the timer and restart the interval
            this.timerTime = 0;
            clearInterval(this.timerIntervalID);
            this.timerIntervalID = setInterval(this.actionInterval.bind(this), 1000);
            // We reset the flames array
            this.resetFlamesArray();
            // Update
            this.update();
            this.getGame().updatePlace();
        }
    };
    Cauldron.prototype.changeCandiesInput = function () {
        if ($(".cauldronCandiesInput").length)
            this.candiesInput = $(".cauldronCandiesInput").val();
    };
    Cauldron.prototype.changeLollipopsInput = function () {
        if ($(".cauldronLollipopsInput").length)
            this.lollipopsInput = $(".cauldronLollipopsInput").val();
    };
    Cauldron.prototype.drawActions = function (x, y, firstTimeWeUpdate, keepInputContent) {
        // Variables
        var candiesInputHasFocus = false;
        var lollipopsInputHasFocus = false;
        // If it's not the first time we update, we need to keep some stuff from the page (content of the inputs + focus on the inputs)
        if (firstTimeWeUpdate == false) {
            // If if the candies / lollipops input has the focus (in order to restore the focus after the page updating)
            candiesInputHasFocus = $(".cauldronCandiesInput").is(":focus");
            lollipopsInputHasFocus = $(".cauldronLollipopsInput").is(":focus");
            // Reset the content of candiesInput and lollipopsInput
            this.candiesInput = "";
            this.lollipopsInput = "";
        }
        // What you want to put in the cauldron
        // Text
        this.renderArea.drawString(Database.getText("cauldronWhatYouWantToPut"), x, y); // Normal
        this.renderArea.addBold(x, x + Database.getText("cauldronWhatYouWantToPut").length, y); // Add bold on normal
        this.renderArea.drawString(Database.getTranslatedText("cauldronWhatYouWantToPut"), x, y + 1, true); // Translated
        // Candies input
        this.renderArea.addSimpleInput(x, x + 20, y + 2, new CallbackCollection(this.changeCandiesInput.bind(this)), "cauldronCandiesInput", (keepInputContent ? this.candiesInput : ""), candiesInputHasFocus);
        this.renderArea.drawString("candies", x + 21, y + 2);
        if (this.candiesInputComment != null) {
            this.renderArea.drawString(this.candiesInputComment, x + 29, y + 2);
            this.renderArea.addBold(x + 29, x + 29 + this.candiesInputComment.length, y + 2);
        }
        // Lollipops input
        this.renderArea.addSimpleInput(x, x + 20, y + 4, new CallbackCollection(this.changeLollipopsInput.bind(this)), "cauldronLollipopsInput", (keepInputContent ? this.lollipopsInput : ""), lollipopsInputHasFocus);
        this.renderArea.drawString("lollipops", x + 21, y + 4);
        if (this.lollipopsInputComment != null) {
            this.renderArea.drawString(this.lollipopsInputComment, x + 31, y + 4);
            this.renderArea.addBold(x + 31, x + 31 + this.lollipopsInputComment.length, y + 4);
        }
        // Put all that in the cauldron
        this.renderArea.addAsciiRealButton("Put all that in the cauldron", x, y + 6, "cauldronPutAllThatInTheCauldronButton", "", false, 4);
        this.renderArea.addLinkCall(".cauldronPutAllThatInTheCauldronButton", new CallbackCollection(this.putInCauldron.bind(this)));
        // What is in the cauldron
        // Text
        this.renderArea.drawString(Database.getText("cauldronWhatIsIn"), x, y + 9); // Normal
        this.renderArea.addBold(x, x + Database.getText("cauldronWhatIsIn").length, y + 9); // Add bold on normal
        this.renderArea.drawString(Database.getTranslatedText("cauldronWhatIsIn"), x, y + 10, true); // Translated
        // Candies
        this.renderArea.drawString("Candies :", x + 2, y + 11);
        this.renderArea.drawString(Algo.numberToStringButNicely(this.getGame().getCandiesInCauldron().getCurrent()), x + 14, y + 11);
        // Lollipops
        this.renderArea.drawString("Lollipops :", x + 2, y + 12);
        this.renderArea.drawString(Algo.numberToStringButNicely(this.getGame().getLollipopsInCauldron().getCurrent()), x + 14, y + 12);
        // What you can do with it
        // Text
        this.renderArea.drawString(Database.getText("cauldronWhatYouCanDo"), x, y + 14); // Normal
        this.renderArea.addBold(x, x + Database.getText("cauldronWhatYouCanDo").length, y + 14); // Add bold on normal
        this.renderArea.drawString(Database.getTranslatedText("cauldronWhatYouCanDo"), x, y + 15, true); // Translated
        // Mix button
        this.renderArea.addAsciiRealButton("Mix", x, y + 16, "cauldronMixButton", "", false, 0);
        this.renderArea.addLinkCall(".cauldronMixButton", new CallbackCollection(this.changeAction.bind(this, CauldronAction.MIXING)));
        // Boil button
        this.renderArea.addAsciiRealButton("Boil", x + 5, y + 16, "cauldronBoilButton", "", false, 0);
        this.renderArea.addLinkCall(".cauldronBoilButton", new CallbackCollection(this.changeAction.bind(this, CauldronAction.BOILING)));
        // Stop button
        this.renderArea.addAsciiRealButton("Stop", x + 11, y + 16, "cauldronStopButton", "", false, 0);
        this.renderArea.addLinkCall(".cauldronStopButton", new CallbackCollection(this.changeAction.bind(this, CauldronAction.NOTHING)));
        // Show what we're doing
        switch (this.currentAction) {
            case CauldronAction.MIXING:
                this.renderArea.drawString("Mixing" + this.getSpecialMixingText(), x, y + 18);
                break;
            case CauldronAction.BOILING:
                this.renderArea.drawString("Boiling" + this.getSpecialBoilingText(), x, y + 18);
                break;
        }
        // Put into bottles if we're not questing
        if (this.getGame().getWeAreQuesting() == false) {
            this.renderArea.addAsciiRealButton("Put into bottles", x, y + 20, "cauldronPutIntoBottlesButton", "", false, 0);
            this.renderArea.addLinkCall(".cauldronPutIntoBottlesButton", new CallbackCollection(this.putIntoBottles.bind(this)));
        }
        else {
            this.renderArea.drawString("You can't put into bottles while you're in a quest", x, y + 20);
        }
        // The comment
        if (this.potionsComment != null)
            this.renderArea.drawString(this.potionsComment, x, y + 22);
    };
    Cauldron.prototype.drawBook = function (x, y) {
        // Draw the book
        this.renderArea.drawArray(Database.getAscii("places/cauldron/book"), x, y);
        // Draw the pages' content
        this.renderArea.drawArray(Database.getAscii("places/cauldron/bookPage" + Saving.loadNumber("cauldronBookCurrentPage")), x + 8, y + 1);
        this.renderArea.drawArray(Database.getAscii("places/cauldron/bookPage" + (Saving.loadNumber("cauldronBookCurrentPage") + 1)), x + 50, y + 1);
        // Add the previous page button if we're not already at the first page
        if (Saving.loadNumber("cauldronBookCurrentPage") > 0) {
            this.renderArea.addAsciiRealButton(Database.getText("cauldronPreviousPageButton"), x, y + 31, "cauldronPreviousPageButton", Database.getTranslatedText("cauldronPreviousPageButton"), true, -1, null, false);
            this.renderArea.addLinkCall(".cauldronPreviousPageButton", new CallbackCollection(this.previousPage.bind(this)));
        }
        // Add the next page button if we're not already at the last page
        if (Saving.loadNumber("cauldronBookCurrentPage") < this.maxPage) {
            this.renderArea.addAsciiRealButton(Database.getText("cauldronNextPageButton"), x + 87, y + 31, "cauldronNextPageButton", Database.getTranslatedText("cauldronNextPageButton"), true, -1, null, false, true);
            this.renderArea.addLinkCall(".cauldronNextPageButton", new CallbackCollection(this.nextPage.bind(this)));
        }
        // Add the translation if there is one
        if (Database.isTranslated()) {
            // Buttons on the left page
            for (var i = 1; i < 28; i++) {
                this.renderArea.addAsciiNinjaButton(x + 7, x + 48, i, "cauldronLeftPageTranslationButton");
            }
            // Buttons on the right page
            for (var i = 1; i < 28; i++) {
                this.renderArea.addAsciiNinjaButton(x + 49, x + 90, i, "cauldronRightPageTranslationButton");
            }
            // Tooltips
            this.renderArea.addTooltip("cauldronLeftPageTranslationButtonTooltip", Database.getTranslatedText("cauldron.page" + Saving.loadNumber("cauldronBookCurrentPage")));
            this.renderArea.addTooltip("cauldronRightPageTranslationButtonTooltip", Database.getTranslatedText("cauldron.page" + (Saving.loadNumber("cauldronBookCurrentPage") + 1)));
            // Links
            this.renderArea.addLinkOnHoverShowTooltip(".cauldronLeftPageTranslationButton", ".cauldronLeftPageTranslationButtonTooltip");
            this.renderArea.addLinkOnHoverShowTooltip(".cauldronRightPageTranslationButton", ".cauldronRightPageTranslationButtonTooltip");
        }
    };
    Cauldron.prototype.drawCauldron = function (x, y) {
        // Draw the cauldron
        this.renderArea.drawArray(Database.getAscii("places/cauldron/cauldron"), x, y);
        // Draw the flames
        for (var i = 0; i < this.flames.length; i++) {
            this.flames[i].draw(this.renderArea, x, y);
        }
    };
    Cauldron.prototype.getSpecialBoilingText = function () {
        if (this.timerTime < 3)
            return "... cold.";
        else if (this.timerTime < 6)
            return "... lukewarm.";
        else if (this.timerTime == 6)
            return "... hot.";
        else if (this.timerTime == 7)
            return "... hot..";
        else if (this.timerTime == 8)
            return "... hot...";
        else if (this.timerTime == 9)
            return "... very hot.";
        else if (this.timerTime == 10)
            return "... very hot..";
        else if (this.timerTime == 11)
            return "... very hot...";
        else if (this.timerTime < 14)
            return "... bubbles begin to appear.";
        else if (this.timerTime == 14)
            return "... bubbles begin to appear..";
        else if (this.timerTime == 15)
            return "... bubbles begin to appear...";
        else if (this.timerTime == 16)
            return "... bubbles begin to appear... and..";
        else if (this.timerTime == 17)
            return "... bubbles begin to appear... and...";
        else if (this.timerTime < 50)
            return "... BOILING!";
        else
            return "... the water is burnt. How is that possible?!";
    };
    Cauldron.prototype.getSpecialMixingText = function () {
        if (this.timerTime < 60)
            return "... (" + this.timerTime + ")";
        else
            return "... your arms are hurting :(";
    };
    Cauldron.prototype.makePotions = function (boolSavingName, numberSavingName, howMany, singularPotionName, pluralPotionName) {
        // We can now use this kind of potion
        Saving.saveBool(boolSavingName, true);
        // We increase the quantity
        Saving.saveNumber(numberSavingName, Saving.loadNumber(numberSavingName) + howMany);
        // We set the comment
        this.potionsComment = "You made " + Algo.pluralFormat(howMany, " " + singularPotionName, " " + pluralPotionName) + ".";
    };
    Cauldron.prototype.nextPage = function () {
        // If we can go to the next page
        if (Saving.loadNumber("cauldronBookCurrentPage") < this.maxPage) {
            // Change the current page number
            Saving.saveNumber("cauldronBookCurrentPage", Saving.loadNumber("cauldronBookCurrentPage") + 2);
            // Update
            this.update();
            this.getGame().updatePlace();
        }
    };
    Cauldron.prototype.previousPage = function () {
        // If we can go to the previous page
        if (Saving.loadNumber("cauldronBookCurrentPage") > 0) {
            // Change the current page number
            Saving.saveNumber("cauldronBookCurrentPage", Saving.loadNumber("cauldronBookCurrentPage") - 2);
            // Update
            this.update();
            this.getGame().updatePlace();
        }
    };
    Cauldron.prototype.putInCauldron = function () {
        // Used to know if we will have to update and return
        var updateAndReturn = false;
        // Parse the inputs and put them in two variables
        var candies = (this.candiesInput == "" ? 0 : parseInt(this.candiesInput));
        var lollipops = (this.lollipopsInput == "" ? 0 : parseInt(this.lollipopsInput));
        // Reset the comments
        this.candiesInputComment = null;
        this.lollipopsInputComment = null;
        // If the candies are incorrect, set the comment and return
        if (isNaN(candies)) {
            this.candiesInputComment = "(this isn't a number!)";
            updateAndReturn = true;
        }
        else if (candies < 0) {
            this.candiesInputComment = "(must be positive)";
            updateAndReturn = true;
        }
        else if (candies > this.getGame().getCandies().getCurrent()) {
            this.candiesInputComment = "(not enough candies)";
            updateAndReturn = true;
        }
        // If the lollipops are incorrect, set the comment and return
        if (isNaN(lollipops)) {
            this.lollipopsInputComment = "(this isn't a number!)";
            updateAndReturn = true;
        }
        else if (lollipops < 0) {
            this.lollipopsInputComment = "(must be positive)";
            updateAndReturn = true;
        }
        else if (lollipops > this.getGame().getLollipops().getCurrent()) {
            this.lollipopsInputComment = "(not enough lollipops)";
            updateAndReturn = true;
        }
        // If we have to update and return, well, we do that
        if (updateAndReturn) {
            this.update();
            this.getGame().updatePlace();
            return;
        }
        else {
            // Take the candies & lollipops
            this.getGame().getCandies().add(-candies);
            this.getGame().getLollipops().add(-lollipops);
            // Put all the stuff
            this.getGame().getCandiesInCauldron().add(candies);
            this.getGame().getLollipopsInCauldron().add(lollipops);
            // Update
            this.update(false, false);
            this.getGame().updatePlace();
        }
    };
    Cauldron.prototype.putIntoBottles = function () {
        // Reset the potions comment
        this.potionsComment = null;
        // Stop any action
        this.changeAction(CauldronAction.NOTHING);
        // Take the candies & lollipops in the cauldron
        this.getGame().getCandiesInCauldron().add(-this.getGame().getCandiesInCauldron().getCurrent());
        this.getGame().getLollipopsInCauldron().add(-this.getGame().getLollipopsInCauldron().getCurrent());
        // Health potion check
        if (this.actionLog[0] != null &&
            this.actionLog[0].getAction() == CauldronAction.MIXING &&
            this.actionLog[0].getLollipops() == 0 &&
            this.actionLog[0].getCandies() > 0 &&
            this.actionLog[0].getCandies() % 100 == 0 &&
            this.actionLog[0].getTime() < 30) {
            this.makePotions("questPlayerSpellHealthPotionHasSpell", "questPlayerSpellHealthPotionQuantity", this.actionLog[0].getCandies() / 100, "health potion", "health potions");
        }
        else if (this.actionLog[1] != null &&
            this.actionLog[1].getAction() == CauldronAction.MIXING &&
            this.actionLog[1].getCandies() > 0 &&
            this.actionLog[1].getLollipops() > 0 &&
            this.actionLog[1].getCandies() % 50 == 0 &&
            this.actionLog[1].getLollipops() % 500 == 0 &&
            this.actionLog[1].getLollipops() == 10 * this.actionLog[1].getCandies() &&
            this.actionLog[1].getTime() > 6 &&
            this.actionLog[1].getTime() < 14 &&
            this.actionLog[0] != null &&
            this.actionLog[0].getAction() == CauldronAction.MIXING &&
            this.actionLog[0].getCandies() == 2 * this.actionLog[1].getCandies() &&
            this.actionLog[0].getLollipops() == this.actionLog[1].getLollipops()) {
            this.makePotions("questPlayerSpellTurtlePotionHasSpell", "questPlayerSpellTurtlePotionQuantity", this.actionLog[0].getLollipops() / 500, "turtle potion", "turtle potions");
        }
        else if (this.actionLog[1] != null &&
            this.actionLog[1].getAction() == CauldronAction.BOILING &&
            this.actionLog[1].getLollipops() == 0 &&
            this.actionLog[1].getCandies() > 0 &&
            this.actionLog[1].getCandies() % 1000 == 0 &&
            this.actionLog[1].getTime() >= 3 && this.actionLog[1].getTime() < 6 &&
            this.actionLog[0] != null &&
            this.actionLog[0].getAction() == CauldronAction.BOILING &&
            this.actionLog[0].getLollipops() == 0 &&
            this.actionLog[0].getCandies() == 2 * this.actionLog[1].getCandies() &&
            this.actionLog[0].getTime() > 17) {
            this.makePotions("questPlayerSpellAntiGravityPotionHasSpell", "questPlayerSpellAntiGravityPotionQuantity", this.actionLog[1].getCandies() / 200, "anti-gravity potion", "anti-gravity potions");
        }
        else if (this.actionLog[0] != null &&
            this.actionLog[0].getAction() == CauldronAction.MIXING &&
            this.actionLog[0].getLollipops() > 0 &&
            this.actionLog[0].getLollipops() % 20000 == 0 &&
            this.actionLog[0].getTime() >= 60) {
            // If we didn't use any candy, then we made berserk potions
            if (this.actionLog[0].getCandies() == 0) {
                this.makePotions("questPlayerSpellBerserkPotionHasSpell", "questPlayerSpellBerserkPotionQuantity", this.actionLog[0].getLollipops() / 20000, "berserk potion", "berserk potions");
            }
            else {
                this.makePotions("questPlayerSpellCloningPotionHasSpell", "questPlayerSpellCloningPotionQuantity", this.actionLog[0].getLollipops() / 20000, "cloning potion", "cloning potions");
            }
        }
        else if (this.actionLog[2] != null &&
            this.actionLog[2].getAction() == CauldronAction.MIXING &&
            this.actionLog[2].getLollipops() == 0 &&
            this.actionLog[2].getCandies() > 0 &&
            this.actionLog[2].getCandies() % 500 == 0 &&
            this.actionLog[2].getTime() < 30 &&
            this.actionLog[1] != null &&
            this.actionLog[1].getLollipops() == 0 &&
            this.actionLog[1].getCandies() == this.actionLog[2].getCandies() + 100 * this.actionLog[2].getTime() &&
            this.actionLog[1].getAction() == CauldronAction.BOILING &&
            this.actionLog[1].getTime() >= 3 && this.actionLog[1].getTime() < 6 &&
            this.actionLog[0] != null &&
            this.actionLog[0].getAction() == CauldronAction.MIXING &&
            this.actionLog[0].getCandies() == this.actionLog[1].getCandies() &&
            this.actionLog[0].getLollipops() > 0) {
            this.makePotions("questPlayerSpellPPotionHasSpell", "questPlayerSpellPPotionQuantity", Math.ceil(this.actionLog[1].getCandies() / 500 + this.actionLog[0].getLollipops() / 1000), "P potion", "P potions");
        }
        else if (this.actionLog[4] != null && this.actionLog[3] != null && this.actionLog[2] != null && this.actionLog[1] != null && this.actionLog[0] != null &&
            this.actionLog[4].getAction() == CauldronAction.BOILING &&
            this.actionLog[3].getAction() == CauldronAction.BOILING &&
            this.actionLog[2].getAction() == CauldronAction.BOILING &&
            this.actionLog[1].getAction() == CauldronAction.BOILING &&
            this.actionLog[0].getAction() == CauldronAction.BOILING &&
            this.actionLog[4].getTime() < 3 &&
            this.actionLog[3].getTime() < 3 &&
            this.actionLog[2].getTime() < 3 &&
            this.actionLog[1].getTime() < 3 &&
            this.actionLog[0].getTime() >= 6 &&
            this.actionLog[4].getLollipops() == 0 && this.actionLog[4].getCandies() == 1 &&
            this.actionLog[3].getLollipops() == 0 && this.actionLog[3].getCandies() == 2 &&
            this.actionLog[2].getLollipops() == 0 && this.actionLog[2].getCandies() == 3 &&
            this.actionLog[1].getLollipops() == 0 && this.actionLog[1].getCandies() == 4 &&
            this.actionLog[0].getLollipops() == 1 && this.actionLog[0].getCandies() == 4) {
            this.makePotions("questPlayerSpellXPotionHasSpell", "questPlayerSpellXPotionQuantity", 1, "X potion", "X potions");
        }
        // If the potions comment is null, it means we didn't manage to make anything
        if (this.potionsComment == null)
            this.potionsComment = "You didn't manage to make anything.";
        // Reset the action log
        for (var i = 0; i < this.actionLog.length; i++) {
            this.actionLog[i] = null;
        }
        // Update
        this.update();
        this.getGame().updatePlace();
    };
    Cauldron.prototype.resetFlamesArray = function () {
        this.flames = [];
    };
    Cauldron.prototype.update = function (firstTimeWeUpdate, keepInputContent) {
        if (firstTimeWeUpdate === void 0) { firstTimeWeUpdate = false; }
        if (keepInputContent === void 0) { keepInputContent = true; }
        // Erase everything
        this.renderArea.resetAllButSize();
        // Draw everything
        this.drawBook(2, 0);
        this.drawCauldron(2, 39);
        this.drawActions(47, 34, firstTimeWeUpdate, keepInputContent);
    };
    Cauldron.prototype.updateFlamesArray = function () {
        // Create the variables
        var minX = 0;
        var maxX = 41;
        var minY;
        var maxY = 14;
        var howManyFlames;
        var x;
        var y;
        // Calculate minY
        minY = 14 - this.timerTime;
        if (minY < 5)
            minY = 5;
        // Caulcate howManyFlames
        howManyFlames = this.timerTime * 25;
        if (howManyFlames > 200)
            howManyFlames = 200;
        // Reset the array
        this.resetFlamesArray();
        // If we're boiling
        if (this.currentAction = CauldronAction.BOILING) {
            // Add flames depending on the current timer time
            for (var i = 0; i < howManyFlames; i++) {
                // Set y
                y = null;
                for (var j = maxY; j > minY; j--) {
                    if (Random.oneChanceOutOf(3)) {
                        y = j;
                        break;
                    }
                }
                if (y == null)
                    y = maxY;
                // Set x
                x = Random.between(minX + (14 - y), maxX - (14 - y));
                // Add the flame
                this.flames.push(new CauldronFlame(new Pos(x, y), Random.fromArray([")", "(", "`", "'", "."])));
            }
        }
    };
    return Cauldron;
})(Place);
var CauldronAction;
(function (CauldronAction) {
    CauldronAction[CauldronAction["NOTHING"] = 0] = "NOTHING";
    CauldronAction[CauldronAction["MIXING"] = 1] = "MIXING";
    CauldronAction[CauldronAction["BOILING"] = 2] = "BOILING";
})(CauldronAction || (CauldronAction = {}));
var CauldronActionLogEntry = (function () {
    // Constructor
    function CauldronActionLogEntry(action, time, candies, lollipops) {
        this.action = action;
        this.time = time;
        this.candies = candies;
        this.lollipops = lollipops;
    }
    // Public getters
    CauldronActionLogEntry.prototype.getAction = function () {
        return this.action;
    };
    CauldronActionLogEntry.prototype.getCandies = function () {
        return this.candies;
    };
    CauldronActionLogEntry.prototype.getLollipops = function () {
        return this.lollipops;
    };
    CauldronActionLogEntry.prototype.getTime = function () {
        return this.time;
    };
    return CauldronActionLogEntry;
})();
var CauldronFlame = (function () {
    // Constructor
    function CauldronFlame(pos, character) {
        this.pos = pos;
        this.character = character;
    }
    // Public methods
    CauldronFlame.prototype.draw = function (renderArea, x, y) {
        renderArea.drawString(this.character, x + this.pos.x, y + this.pos.y);
    };
    return CauldronFlame;
})();
///<reference path="Quest.ts"/>
Saving.registerBool("cellarDone", false);
var Cellar = (function (_super) {
    __extends(Cellar, _super);
    // Constructor
    function Cellar(game) {
        _super.call(this, game);
        // Resize the quest
        this.resizeQuest(100, 3);
        // Add collision boxes around
        this.addPlayerCollisionBoxes(true, false, true, true);
        // Add the player
        this.getGame().getPlayer().loadCandyBoxCharacter(this);
        this.getGame().getPlayer().setGlobalPosition(new Pos(0, 2));
        this.getGame().getPlayer().setQuestEntityMovement(new QuestEntityMovement(new Pos(1, 0)));
        this.getGame().getPlayer().getQuestEntityMovement().setGravity(true);
        this.getGame().getPlayer().getQuestEntityMovement().setWormsLike(false);
        this.addEntity(this.getGame().getPlayer());
        // Add the ground
        this.addGround();
        // Add the rats
        this.addRats();
        // Add a delimiter and the message
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You enter the cellar. It's dark and you hear rats squeaking all around you."));
    }
    // Public methods
    Cellar.prototype.endQuest = function (win) {
        // We add some messages
        if (win) {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You managed to kill all the rats!"));
            Saving.saveBool("cellarDone", true);
            // We gain the main map
            this.getGame().gainItem("gridItemPossessedMainMap");
        }
        else {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You died in the cellar. Rats are probably going to eat your body."));
        }
        // We call the endQuest method of our mother class
        _super.prototype.endQuest.call(this, win);
    };
    Cellar.prototype.update = function () {
        if (this.getQuestEnded() == false) {
            // Test if the player won the quest, if so, end the quest and return
            if (this.thePlayerWon()) {
                this.endQuest(true);
                return;
            }
            // Test if the player is dead, if so, end the quest and return
            if (this.getGame().getPlayer().shouldDie()) {
                this.endQuest(false);
                return;
            }
            // Update entities
            this.updateEntities();
        }
        // Draw
        this.preDraw();
        this.drawEntities();
        this.drawAroundQuest();
        if (this.getQuestEnded())
            this.addExitQuestButton(new CallbackCollection(this.goToFifthHouse.bind(this)), "buttonExitQuestKeeping");
        this.postDraw();
    };
    // Private methods
    Cellar.prototype.addGround = function () {
        var wall = new Wall(this, new Pos(0, this.getRealQuestSize().y));
        wall.addBox(new Pos(0, 0), new Pos(this.getRealQuestSize().x, 1));
        this.addEntity(wall);
    };
    Cellar.prototype.addRat = function (pos) {
        var rat = new Rat(this, pos);
        rat.setHealthBar(new QuestEntityHealthBar(rat, new Pos(3, 1)));
        this.addEntity(rat);
    };
    Cellar.prototype.addRats = function () {
        for (var i = 5; i <= 95; i++) {
            // One chance out of 3
            if (Random.oneChanceOutOf(3)) {
                // We add a rat
                this.addRat(new Pos(i, 2));
                // We increase i to avoid adding a rat above the last one
                i += 2;
            }
        }
    };
    Cellar.prototype.goToFifthHouse = function () {
        this.getGame().setPlace(new FifthHouse(this.getGame()));
    };
    Cellar.prototype.thePlayerWon = function () {
        // If the player is at the right of the desert, we return true
        if (this.getGame().getPlayer().getGlobalPosition().x >= 100)
            return true;
        // Else we return false
        return false;
    };
    return Cellar;
})(Quest);
///<reference path="Place.ts"/>
var Cfg = (function (_super) {
    __extends(Cfg, _super);
    // Constructor
    function Cfg(game) {
        _super.call(this, game);
        // The render area
        this.renderArea = new RenderArea();
        // The map used for the language selection : match the select's options id with the actual usually two letters code used by the Saving module
        this.languageSelectionMap = {
            "cfgLanguageEn": "en",
            "cfgLanguageBr": "br",
            "cfgLanguageCz": "cz",
            "cfgLanguageEs": "es",
            "cfgLanguageFr": "fr",
            "cfgLanguageNl": "nl",
            "cfgLanguageZh": "zh",
            "cfgLanguageDe": "de",
            "cfgLanguageSe": "se",
            "cfgLanguageHu": "hu",
            "cfgLanguageId": "id",
            "cfgLanguageKr": "kr",
            "cfgLanguagePl": "pl",
            "cfgLanguageUk": "uk",
            "cfgLanguageRu": "ru",
            "cfgLanguageTr": "tr",
            "cfgLanguageEl": "el"
        };
        // Resize the area
        this.renderArea.resize(100, 48);
        // Update for the first time
        this.update();
    }
    // getRenderArea()
    Cfg.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // Private methods
    Cfg.prototype.drawAbout = function (x, y) {
        // The title
        this.renderArea.drawArray(Database.getAscii("text/About"), x + 34, y);
        // Who?
        this.renderArea.drawString("Who?", x + 2, y + 7);
        this.renderArea.addBold(x + 2, x + 6, y + 7);
        // Who...
        this.renderArea.drawString("Ideas, game design & code by aniwey.", x + 4, y + 9);
        this.renderArea.drawString("Ascii art by Tobias Nordqvist, GodsTurf, dixsept, Dani \"Deinol\" Gómez and aniwey.", x + 4, y + 10);
        // License?
        this.renderArea.drawString("License?", x + 2, y + 13);
        this.renderArea.addBold(x + 2, x + 10, y + 13);
        // License...
        this.renderArea.drawString("The game source code is published under the GPLv3 license. This means you are free to modify and", x + 4, y + 15);
        this.renderArea.drawString("redistribute the game, even for commercial purposes, under some conditions.", x, y + 16);
        this.renderArea.addHtmlLink(x + 76, y + 16, "source_code.html", "Learn more.");
        this.renderArea.drawString("The ascii art is published under the CC-BY-SA license, which means that you can reuse it if you", x + 4, y + 18);
        this.renderArea.drawString("credit the artist who made the art and share your modifications under the same license.", x, y + 19);
        this.renderArea.addHtmlLink(x + 88, y + 19, "ascii_art.html", "Learn more.");
        // Aything else?
        this.renderArea.drawString("Anything else?", x + 2, y + 22);
        this.renderArea.addBold(x + 2, x + 16, y + 22);
        // Contact
        this.renderArea.drawString("Feel free to contact me at aniwey@gmail.com if you have any comments or questions :)", x + 4, y + 24);
    };
    Cfg.prototype.drawCfgInvertColors = function (x, y) {
        // Text
        this.renderArea.drawString(Database.getText("cfgInvertColors"), x, y);
        this.renderArea.drawString(Database.getTranslatedText("cfgInvertColors"), x, y + 1, true);
        // The checkbox
        this.renderArea.addCheckbox(x + Algo.takeBiggest(Database.getText("cfgInvertColors").length, Database.getTranslatedText("cfgInvertColors").length) + 2, y, new CallbackCollection(this.invertColorsChecked.bind(this)), new CallbackCollection(this.invertColorsUnchecked.bind(this)), "cfgInvertColorsCheckbox", Saving.loadBool("gameInvertedColors"));
    };
    Cfg.prototype.drawCfgLanguage = function (x, y) {
        // Text
        this.renderArea.drawString(Database.getText("cfgChooseLanguage"), x, y);
        this.renderArea.drawString(Database.getTranslatedText("cfgChooseLanguage"), x, y + 1, true);
        // List
        this.renderArea.addList(x + Algo.takeBiggest(Database.getText("cfgChooseLanguage").length, Database.getTranslatedText("cfgChooseLanguage").length) + 2, x + Algo.takeBiggest(Database.getText("cfgChooseLanguage").length, Database.getTranslatedText("cfgChooseLanguage").length) + 20, y, "cfgLanguageList", new CallbackCollection(this.languageSelected.bind(this)), [
            "cfgLanguageEn", "English",
            "cfgLanguageBr", "Brazilian Portuguese (by TranslaCAT)",
            "cfgLanguageZh", "Chinese (by Fan Zhang)",
            "cfgLanguageCz", "Czech (by Keranis)",
            "cfgLanguageNl", "Dutch (by Noël Wierema and Vincent van Gennep, corrections by Wessel van den Putte)",
            "cfgLanguageFr", "French (by aniwey)",
            "cfgLanguageDe", "German (by Kai Kubasta)",
            "cfgLanguageEl", "Greek (by VagosLabrou)",
            "cfgLanguageHu", "Hungarian (by The_Reaper_CooL)",
            "cfgLanguageId", "Indonesian (by Richard Sudaryono)",
            "cfgLanguageKr", "Korean (by jiyeonnn03)",
            "cfgLanguagePl", "Polish (by Patryk Połomski)",
            "cfgLanguageRu", "Russian (by Julia Richter (Zen Chelios Jr.))",
            "cfgLanguageEs", "Spanish (by Saúl Ruiz Calleja and Tania López Camino)",
            "cfgLanguageSe", "Swedish (by Jessica Tsiamis)",
            "cfgLanguageTr", "Turkish (by B. Güler)",
            "cfgLanguageUk", "Ukrainian (by Volodymyr Lataniuk)"
        ]);
        // Add the link which will call the selectRightLanguage method after the html dom is created
        this.renderArea.addLinkCallbackCollection(new CallbackCollection(this.selectRightLanguage.bind(this)));
        // Add the special message for the chinese translation
        if (Saving.loadString("gameLanguage") == "zh") {
            this.renderArea.drawString("中文版翻译会导致少量图像显示错误，我会尽量修复它们的！", x + 9, y + 2, true);
        }
        else if (Saving.loadString("gameLanguage") == "br") {
            this.renderArea.drawArray(Database.getAscii("general/translaCAT"), x + 70, y - 1);
            this.renderArea.addHtmlLink(x + 76, y + 7, "http://www.translacat.com/", "TranslaCAT");
        }
    };
    Cfg.prototype.drawConfigurationText = function (x, y) {
        this.renderArea.drawArray(Database.getAscii("text/Configuration"), x + 17, y);
    };
    Cfg.prototype.invertColorsChecked = function () {
        this.setInvertedColors(true);
    };
    Cfg.prototype.invertColorsUnchecked = function () {
        this.setInvertedColors(false);
    };
    Cfg.prototype.languageSelected = function () {
        // Get the selected language id
        var id = $("#cfgLanguageList").find(":selected").attr("id");
        // Set the new language
        if (this.languageSelectionMap[id] != null) {
            Saving.saveString("gameLanguage", this.languageSelectionMap[id]);
        }
        // Update Cfg
        this.update();
        this.getGame().updatePlace();
    };
    Cfg.prototype.selectRightLanguage = function () {
        // We iterate over all languages
        for (var language in this.languageSelectionMap) {
            // If this is the right one, we select it
            if (Saving.loadString("gameLanguage") == this.languageSelectionMap[language]) {
                $("#" + language).prop('selected', true);
            }
        }
    };
    Cfg.prototype.setInvertedColors = function (invertedColors) {
        Saving.saveBool("gameInvertedColors", invertedColors);
        this.getGame().applyInvertedColorsToCss();
        this.update();
        this.getGame().updateStatusBar(); // We also update the status bar to fix the selected tab's color
        this.getGame().updatePlace();
    };
    Cfg.prototype.update = function () {
        // Erase everything
        this.renderArea.resetAllButSize();
        // The "Configuration" text
        this.drawConfigurationText(0, 0);
        // Language selection
        this.drawCfgLanguage(0, 8);
        // Invert colors checkbox
        this.drawCfgInvertColors(0, 12);
        // "About" section
        this.drawAbout(0, 18);
    };
    return Cfg;
})(Place);
///<reference path="QuestEntity.ts"/>
var Chest = (function (_super) {
    __extends(Chest, _super);
    // Constructor
    function Chest(quest, globalPosition, isFacingRight, callbackCollection, isOpened) {
        if (isFacingRight === void 0) { isFacingRight = true; }
        if (callbackCollection === void 0) { callbackCollection = new CallbackCollection(); }
        if (isOpened === void 0) { isOpened = false; }
        // Call the mother constructor
        _super.call(this, quest, globalPosition, new Naming("A chest", "a chest"), new RenderArea(), new Pos(0, -1), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, -1), new Pos(3, 2))));
        // Set the parameters
        this.isFacingRight = isFacingRight;
        this.callbackCollection = callbackCollection;
        // At first, we're not opened
        this.isOpened = isOpened;
        // Create the opening collision box collection
        this.openingCollisionBoxCollection = new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(5, 3)));
        // Set the team (nature)
        this.setTeam(QuestEntityTeam.NATURE);
        // Resize the render area
        this.getRenderArea().resizeFromArray(Database.getAscii("places/quests/common/chestClosed"));
        this.setTransparency(new RenderTransparency(" "));
        // Draw for the first time
        this.drawChestAscii();
    }
    // update()
    Chest.prototype.update = function () {
        _super.prototype.update.call(this);
        // If the chest isn't opened yet
        if (this.isOpened == false) {
            // If the player has a collision box collection
            if (this.getQuest().getGame().getPlayer().getCbc() != null) {
                // If it collides with our opening collision box collection
                if (this.getQuest().getGame().getPlayer().getCbc().collidesWith(this.openingCollisionBoxCollection)) {
                    // We are now opened
                    this.isOpened = true;
                    // We fire the callback collection
                    this.callbackCollection.fire();
                    // We re-draw
                    this.drawChestAscii();
                }
            }
        }
    };
    // Private methods
    Chest.prototype.drawChestAscii = function () {
        // We erase
        this.getRenderArea().resetAllButSize();
        // If we're not opened
        if (this.isOpened == false) {
            this.getRenderArea().drawArray(Database.getAscii("places/quests/common/chestClosed"));
        }
        else {
            // If we're facing right
            if (this.isFacingRight)
                this.getRenderArea().drawArray(Database.getAscii("places/quests/common/chestOpenedRight"));
            else
                this.getRenderArea().drawArray(Database.getAscii("places/quests/common/chestOpenedLeft"));
        }
    };
    return Chest;
})(QuestEntity);
///<reference path="StatusBarResource.ts"/>
var ChocolateBars = (function (_super) {
    __extends(ChocolateBars, _super);
    // Constructor
    function ChocolateBars(game, savingPrefix) {
        _super.call(this, game, savingPrefix);
    }
    // Public methods
    ChocolateBars.prototype.getCurrentAsString = function (totalSize) {
        if (totalSize === void 0) { totalSize = 10; }
        var n = this.getCurrent();
        var size = totalSize;
        var base = "";
        var prefix = "";
        var suffix = "";
        // We set the base or return right now in some special cases
        if (n < 0)
            return "What, negative chocolate bars?!";
        else if (n == 1)
            return "You have 1 chocolate bar";
        else
            base = Algo.numberToStringButNicely(n);
        // How much space do we still have ?
        size = totalSize - base.length;
        // We set the suffix
        if (size >= 15) {
            suffix = " chocolate bars";
            // We add a suffix
            // How much space do we still have ?
            size = totalSize - base.length - suffix.length;
            // We set the prefix
            if (size >= 9)
                prefix = "You have ";
            else if (size >= 3)
                prefix = "-> ";
        }
        else if (size >= 3)
            suffix = " cb";
        // How much space do we still have ?
        size = totalSize - base.length - prefix.length - suffix.length;
        return prefix + base + suffix;
    };
    return ChocolateBars;
})(StatusBarResource);
var CollisionBox = (function () {
    // Constructor
    function CollisionBox(questEntity, position, size) {
        this.questEntity = questEntity;
        this.position = position;
        this.size = size;
    }
    // Public methods
    CollisionBox.prototype.collidesWith = function (collisionBox, pos) {
        if (pos === void 0) { pos = new Pos(0, 0); }
        // We return false if we detect that the collision is impossible
        if (collisionBox.questEntity.getGlobalPosition().x + collisionBox.position.x + collisionBox.size.x <= this.questEntity.getGlobalPosition().x + this.position.plus(pos).x)
            return false;
        if (collisionBox.questEntity.getGlobalPosition().x + collisionBox.position.x >= this.questEntity.getGlobalPosition().x + this.position.plus(pos).x + this.size.x)
            return false;
        if (collisionBox.questEntity.getGlobalPosition().y + collisionBox.position.y + collisionBox.size.y <= this.questEntity.getGlobalPosition().y + this.position.plus(pos).y)
            return false;
        if (collisionBox.questEntity.getGlobalPosition().y + collisionBox.position.y >= this.questEntity.getGlobalPosition().y + this.position.plus(pos).y + this.size.y)
            return false;
        // Else, we return true
        return true;
    };
    CollisionBox.prototype.move = function (pos) {
        this.position.add(pos);
    };
    // Public getters
    CollisionBox.prototype.getPosition = function () {
        return this.position;
    };
    CollisionBox.prototype.getSize = function () {
        return this.size;
    };
    return CollisionBox;
})();
var CollisionBoxCollection = (function () {
    // Constructor
    function CollisionBoxCollection() {
        var boxes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            boxes[_i - 0] = arguments[_i];
        }
        this.boxes = boxes;
    }
    // Public method
    CollisionBoxCollection.prototype.addCollisionBox = function (collisionBox) {
        this.boxes.push(collisionBox);
    };
    CollisionBoxCollection.prototype.collidesWith = function (collisionBoxCollection, pos) {
        if (pos === void 0) { pos = new Pos(0, 0); }
        // We test if one of our boxes collide with one of the boxes of the collection given in parameters
        for (var i = 0; i < this.boxes.length; i++) {
            for (var j = 0; j < collisionBoxCollection.getBoxes().length; j++) {
                // If there's a collision between those two, we return true
                if (this.boxes[i].collidesWith(collisionBoxCollection.getBoxes()[j], pos))
                    return true;
            }
        }
        // No collision, we return false
        return false;
    };
    CollisionBoxCollection.prototype.move = function (pos) {
        // We move each collision box
        for (var i = 0; i < this.boxes.length; i++) {
            this.boxes[i].move(pos);
        }
    };
    CollisionBoxCollection.prototype.removeBoxes = function () {
        this.boxes = [];
    };
    // Public getters
    CollisionBoxCollection.prototype.getBoxes = function () {
        return this.boxes;
    };
    return CollisionBoxCollection;
})();
var Color = (function () {
    // Constructor
    function Color(colorType, shouldInvert) {
        if (shouldInvert === void 0) { shouldInvert = false; }
        this.setColorType(colorType);
        this.shouldInvert = shouldInvert;
    }
    // Public getters
    Color.prototype.getColorString = function () {
        // If the player doesn't use inverted colors or we don't need to invert
        if (Saving.loadBool("gameInvertedColors") == false || this.shouldInvert == false)
            return this.colorString;
        else
            return this.invertedColorString;
    };
    // Public setters
    Color.prototype.setColorType = function (colorType) {
        // Set the type
        this.colorType = colorType;
        // Set r, g, and b depending on the color type
        switch (this.colorType) {
            // Health bars
            case ColorType.HEALTH_GREEN:
                this.setRGB(20, 212, 0);
                break;
            case ColorType.HEALTH_ORANGE:
                this.setRGB(255, 128, 0);
                break;
            case ColorType.HEALTH_RED:
                this.setRGB(230, 15, 0);
                break;
            case ColorType.HEALTH_UNICOLOR:
                this.setRGB(20, 212, 0);
                break;
            // Player spells
            case ColorType.PLAYER_FIREBALL:
                this.setRGB(255, 120, 0);
                break;
            case ColorType.PLAYER_ACID_DROP:
                this.setRGB(138, 172, 60);
                break;
            case ColorType.PLAYER_THORN:
                this.setRGB(85, 150, 40);
                break;
            case ColorType.PLAYER_OBSIDIAN_BRICK:
                this.setRGB(52, 0, 61);
                break;
            case ColorType.PLAYER_SUMMONED_DEMON:
                this.setRGB(0, 0, 0);
                break;
            // Eq items spells
            case ColorType.RED_ENCHANTED_GLOVES_FIREBALL:
                this.setRGB(255, 80, 0);
                break;
            // Quest buttons
            case ColorType.QUEST_BUTTON_ACID_RAIN:
                this.setRGB(138, 172, 60);
                break;
            case ColorType.QUEST_BUTTON_FIREBALL:
                this.setRGB(255, 120, 0);
                break;
            case ColorType.QUEST_BUTTON_TELEPORT:
                this.setRGB(185, 213, 213);
                break;
            case ColorType.QUEST_BUTTON_ERASE_MAGIC:
                this.setRGB(230, 255, 108);
                break;
            case ColorType.QUEST_BUTTON_THORNS_SHIELD:
                this.setRGB(85, 150, 40);
                break;
            case ColorType.QUEST_BUTTON_OBSIDIAN_WALL:
                this.setRGB(180, 90, 130);
                break;
            case ColorType.QUEST_BUTTON_BLACK_DEMONS:
                this.setRGB(128, 128, 128);
                break;
            case ColorType.QUEST_BUTTON_HEALTH_POTION:
                this.setRGB(255, 31, 31);
                break;
            case ColorType.QUEST_BUTTON_TURTLE_POTION:
                this.setRGB(123, 137, 13);
                break;
            case ColorType.QUEST_BUTTON_ANTI_GRAVITY_POTION:
                this.setRGB(187, 64, 188);
                break;
            case ColorType.QUEST_BUTTON_BERSERK_POTION:
                this.setRGB(110, 30, 47);
                break;
            case ColorType.QUEST_BUTTON_CLONING_POTION:
                this.setRGB(200, 200, 200);
                break;
            case ColorType.QUEST_BUTTON_P_POTION:
                this.setRGB(42, 135, 141);
                break;
            case ColorType.QUEST_BUTTON_X_POTION:
                this.setRGB(252, 82, 255);
                break;
            case ColorType.QUEST_BUTTON_SOME_OBJECT:
                this.setRGB(209, 131, 67);
                break;
            case ColorType.QUEST_BLACKHOLE_SPELL:
                this.setRGB(80, 80, 80);
                break;
            // Quest spells/potions countdown color
            case ColorType.QUEST_COUNTDOWN:
                this.setRGB(255, 0, 0);
                break;
            // Special colors used for the save page
            case ColorType.SAVE_GREEN:
                this.setRGB(42, 184, 39);
                break;
            case ColorType.SAVE_RED:
                this.setRGB(255, 28, 28);
                break;
            // Status bar special colors
            case ColorType.STATUS_BAR_SELECTED_TAB:
                this.setRGB(191, 191, 191);
                break;
            // Sea horse water ball
            case ColorType.SEAHORSE_WATER_BALL:
                this.setRGB(0, 58, 118);
                break;
            // The cave background color for the front exit
            case ColorType.THECAVE_BACKGROUND_COLOR:
                this.setRGB(20, 20, 20);
                break;
            // Secial color used by the monkey wizard
            case ColorType.MONKEY_WIZARD_BALL:
                this.setRGB(114, 0, 101);
                break;
            case ColorType.MONKEY_WIZARD_BALL_STORED:
                this.setRGB(114, 0, 56);
                break;
            // Special colors used in the forest quest
            case ColorType.TREE_SPIRIT_MAGIC_SPINE:
                this.setRGB(16, 95, 16);
                break;
            // Special color in the castle's dark room
            case ColorType.CASTLE_DARK_ROOM:
                this.setRGB(0, 0, 0);
                break;
            // Special colors for the shark fins
            case ColorType.BIGSHARK_FIN_RED:
                this.setRGB(217, 31, 31);
                break;
            case ColorType.BIGSHARK_FIN_GREEN:
                this.setRGB(31, 217, 64);
                break;
            case ColorType.BIGSHARK_FIN_PURPLE:
                this.setRGB(151, 31, 217);
                break;
            // Special colors for the blackhole spell
            case ColorType.BLACKHOLE_GREY20:
                this.setRGB(20, 20, 20);
                break;
            case ColorType.BLACKHOLE_GREY40:
                this.setRGB(40, 40, 40);
                break;
            case ColorType.BLACKHOLE_GREY60:
                this.setRGB(60, 60, 60);
                break;
            case ColorType.BLACKHOLE_GREY80:
                this.setRGB(80, 80, 80);
                break;
            case ColorType.BLACKHOLE_GREY100:
                this.setRGB(100, 100, 100);
                break;
            case ColorType.BLACKHOLE_GREY120:
                this.setRGB(120, 120, 120);
                break;
            case ColorType.BLACKHOLE_GREY140:
                this.setRGB(140, 140, 140);
                break;
            case ColorType.BLACKHOLE_GREY160:
                this.setRGB(160, 160, 160);
                break;
            case ColorType.BLACKHOLE_GREY180:
                this.setRGB(180, 180, 180);
                break;
            case ColorType.BLACKHOLE_GREY200:
                this.setRGB(200, 200, 200);
                break;
            case ColorType.BLACKHOLE_GREY220:
                this.setRGB(220, 220, 220);
                break;
            case ColorType.BLACKHOLE_GREY240:
                this.setRGB(240, 240, 240);
                break;
            // Special colors for the Hell quest
            case ColorType.HELL_RED_LAVA:
                this.setRGB(200, 8, 3);
                break;
            case ColorType.DEVIL_FIREBALL:
                this.setRGB(191, 0, 0);
                break;
            // Special colors for the developer quest
            case ColorType.DEVELOPER_BLUE:
                this.setRGB(20, 20, 213);
                break;
            case ColorType.DEVELOPER_YELLOW:
                this.setRGB(227, 194, 11);
                break;
            case ColorType.DEVELOPER_ORANGE:
                this.setRGB(201, 77, 9);
                break;
        }
    };
    // Private setters
    Color.prototype.setColorString = function (colorString) {
        this.colorString = colorString;
    };
    Color.prototype.setInvertedColorString = function (invertedColorString) {
        this.invertedColorString = invertedColorString;
    };
    Color.prototype.setRGB = function (r, g, b) {
        // Set r, g and b
        this.r = r;
        this.g = g;
        this.b = b;
        // Set the color strings from r, g and b
        this.setColorString("rgb(" + r.toString() + ", " + g.toString() + ", " + b.toString() + ")");
        this.setInvertedColorString("rgb(" + (255 - r).toString() + ", " + (255 - g).toString() + ", " + (255 - b).toString() + ")");
    };
    return Color;
})();
var ColorType;
(function (ColorType) {
    // Health bars
    ColorType[ColorType["HEALTH_GREEN"] = 0] = "HEALTH_GREEN";
    ColorType[ColorType["HEALTH_ORANGE"] = 1] = "HEALTH_ORANGE";
    ColorType[ColorType["HEALTH_RED"] = 2] = "HEALTH_RED";
    ColorType[ColorType["HEALTH_UNICOLOR"] = 3] = "HEALTH_UNICOLOR";
    // Player spells
    ColorType[ColorType["PLAYER_FIREBALL"] = 4] = "PLAYER_FIREBALL";
    ColorType[ColorType["PLAYER_ACID_DROP"] = 5] = "PLAYER_ACID_DROP";
    ColorType[ColorType["PLAYER_THORN"] = 6] = "PLAYER_THORN";
    ColorType[ColorType["PLAYER_OBSIDIAN_BRICK"] = 7] = "PLAYER_OBSIDIAN_BRICK";
    ColorType[ColorType["PLAYER_SUMMONED_DEMON"] = 8] = "PLAYER_SUMMONED_DEMON";
    // Eq items spells
    ColorType[ColorType["RED_ENCHANTED_GLOVES_FIREBALL"] = 9] = "RED_ENCHANTED_GLOVES_FIREBALL";
    // Quest buttons
    ColorType[ColorType["QUEST_BUTTON_ACID_RAIN"] = 10] = "QUEST_BUTTON_ACID_RAIN";
    ColorType[ColorType["QUEST_BUTTON_FIREBALL"] = 11] = "QUEST_BUTTON_FIREBALL";
    ColorType[ColorType["QUEST_BUTTON_TELEPORT"] = 12] = "QUEST_BUTTON_TELEPORT";
    ColorType[ColorType["QUEST_BUTTON_ERASE_MAGIC"] = 13] = "QUEST_BUTTON_ERASE_MAGIC";
    ColorType[ColorType["QUEST_BUTTON_THORNS_SHIELD"] = 14] = "QUEST_BUTTON_THORNS_SHIELD";
    ColorType[ColorType["QUEST_BUTTON_OBSIDIAN_WALL"] = 15] = "QUEST_BUTTON_OBSIDIAN_WALL";
    ColorType[ColorType["QUEST_BUTTON_BLACK_DEMONS"] = 16] = "QUEST_BUTTON_BLACK_DEMONS";
    ColorType[ColorType["QUEST_BUTTON_HEALTH_POTION"] = 17] = "QUEST_BUTTON_HEALTH_POTION";
    ColorType[ColorType["QUEST_BUTTON_TURTLE_POTION"] = 18] = "QUEST_BUTTON_TURTLE_POTION";
    ColorType[ColorType["QUEST_BUTTON_ANTI_GRAVITY_POTION"] = 19] = "QUEST_BUTTON_ANTI_GRAVITY_POTION";
    ColorType[ColorType["QUEST_BUTTON_BERSERK_POTION"] = 20] = "QUEST_BUTTON_BERSERK_POTION";
    ColorType[ColorType["QUEST_BUTTON_CLONING_POTION"] = 21] = "QUEST_BUTTON_CLONING_POTION";
    ColorType[ColorType["QUEST_BUTTON_P_POTION"] = 22] = "QUEST_BUTTON_P_POTION";
    ColorType[ColorType["QUEST_BUTTON_X_POTION"] = 23] = "QUEST_BUTTON_X_POTION";
    ColorType[ColorType["QUEST_BUTTON_SOME_OBJECT"] = 24] = "QUEST_BUTTON_SOME_OBJECT";
    ColorType[ColorType["QUEST_BLACKHOLE_SPELL"] = 25] = "QUEST_BLACKHOLE_SPELL";
    // Quest spells/potions countdown color
    ColorType[ColorType["QUEST_COUNTDOWN"] = 26] = "QUEST_COUNTDOWN";
    // Special colors used for the save page
    ColorType[ColorType["SAVE_GREEN"] = 27] = "SAVE_GREEN";
    ColorType[ColorType["SAVE_RED"] = 28] = "SAVE_RED";
    // Status bar special colors
    ColorType[ColorType["STATUS_BAR_SELECTED_TAB"] = 29] = "STATUS_BAR_SELECTED_TAB";
    // Sea horse water ball
    ColorType[ColorType["SEAHORSE_WATER_BALL"] = 30] = "SEAHORSE_WATER_BALL";
    // The cave background color for the front exit
    ColorType[ColorType["THECAVE_BACKGROUND_COLOR"] = 31] = "THECAVE_BACKGROUND_COLOR";
    // Secial colors used by the monkey wizard
    ColorType[ColorType["MONKEY_WIZARD_BALL"] = 32] = "MONKEY_WIZARD_BALL";
    ColorType[ColorType["MONKEY_WIZARD_BALL_STORED"] = 33] = "MONKEY_WIZARD_BALL_STORED";
    // Special colors used in the forest quest
    ColorType[ColorType["TREE_SPIRIT_MAGIC_SPINE"] = 34] = "TREE_SPIRIT_MAGIC_SPINE";
    // Special color in the castle's dark room
    ColorType[ColorType["CASTLE_DARK_ROOM"] = 35] = "CASTLE_DARK_ROOM";
    // Special colors for the shark fins
    ColorType[ColorType["BIGSHARK_FIN_RED"] = 36] = "BIGSHARK_FIN_RED";
    ColorType[ColorType["BIGSHARK_FIN_GREEN"] = 37] = "BIGSHARK_FIN_GREEN";
    ColorType[ColorType["BIGSHARK_FIN_PURPLE"] = 38] = "BIGSHARK_FIN_PURPLE";
    // Special colors for the blackhole spell
    ColorType[ColorType["BLACKHOLE_GREY20"] = 39] = "BLACKHOLE_GREY20";
    ColorType[ColorType["BLACKHOLE_GREY40"] = 40] = "BLACKHOLE_GREY40";
    ColorType[ColorType["BLACKHOLE_GREY60"] = 41] = "BLACKHOLE_GREY60";
    ColorType[ColorType["BLACKHOLE_GREY80"] = 42] = "BLACKHOLE_GREY80";
    ColorType[ColorType["BLACKHOLE_GREY100"] = 43] = "BLACKHOLE_GREY100";
    ColorType[ColorType["BLACKHOLE_GREY120"] = 44] = "BLACKHOLE_GREY120";
    ColorType[ColorType["BLACKHOLE_GREY140"] = 45] = "BLACKHOLE_GREY140";
    ColorType[ColorType["BLACKHOLE_GREY160"] = 46] = "BLACKHOLE_GREY160";
    ColorType[ColorType["BLACKHOLE_GREY180"] = 47] = "BLACKHOLE_GREY180";
    ColorType[ColorType["BLACKHOLE_GREY200"] = 48] = "BLACKHOLE_GREY200";
    ColorType[ColorType["BLACKHOLE_GREY220"] = 49] = "BLACKHOLE_GREY220";
    ColorType[ColorType["BLACKHOLE_GREY240"] = 50] = "BLACKHOLE_GREY240";
    // Special colors for the Hell quest
    ColorType[ColorType["HELL_RED_LAVA"] = 51] = "HELL_RED_LAVA";
    ColorType[ColorType["DEVIL_FIREBALL"] = 52] = "DEVIL_FIREBALL";
    // Special colors for the developer quest
    ColorType[ColorType["DEVELOPER_BLUE"] = 53] = "DEVELOPER_BLUE";
    ColorType[ColorType["DEVELOPER_YELLOW"] = 54] = "DEVELOPER_YELLOW";
    ColorType[ColorType["DEVELOPER_ORANGE"] = 55] = "DEVELOPER_ORANGE";
})(ColorType || (ColorType = {}));
///<reference path="./../../libs/jquery.d.ts"/>
var Database;
(function (Database) {
    // Variables
    var asciiMap = {}; // A map which associates strings (the keys) to array of strings (the ascii arts)
    var asciiSizeMap = {}; // A map which associates strings (the keys) to the sizes of ascii arts
    var textMap = {}; // A map which associated strings (the keys) to strings (the texts)
    // Public functions
    function addAscii(asciiName, width, height, asciiArray) {
        asciiMap[asciiName] = asciiArray;
        asciiSizeMap[asciiName] = new Pos(width, height);
    }
    Database.addAscii = addAscii;
    function addText(key, text) {
        textMap[key] = text;
    }
    Database.addText = addText;
    function isTranslated() {
        if (Saving.loadString("gameLanguage") != "en")
            return true;
        return false;
    }
    Database.isTranslated = isTranslated;
    // Public getters
    function getAscii(key) {
        if (asciiMap[key] == null)
            console.log("Error : trying to access the unknown ascii art \"" + key + "\"");
        return asciiMap[key];
    }
    Database.getAscii = getAscii;
    function getAsciiHeight(key) {
        return asciiSizeMap[key].y;
    }
    Database.getAsciiHeight = getAsciiHeight;
    function getAsciiWidth(key) {
        return asciiSizeMap[key].x;
    }
    Database.getAsciiWidth = getAsciiWidth;
    function getPartOfAscii(key, y1, y2) {
        return getAscii(key).slice(y1, y2);
    }
    Database.getPartOfAscii = getPartOfAscii;
    function getText(key) {
        if (textMap["en." + key] == null)
            console.log("Error : trying to access the unknown text \"" + key + "\"");
        return textMap["en." + key];
    }
    Database.getText = getText;
    function getTranslatedText(key) {
        // If we have a language (other than english) selected
        if (Saving.loadString("gameLanguage") != "en") {
            // If the translated text can't be found
            if (textMap[Saving.loadString("gameLanguage") + "." + key] == null)
                console.log("Error : trying to access the unknown translated text \"" + key + "\" for language " + Saving.loadString("gameLanguage") + "."); // Error
            // If the translated text isn't chinese
            if (Saving.loadString("gameLanguage") != "zh")
                return textMap[Saving.loadString("gameLanguage") + "." + key]; // We just return the text
            else
                return textMap[Saving.loadString("gameLanguage") + "." + key].addChineseSpaces(); // We return the text after adding spaces
        }
        // Else, we return an empty string
        return "";
    }
    Database.getTranslatedText = getTranslatedText;
})(Database || (Database = {}));
///<reference path="QuestEntity.ts"/>
var Demon = (function (_super) {
    __extends(Demon, _super);
    // Constructor
    function Demon(quest, pos) {
        _super.call(this, quest, pos, new Naming("A demon", "a demon"), new RenderArea(0, 0), new Pos(0, 0), new CollisionBoxCollection(), new QuestEntityMovement());
        // Set gravity
        this.getQuestEntityMovement().setGravity(true);
        // Set destructible
        this.setDestructible(true);
        // Set the demon type, randomly-chosen
        switch (Random.between(0, 2)) {
            case 0:
                this.type = DemonType.CUBE;
                break;
            case 1:
                this.type = DemonType.EYES;
                break;
            case 2:
                this.type = DemonType.BUBBLES;
                break;
        }
        // Depending on the type, resize the render area, add a collision box, and draw the ascii art, and add the weapon and its delay
        switch (this.type) {
            case DemonType.CUBE:
                this.getRenderArea().resize(5, 3);
                this.getCbc().addCollisionBox(new CollisionBox(this, new Pos(0, 0), new Pos(5, 3)));
                this.getRenderArea().drawArray(Database.getAscii("places/quests/hell/demonCube"));
                this.setTransparency(new RenderTransparency(" ", "%"));
                this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("Its huge body", "its huge body"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, 2), new Pos(7, 2))), 50));
                this.getLastQuestEntityWeapon().getCloseCombatDelay().setFixedDelay(10);
                break;
            case DemonType.EYES:
                this.getRenderArea().resize(5, 4);
                this.getCbc().addCollisionBox(new CollisionBox(this, new Pos(0, 1), new Pos(5, 3)));
                this.getRenderArea().drawArray(Database.getAscii("places/quests/hell/demonEyes"));
                this.setTransparency(new RenderTransparency(" ", "%"));
                this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("Demonish eyes", "demonish eyes"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(7, 6))), 10));
                this.getLastQuestEntityWeapon().getCloseCombatDelay().setFixedDelay(0);
                break;
            case DemonType.BUBBLES:
                this.getRenderArea().resize(5, 3);
                this.getCbc().addCollisionBox(new CollisionBox(this, new Pos(0, 0), new Pos(5, 3)));
                this.getRenderArea().drawArray(Database.getAscii("places/quests/hell/demonBubbles" + Random.between(0, 6).toString()));
                this.setTransparency(new RenderTransparency(" "));
                this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("Fire bubbles", "fire bubbles"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(7, 5))), 15));
                this.getLastQuestEntityWeapon().getCloseCombatDelay().setFixedDelay(1);
                break;
        }
        // Set the health points, depending on the type
        switch (this.type) {
            case DemonType.CUBE:
                this.setMaxHp(120);
                this.setHp(120);
                break;
            default:
                this.setMaxHp(30 + Random.between(0, 7) * 10);
                this.setHp(this.getMaxHp());
                break;
        }
    }
    // update()
    Demon.prototype.update = function () {
        // Try to go towards the player
        this.goTowards(this.getRenderAreaCenter(), this.getQuest().getGame().getPlayer().getRenderAreaCenter(), 0, new Pos(1, 0));
        // If we're far from the player, we try to jump
        if (Math.abs(this.getRenderAreaCenter().x - this.getQuest().getGame().getPlayer().getRenderAreaCenter().x) > 5)
            this.jump(3);
        // Call the mother class update method
        _super.prototype.update.call(this);
    };
    // willDie()
    Demon.prototype.willDie = function () {
        this.getQuest().getGame().getQuestLog().addMessage(new QuestLogMessage(this.getDeathMessage() + " (and found " + Algo.pluralFormat(this.getQuest().foundCandies(5 + Random.upTo(5)), " candy", " candies") + ")", this.getQuest().getCandiesFoundMessage()));
    };
    return Demon;
})(QuestEntity);
var DemonType;
(function (DemonType) {
    DemonType[DemonType["CUBE"] = 0] = "CUBE";
    DemonType[DemonType["EYES"] = 1] = "EYES";
    DemonType[DemonType["BUBBLES"] = 2] = "BUBBLES";
})(DemonType || (DemonType = {}));
///<reference path="Quest.ts"/>
var Desert = (function (_super) {
    __extends(Desert, _super);
    // Constructor
    function Desert(game) {
        _super.call(this, game);
        // Resize the quest
        this.resizeQuest(149, 30);
        // Add collision boxes around
        this.addPlayerCollisionBoxes(true, false, true, true);
        // Add the player
        this.getGame().getPlayer().loadCandyBoxCharacter(this);
        this.getGame().getPlayer().setGlobalPosition(new Pos(0, 26));
        this.configPlayerOrClone(this.getGame().getPlayer());
        this.addEntity(this.getGame().getPlayer());
        // Add the ground
        this.addGround(0, 3, 1, 4, 12, 0, 13, 18, 1, 19, 24, 2, 25, 30, 3, 31, 36, 2, 37, 42, 1, 43, 51, 0, 52, 57, 1, 58, 62, 2, 63, 68, 3, 69, 75, 2, 76, 82, 1, 83, 92, 0, 93, 97, 1, 98, 101, 2, 102, 107, 3, 108, 113, 2, 114, 119, 1, 120, 128, 0, 129, 134, 1, 135, 139, 2, 140, 145, 3, 146, 148, 2);
        // Bird adding stuff
        this.currentBirdTime = 0;
        this.setNextBirdAt();
        // Add the camels
        this.addCamel(new Pos(44, 24));
        this.addCamel(new Pos(65, 26));
        this.addCamel(new Pos(84, 24));
        this.addCamel(new Pos(106, 26));
        this.addCamel(new Pos(118, 24));
        this.addCamel(new Pos(144, 26));
        // Add the message
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You enter the desert, camels and palm trees as far as the eye can see."));
    }
    // Public methods
    Desert.prototype.configPlayerOrClone = function (entity) {
        entity.setQuestEntityMovement(new QuestEntityMovement(new Pos(1, 0)));
        entity.getQuestEntityMovement().setGravity(true);
        entity.getQuestEntityMovement().setWormsLike(true);
    };
    Desert.prototype.endQuest = function (win) {
        // We add some messages
        if (win) {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You made your way through the desert!"));
            Saving.saveBool("mainMapDoneDesert", true); // The desert is done
        }
        else {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You died in the desert. Alone."));
        }
        // We call the endQuest method of our mother class
        _super.prototype.endQuest.call(this, win);
    };
    Desert.prototype.update = function () {
        if (this.getQuestEnded() == false) {
            // Possibly add a bird
            if (this.currentBirdTime >= this.nextBirdAt) {
                this.currentBirdTime = 0;
                this.setNextBirdAt();
                this.addBird();
            }
            else
                this.currentBirdTime += 1;
            // Test if the player won the quest, if so, end the quest and return
            if (this.thePlayerWon()) {
                this.endQuest(true);
                return;
            }
            // Test if the player is dead, if so, end the quest and return
            if (this.getGame().getPlayer().shouldDie()) {
                this.endQuest(false);
                return;
            }
            // Update entities
            this.updateEntities();
        }
        // Draw
        this.preDraw();
        this.getRenderArea().drawArray(Database.getAscii("places/quests/desert/background"), this.getRealQuestPosition().x, this.getRealQuestPosition().y + 21);
        this.drawEntities();
        this.drawAroundQuest();
        if (this.getQuestEnded() == false)
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestNoKeeping");
        else if (this.getQuestEndedAndWeWon() == false)
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestNoKeepingBecauseLose");
        else
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestKeeping");
        this.postDraw();
    };
    // Private methods
    Desert.prototype.addBird = function () {
        // We create the variable which will contain our bird
        var bird;
        // We choose the y position of our bird
        var yPos = Random.upTo(14);
        // We check if we could collide with another bird using this y position
        for (var i = 0; i < this.getEntities().length; i++) {
            if (this.getEntities()[i].getCbc() != null && this.getEntities()[i].getCbc().collidesWith(new CollisionBoxCollection(new CollisionBox(new QuestEntity(this, new Pos(0, 0)), new Pos(0, yPos), new Pos(149, 4)))))
                return;
        }
        // We add a bird going right
        if (Random.flipACoin()) {
            bird = new DesertBird(this, new Pos(-9, yPos), true);
        }
        else {
            bird = new DesertBird(this, new Pos(149, yPos), false);
        }
        // We add the health bar and finally add the bird to the entities
        bird.setHealthBar(new QuestEntityHealthBar(bird, new Pos(9, 1)));
        this.addEntity(bird);
    };
    Desert.prototype.addCamel = function (pos) {
        var camel;
        if (Random.oneChanceOutOf(20))
            camel = new TripodCamel(this, pos);
        else
            camel = new Camel(this, pos);
        camel.setHealthBar(new QuestEntityHealthBar(camel, new Pos(7, 1)));
        this.addEntity(camel);
    };
    Desert.prototype.addGround = function () {
        var positions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            positions[_i - 0] = arguments[_i];
        }
        // Create the wall entity
        this.addEntity(new Wall(this, new Pos(0, 26)));
        var wall = (this.getLastEntity());
        // Add the boxes
        for (var i = 0; i < positions.length / 3; i++) {
            wall.addBox(new Pos(positions[i * 3], positions[i * 3 + 2]), new Pos(positions[i * 3 + 1] - positions[i * 3] + 1, 4 - positions[i * 3 + 2]));
        }
    };
    Desert.prototype.setNextBirdAt = function () {
        this.nextBirdAt = 20 + Random.upTo(30);
    };
    Desert.prototype.thePlayerWon = function () {
        // If the player is at the right of the desert, we return true
        if (this.getGame().getPlayer().getGlobalPosition().x >= 149)
            return true;
        // Else we return false
        return false;
    };
    return Desert;
})(Quest);
///<reference path="QuestEntity.ts"/>
var DesertBird = (function (_super) {
    __extends(DesertBird, _super);
    // Constructor
    function DesertBird(quest, pos, goingRight) {
        _super.call(this, quest, pos, new Naming("A desert bird", "a desert bird"), new RenderArea(9, 4), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 0), new Pos(9, 4))));
        // If we're heading to right
        if (goingRight) {
            this.setQuestEntityMovement(new QuestEntityMovement(new Pos(1, 0)));
            this.setQuestEntityAnimation(new QuestEntityAnimation(3, Random.upTo(2), Random.upTo(1), "places/quests/desert/birdRightUp", "places/quests/desert/birdRightDown"));
        }
        else {
            this.setQuestEntityMovement(new QuestEntityMovement(new Pos(-1, 0)));
            this.setQuestEntityAnimation(new QuestEntityAnimation(3, Random.upTo(2), Random.upTo(1), "places/quests/desert/birdLeftUp", "places/quests/desert/birdLeftDown"));
        }
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(6);
        this.setHp(6);
    }
    // willDie()
    DesertBird.prototype.willDie = function () {
        _super.prototype.willDie.call(this);
        this.getQuest().foundGridOrEqItem(new QuestItemFound(this.getQuest(), "gridItemPossessedFeather", "You found a desert bird feather!", "You gain a desert bird feather"));
    };
    return DesertBird;
})(QuestEntity);
///<reference path="Quest.ts"/>
var Developer = (function (_super) {
    __extends(Developer, _super);
    // Constructor
    function Developer(game) {
        _super.call(this, game);
        // Resize the quest
        this.resizeQuest(100, 34);
        // Add collision boxes around
        this.addPlayerCollisionBoxes(true, true, true, true);
        // Add the player
        this.getGame().getPlayer().loadCandyBoxCharacter(this);
        this.getGame().getPlayer().setGlobalPosition(new Pos(0, 33));
        this.configPlayerOrClone(this.getGame().getPlayer());
        this.addEntity(this.getGame().getPlayer());
        // Add the developer entity
        this.addDeveloperEntity(new Pos(57, 0));
        // Add the message
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You're attacking the developer."));
    }
    // Public methods
    Developer.prototype.castPlayerBlackDemons = function () {
        _super.prototype.castPlayerBlackDemons.call(this);
        this.developerEntity.playerUsedBlackMagic();
    };
    Developer.prototype.castPlayerBlackhole = function () {
        _super.prototype.castPlayerBlackhole.call(this);
        this.developerEntity.playerUsedBlackMagic();
    };
    Developer.prototype.castPlayerEraseMagic = function () {
        _super.prototype.castPlayerEraseMagic.call(this);
        this.developerEntity.playerUsedBlackMagic();
    };
    Developer.prototype.castPlayerObsidianWall = function () {
        _super.prototype.castPlayerObsidianWall.call(this);
        this.developerEntity.playerUsedBlackMagic();
    };
    Developer.prototype.configPlayerOrClone = function (entity) {
        entity.setQuestEntityMovement(new QuestEntityMovement(new Pos(1, 0)));
        entity.getQuestEntityMovement().setGravity(true);
        entity.getQuestEntityMovement().setWormsLike(true);
    };
    Developer.prototype.endQuest = function (win) {
        // We add some messages
        if (win) {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You managed to beat me. Congratulations :)"));
        }
        else {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You died fighting the developer. Eh, he made this game after all!"));
        }
        // We call the endQuest method of our mother class
        _super.prototype.endQuest.call(this, win);
    };
    Developer.prototype.update = function () {
        if (this.getQuestEnded() == false) {
            // Test if the player won the quest, if so, end the quest and return
            if (this.thePlayerWon()) {
                this.endQuest(true);
                return;
            }
            // Test if the player is dead, if so, end the quest and return
            if (this.getGame().getPlayer().shouldDie()) {
                this.endQuest(false);
                return;
            }
            // Update entities
            this.updateEntities();
        }
        // Draw
        this.preDraw();
        this.drawEntities();
        this.drawAroundQuest();
        if (this.getQuestEnded() == false)
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestNoKeeping");
        else if (this.getQuestEndedAndWeWon() == false)
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestNoKeepingBecauseLose");
        else
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestKeeping");
        this.postDraw();
    };
    // Private methods
    Developer.prototype.addDeveloperEntity = function (pos) {
        this.developerEntity = new DeveloperEntity(this, pos);
        this.developerEntity.setHealthBar(new QuestEntityHealthBar(this.developerEntity, new Pos(100, 1), new Pos(0, 0), QuestEntityHealthBarPositionType.FIXED_ON_PAGE, true, true, BarType.HEALTH));
        this.addEntity(this.developerEntity);
    };
    Developer.prototype.thePlayerWon = function () {
        // If the developer is dead, we return true
        if (this.developerEntity.shouldDie())
            return true;
        // Else we return false
        return false;
    };
    return Developer;
})(Quest);
///<reference path="QuestEntity.ts"/>
var DeveloperEntity = (function (_super) {
    __extends(DeveloperEntity, _super);
    // Constructor
    function DeveloperEntity(quest, pos) {
        _super.call(this, quest, pos, new Naming("The developer", "the developer"), new RenderArea(43, 34), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(20, 0), new Pos(6, 1)), new CollisionBox(this, new Pos(16, 1), new Pos(12, 1)), new CollisionBox(this, new Pos(15, 2), new Pos(14, 1)), new CollisionBox(this, new Pos(12, 3), new Pos(18, 1)), new CollisionBox(this, new Pos(11, 4), new Pos(20, 1)), new CollisionBox(this, new Pos(10, 5), new Pos(22, 1)), new CollisionBox(this, new Pos(9, 6), new Pos(24, 2)), new CollisionBox(this, new Pos(9, 8), new Pos(25, 1)), new CollisionBox(this, new Pos(9, 9), new Pos(26, 2)), new CollisionBox(this, new Pos(9, 11), new Pos(27, 3)), new CollisionBox(this, new Pos(9, 14), new Pos(28, 1)), new CollisionBox(this, new Pos(8, 15), new Pos(29, 3)), new CollisionBox(this, new Pos(7, 18), new Pos(30, 4)), new CollisionBox(this, new Pos(7, 22), new Pos(31, 2)), new CollisionBox(this, new Pos(6, 24), new Pos(32, 4)), new CollisionBox(this, new Pos(5, 28), new Pos(33, 1)), new CollisionBox(this, new Pos(5, 29), new Pos(34, 1)), new CollisionBox(this, new Pos(4, 30), new Pos(35, 1)), new CollisionBox(this, new Pos(2, 31), new Pos(38, 1)), new CollisionBox(this, new Pos(1, 32), new Pos(40, 1)), new CollisionBox(this, new Pos(0, 33), new Pos(43, 1))), new QuestEntityMovement());
        // Init the time spent
        this.timeSpent = 0;
        // Create the texts
        this.createTexts();
        // Set gravity
        this.getQuestEntityMovement().setGravity(false);
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(1000000000);
        this.setHp(1000000000);
        // Set the ascii art and the transparent character
        this.getRenderArea().drawArray(Database.getAscii("places/quests/developer/me"));
        this.setTransparency(new RenderTransparency(" "));
    }
    // inflictDamage()
    DeveloperEntity.prototype.inflictDamage = function (damage, reason) {
        _super.prototype.inflictDamage.call(this, damage * Random.between(60000, 70000), reason);
    };
    // update()
    DeveloperEntity.prototype.update = function () {
        // Increase the time spent
        this.timeSpent += 1;
        // Increase the current text index, depending on the time spent
        if (this.timeSpent == 95 || this.timeSpent == 245)
            this.indexOfCurrentText += 1;
        // Call the current text update method
        this.texts[this.indexOfCurrentText].update(this);
        // Call the mother class update method
        _super.prototype.update.call(this);
    };
    // willDie()
    DeveloperEntity.prototype.willDie = function () {
        this.getQuest().getGame().getQuestLog().addMessage(new QuestLogMessage(this.getDeathMessage() + " (and found " + Algo.pluralFormat(this.getQuest().foundCandies(6000000), " candy", " candies") + ")", this.getQuest().getCandiesFoundMessage()));
        this.getQuest().foundGridOrEqItem(new QuestItemFound(this.getQuest(), "gridItemPossessedY", "You found a strange stone.", "You gain a strange stone."));
    };
    // Public methods
    DeveloperEntity.prototype.addMagicBall = function (finalPosition, damage, timeToLive, colorType) {
        // Set the first position (either the mouth or one of the eyes)
        var firstPosition;
        switch (Random.upTo(2)) {
            case 0:
                firstPosition = new Pos(15, 15);
                break;
            case 1:
                firstPosition = new Pos(25, 15);
                break;
            case 2:
                firstPosition = new Pos(20, 26);
                break;
        }
        // Create the fireball
        var magicBall = new DeveloperMagicBall(this.getQuest(), this.getGlobalPosition().plus(firstPosition), new Naming("A magic ball", "a magic ball"), new Color(colorType), new Pos(2, 1), damage, this.getAndPossiblyCreateSpellCastingDamageReason(new Naming("A magic ball", "a magic ball")), timeToLive);
        // No target
        magicBall.setTargetTypeTargetPosition(finalPosition, new Pos(1, 1));
        // Add the entity
        this.getQuest().addEntity(magicBall);
    };
    DeveloperEntity.prototype.createTexts = function () {
        // Empty the array
        this.texts = [];
        // At first we're working on the first text
        this.indexOfCurrentText = 0;
        // Add "Hello"
        this.texts.push(new DeveloperEntityText(20, new Pos(3, 3), 110, Database.getAscii("places/quests/developer/hello")));
        // Add "I'm glad you made it so far"
        this.texts.push(new DeveloperEntityText(32, new Pos(3, 3), 150, Database.getAscii("places/quests/developer/imgladyoumadeitsofar")));
        // Add "<3"
        this.texts.push(new DeveloperEntityText(9999999999999, new Pos(8, 10), 100, Database.getAscii("places/quests/developer/love")));
    };
    DeveloperEntity.prototype.playerUsedBlackMagic = function () {
        // We use a blackhole on the player
        this.getQuest().addEntity(new Blackhole(this.getQuest(), this.getQuest().getGame().getPlayer().getRenderAreaCenter(), 5000, new QuestEntityDamageReason(QuestEntityDamageReasonWhoType.ENTITY, QuestEntityDamageReasonWhatType.SPELL).setQuestEntity(this).setSpellNaming(new Naming("A blackhole", "a blackhole"))));
    };
    return DeveloperEntity;
})(QuestEntity);
var DeveloperEntityText = (function () {
    // Constructor
    function DeveloperEntityText(damage, textPos, timeToLive, text) {
        // Set from parameters
        this.damage = damage;
        this.text = text;
        this.textPos = textPos;
        this.timeToLive = timeToLive;
        // Set the default x position
        this.xPos = 0;
    }
    // Public methods
    DeveloperEntityText.prototype.update = function (dev) {
        // Iterate over strings
        for (var i = 0; i < this.text.length; i++) {
            // If there's a character at the current xPos of this string
            if (this.xPos < this.text[i].length && this.text[i][this.xPos] != " ") {
                // Add a magic ball, depending on the character
                switch (this.text[i][this.xPos]) {
                    case "B":
                        dev.addMagicBall(this.textPos.plus(new Pos(this.xPos, i)), this.damage, this.timeToLive - this.xPos, ColorType.DEVELOPER_BLUE);
                        break;
                    case "Y":
                        dev.addMagicBall(this.textPos.plus(new Pos(this.xPos, i)), this.damage, this.timeToLive - this.xPos, ColorType.DEVELOPER_YELLOW);
                        break;
                    case "O":
                        dev.addMagicBall(this.textPos.plus(new Pos(this.xPos, i)), this.damage, this.timeToLive - this.xPos, ColorType.DEVELOPER_ORANGE);
                        break;
                }
            }
        }
        // Increase xPos
        this.xPos += 1;
    };
    return DeveloperEntityText;
})();
///<reference path="QuestEntitySpell.ts"/>
var Fireball = (function (_super) {
    __extends(Fireball, _super);
    // Constructor
    function Fireball(quest, pos, naming, color, size, damage, questEntityDamageReason) {
        // Call the mother class constructor
        _super.call(this, quest, pos, naming);
        // Target stuff
        this.targetType = FireballTargetType.NO_TARGET;
        // Set the size
        this.size = size;
        // Set the damage
        this.damage = damage;
        // Set the quest entity damage reason
        this.questEntityDamageReason = questEntityDamageReason;
        // Create the damage collision box collection
        this.damageCollisionBoxCollection = new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 0), this.size));
        // Add the color
        this.addColor(new QuestEntitySpellColor(this.getQuest(), new Pos(0, 0), this.size, color));
        // Create a quest entity movement
        this.setQuestEntityMovement(new QuestEntityMovement(new Pos(0, 0)));
        // Set the default target type
        this.setTargetTypeNoTarget(new Pos(0, 0));
    }
    // Public methods
    Fireball.prototype.setTargetTypeNoTarget = function (movement) {
        this.targetType = FireballTargetType.NO_TARGET;
        this.getQuestEntityMovement().setOffset(movement); // Set the movement (it will be kept later by itself)
    };
    Fireball.prototype.setTargetTypeTargetEntity = function (entity, specialTargetDamage, speed) {
        if (specialTargetDamage === void 0) { specialTargetDamage = null; }
        if (speed === void 0) { speed = new Pos(1, 1); }
        this.targetType = FireballTargetType.TARGET_ENTITY;
        this.fireballTargetEntity = entity;
        this.specialTargetDamage = specialTargetDamage;
        this.speed = speed;
    };
    Fireball.prototype.setTargetTypeTargetPosition = function (pos, speed) {
        if (speed === void 0) { speed = new Pos(1, 1); }
        this.targetType = FireballTargetType.TARGET_POSITION;
        this.targetPosition = pos;
        this.speed = speed;
    };
    Fireball.prototype.setTargetTypeTargetStickOnEntity = function (entity, specialTargetPosition) {
        if (specialTargetPosition === void 0) { specialTargetPosition = new Pos(0, 0); }
        this.targetType = FireballTargetType.TARGET_STICK_ON_ENTITY;
        this.fireballTargetEntity = entity;
        this.specialTargetPosition = specialTargetPosition;
    };
    Fireball.prototype.update = function () {
        // If we target an entity
        if (this.targetType == FireballTargetType.TARGET_ENTITY) {
            // If this entity is still alive
            if (this.fireballTargetEntity != null && this.fireballTargetEntity.getDead() == false) {
                // We go towards it
                this.goTowards(this.getGlobalPosition().plus(new Pos(Math.floor(this.size.x / 2), Math.floor(this.size.y / 2))), this.fireballTargetEntity.getRenderAreaCenter(), 0, this.speed);
            }
            else
                this.setDead(true);
        }
        else if (this.targetType == FireballTargetType.TARGET_STICK_ON_ENTITY) {
            // If this entity is still alive
            if (this.fireballTargetEntity != null && this.fireballTargetEntity.getDead() == false) {
                // We teleport on it
                this.teleport(this.fireballTargetEntity.getGlobalPosition().plus(this.specialTargetPosition));
            }
            else
                this.setDead(true);
        }
        else if (this.targetType == FireballTargetType.TARGET_POSITION) {
            // We go towards this position
            this.goTowards(this.getGlobalPosition().plus(new Pos(Math.floor(this.size.x / 2), Math.floor(this.size.y / 2))), this.targetPosition, 0, this.speed);
        }
        // Handle our damage
        this.handleDamage();
        // Call the mother class update method
        _super.prototype.update.call(this);
    };
    // willDie()
    Fireball.prototype.willDie = function () { };
    // Private methods
    Fireball.prototype.handleDamage = function () {
        // We iterate over entities
        for (var i = 0; i < this.getQuest().getEntities().length; i++) {
            // If it is from a different team than the team of the entity which launched the fireball
            if (this.questEntityDamageReason.getQuestEntityTeam() != this.getQuest().getEntities()[i].getTeam()) {
                // If it is destructible
                if (this.getQuest().getEntities()[i].getDestructible()) {
                    // If it has a collision box collection
                    if (this.getQuest().getEntities()[i].getCbc() != null) {
                        // If this collision box collection collides with ours
                        if (this.getQuest().getEntities()[i].getCbc().collidesWith(this.damageCollisionBoxCollection)) {
                            // If...
                            if (this.getQuest().getEntities()[i] == this.fireballTargetEntity &&
                                this.targetType == FireballTargetType.TARGET_ENTITY &&
                                this.fireballTargetEntity != null &&
                                this.fireballTargetEntity.getDead() == false &&
                                this.specialTargetDamage != null // And we want to inflict it special damage
                            ) {
                                this.getQuest().getEntities()[i].inflictDamage(this.specialTargetDamage, this.questEntityDamageReason);
                            }
                            else {
                                this.getQuest().getEntities()[i].inflictDamage(this.damage, this.questEntityDamageReason);
                            }
                            // We die because we inflicted damage
                            this.setDead(true);
                        }
                    }
                }
            }
        }
    };
    return Fireball;
})(QuestEntitySpell);
///<reference path="Fireball.ts"/>
var DeveloperMagicBall = (function (_super) {
    __extends(DeveloperMagicBall, _super);
    // Constructor
    function DeveloperMagicBall(quest, pos, naming, color, size, damage, questEntityDamageReason, timeToLive) {
        // Call the mother class constructor
        _super.call(this, quest, pos, naming, color, size, damage, questEntityDamageReason);
        // Did we target the player already?
        this.playerTargeted = false;
        // Set the time to live
        this.timeToLive = timeToLive;
    }
    // Public methods
    DeveloperMagicBall.prototype.update = function () {
        // If the player isn't targeted yet
        if (this.playerTargeted == false) {
            // If it's time to target the player
            if (this.timeToLive <= 0) {
                // We target it
                this.setTargetTypeTargetEntity(this.getQuest().getGame().getPlayer(), null, new Pos(2, 1));
            }
            else
                this.timeToLive -= 1;
        }
        // Call the mother class update method
        _super.prototype.update.call(this);
    };
    // willDie()
    DeveloperMagicBall.prototype.willDie = function () { };
    return DeveloperMagicBall;
})(Fireball);
///<reference path="QuestEntity.ts"/>
var Devil = (function (_super) {
    __extends(Devil, _super);
    // Constructor
    function Devil(quest, pos, minY, maxY) {
        _super.call(this, quest, pos, new Naming("The devil", "the devil"), new RenderArea(16, 16), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(4, 0), new Pos(8, 5))), new QuestEntityMovement());
        // Set from parameters
        this.minY = minY;
        this.maxY = maxY;
        // At first we're going down
        this.setGoingDown(true);
        // Init the flames array
        this.flames = [];
        // Set gravity
        this.getQuestEntityMovement().setGravity(false);
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(666);
        this.setHp(666);
        // Set the transparent character and draw
        this.setTransparency(new RenderTransparency(" ", "%"));
        this.reDraw();
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("Evilness", "evilness"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(18, 18))), 500));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setBetweenDelay(0, 5);
    }
    // inflictDamage()
    Devil.prototype.inflictDamage = function (damage, reason) {
        _super.prototype.inflictDamage.call(this, Math.ceil(damage / 4), reason);
    };
    // update()
    Devil.prototype.update = function () {
        // Handle movement
        this.handleUpDownMovement();
        // Handle fireballs
        this.handleFireballs();
        // Handle the flames
        this.handleFlames();
        // Re draw the devil (ascii art + flames)
        this.reDraw();
        // Call the mother class update method
        _super.prototype.update.call(this);
    };
    // willDie()
    Devil.prototype.willDie = function () {
        this.getQuest().getGame().getQuestLog().addMessage(new QuestLogMessage(this.getDeathMessage() + " (and found " + Algo.pluralFormat(this.getQuest().foundCandies(1000000), " candy", " candies") + ")", this.getQuest().getCandiesFoundMessage()));
        this.getQuest().foundGridOrEqItem(new QuestItemFound(this.getQuest(), "gridItemPossessedA", "You found a strange stone.", "You gain a strange stone."));
    };
    // Private methods
    Devil.prototype.castFireball = function () {
        // Create the fireball
        var fireBall = new Fireball(this.getQuest(), this.getGlobalPosition().plus(new Pos(3, 4)), new Naming("The devil's fireball", "the devil's fireball"), new Color(ColorType.DEVIL_FIREBALL), new Pos(2, 1), 800, this.getAndPossiblyCreateSpellCastingDamageReason(new Naming("The devil's fireball", "the devil's fireball")));
        // If the player is on our left
        if (this.getQuest().getGame().getPlayer().getGlobalPosition().x < this.getGlobalPosition().x) {
            // No target
            fireBall.setTargetTypeNoTarget(new Pos(-Random.between(3, 7), 0));
        }
        else {
            // We target the player
            fireBall.setTargetTypeTargetEntity(this.getQuest().getGame().getPlayer(), null, new Pos(1, 1));
        }
        // Add the entity
        this.getQuest().addEntity(fireBall);
    };
    Devil.prototype.handleFireballs = function () {
        if (Random.oneChanceOutOf(2))
            this.castFireball();
    };
    Devil.prototype.handleFlames = function () {
        // Create the variables
        var minX = 0;
        var maxX = 15;
        var minY = 6;
        var maxY = 15;
        var howManyFlames = 150;
        var x;
        var y;
        // Add flames depending on the current timer time
        for (var i = 0; i < howManyFlames; i++) {
            // If there is no flame for this index OR one chance out of 7
            if (i >= this.flames.length || Random.oneChanceOutOf(7)) {
                // Set y
                y = null;
                for (var j = minY; j < maxY; j++) {
                    if (Random.oneChanceOutOf(3)) {
                        y = j;
                        break;
                    }
                }
                if (y == null)
                    y = maxY;
                // Set x
                x = Random.between(minX + Math.floor((15 - y) / 3), maxX - Math.floor((15 - y) / 3));
                // Add or replace the flame
                var flame = new CauldronFlame(new Pos(x, y), Random.fromArray([")", "(", "`", "'", ".", ";", ":", ",", "-", "/", "\\", "|", "\"", "d", "e", "v", "i", "l"]));
                if (i >= this.flames.length)
                    this.flames.push(flame);
                else
                    this.flames[i] = flame;
            }
        }
    };
    Devil.prototype.handleUpDownMovement = function () {
        // If we're going down but we're too low or it will be impossible, we now go up
        if (this.goingDown && (this.getGlobalPosition().y >= this.maxY || this.checkCollision(new Pos(0, 1)))) {
            this.setGoingDown(false);
        }
        else if (this.goingDown == false && (this.getGlobalPosition().y <= this.minY || this.checkCollision(new Pos(0, -1)))) {
            this.setGoingDown(true);
        }
    };
    Devil.prototype.reDraw = function () {
        // Reset everything
        this.getRenderArea().resetAllButSize();
        // Draw the ascii art
        this.getRenderArea().drawArray(Database.getAscii("places/quests/hell/devil"), 4, 0);
        // Draw the flames
        for (var i = 0; i < this.flames.length; i++) {
            this.flames[i].draw(this.getRenderArea(), 0, 0);
        }
    };
    Devil.prototype.setGoingDown = function (goingDown) {
        this.goingDown = goingDown;
        if (this.goingDown) {
            this.getQuestEntityMovement().setOffset(new Pos(0, 1));
        }
        else {
            this.getQuestEntityMovement().setOffset(new Pos(0, -1));
        }
    };
    return Devil;
})(QuestEntity);
///<reference path="CastleRoom.ts"/>
Saving.registerBool("dragonDone", false); // If true, it means we began talking to the dragon
Saving.registerBool("dragonUnlockedCyclops", false); // If true, we can ask the cyclops about the dragon
var Dragon = (function (_super) {
    __extends(Dragon, _super);
    // Constructor
    function Dragon(game) {
        _super.call(this, game);
        // The render area
        this.renderArea = new RenderArea();
        // Set the default step and player position
        if (Saving.loadBool("dragonDone") == false) {
            this.step = DragonStep.PLAYER_MOVING;
            this.playerPos = 0;
        }
        else {
            this.step = DragonStep.TALKING;
            this.playerPos = 60;
        }
        // Launch the interval and get the ID
        this.timerIntervalID = setInterval(this.actionInterval.bind(this), 100);
        // Resize and update
        this.renderArea.resizeFromArray(Database.getAscii("places/dragonFoot"), 0, 3);
        this.update();
    }
    // getRenderArea()
    Dragon.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // willStopBeingDisplayed()
    Dragon.prototype.willStopBeingDisplayed = function () {
        clearInterval(this.timerIntervalID);
    };
    // Private methods
    Dragon.prototype.actionInterval = function () {
        // Do something different depending on the step
        switch (this.step) {
            case DragonStep.PLAYER_MOVING:
                // Move the player
                this.playerPos += 1;
                if (this.playerPos >= 60) {
                    // We're now attacking
                    this.step = DragonStep.PLAYER_ATTACKING;
                    // Set the countdown
                    this.playerAttackingCountdown = 40;
                }
                // Update
                this.update();
                this.getGame().updatePlace();
                break;
            case DragonStep.PLAYER_ATTACKING:
                // Lower the countdown
                this.playerAttackingCountdown -= 1;
                if (this.playerAttackingCountdown < 0) {
                    // We're now "stop tickling"
                    this.step = DragonStep.STOP_TICKLING;
                }
                // Update
                this.update();
                this.getGame().updatePlace();
                break;
        }
    };
    Dragon.prototype.chooseCandies = function () {
        // Change the step
        this.step = DragonStep.TALKING_CANDIES;
        // Set the bool
        Saving.saveBool("dragonUnlockedCyclops", true);
        // Update
        this.update();
        this.getGame().updatePlace();
    };
    Dragon.prototype.chooseChallenge = function () {
        // Change the step
        this.step = DragonStep.TALKING_CHALLENGE;
        // Update
        this.update();
        this.getGame().updatePlace();
    };
    Dragon.prototype.chooseFame = function () {
        // Change the step
        this.step = DragonStep.TALKING_FAME;
        // Update
        this.update();
        this.getGame().updatePlace();
    };
    Dragon.prototype.drawPlayer = function (x, y) {
        if (y === void 0) { y = 26; }
        this.renderArea.drawString("\\o/", x, y);
    };
    Dragon.prototype.goToDeveloper = function () {
        this.getGame().setPlace(new Developer(this.getGame()));
    };
    Dragon.prototype.goToHell = function () {
        this.getGame().setPlace(new Hell(this.getGame()));
    };
    Dragon.prototype.okayStopTickling = function () {
        if (this.step == DragonStep.STOP_TICKLING) {
            // Change the step
            this.step = DragonStep.TALKING;
            // Set the bool
            Saving.saveBool("dragonDone", true);
            // Update
            this.update();
            this.getGame().updatePlace();
        }
    };
    Dragon.prototype.update = function () {
        // Erase everything
        this.renderArea.resetAllButSize();
        // Back to the map button
        this.addBackToTheCastleButton(this.renderArea, "dragonBackToTheCastleButton");
        // Draw the ascii
        this.renderArea.drawArray(Database.getAscii("places/dragonFoot"), 0, 3);
        // Draw something different depending on the step
        switch (this.step) {
            case DragonStep.PLAYER_MOVING:
                // Draw the player (eventually going down the stairs at the beginning)
                this.drawPlayer(this.playerPos, 20 + (this.playerPos < 21 ? (Math.floor(this.playerPos / 3)) : 6));
                break;
            case DragonStep.PLAYER_ATTACKING:
                // Draw the player
                this.drawPlayer(this.playerPos);
                // Draw the dragon fake health bar
                this.renderArea.drawString("|             A dragon foot : so much hp/so much hp             |", 45, 11);
                this.renderArea.addBackgroundColor(46, 109, 11, new Color(ColorType.HEALTH_GREEN));
                break;
            case DragonStep.STOP_TICKLING:
                // Draw the player
                this.drawPlayer(this.playerPos);
                // Draw the speech
                this.renderArea.drawSpeech(Database.getText("dragonStopTickling"), 5, 50, 78, "dragonStopTicklingSpeech", Database.getTranslatedText("dragonStopTickling"));
                // Add the button
                this.renderArea.addAsciiRealButton(Database.getText("dragonStopTicklingButton"), 50, 9, "dragonStopTicklingButton", Database.getTranslatedText("dragonStopTicklingButton"), true);
                this.renderArea.addLinkCall(".dragonStopTicklingButton", new CallbackCollection(this.okayStopTickling.bind(this)));
                break;
            case DragonStep.TALKING:
                // Draw the player
                this.drawPlayer(this.playerPos);
                // Draw the speech
                this.renderArea.drawSpeech(Database.getText("dragonTalking"), 5, 50, 78, "dragonTalkingSpeech", Database.getTranslatedText("dragonTalking"));
                // Add the challenge button
                this.renderArea.addAsciiRealButton(Database.getText("dragonTalkingChallengeButton"), 82, 5, "dragonTalkingChallengeButton", Database.getTranslatedText("dragonTalkingChallengeButton"));
                this.renderArea.addLinkCall(".dragonTalkingChallengeButton", new CallbackCollection(this.chooseChallenge.bind(this)));
                // Add the fame button
                this.renderArea.addAsciiRealButton(Database.getText("dragonTalkingFameButton"), 82, 7, "dragonTalkingFameButton", Database.getTranslatedText("dragonTalkingFameButton"));
                this.renderArea.addLinkCall(".dragonTalkingFameButton", new CallbackCollection(this.chooseFame.bind(this)));
                // Add the candies button
                this.renderArea.addAsciiRealButton(Database.getText("dragonTalkingCandiesButton"), 82, 9, "dragonTalkingCandiesButton", Database.getTranslatedText("dragonTalkingCandiesButton"));
                this.renderArea.addLinkCall(".dragonTalkingCandiesButton", new CallbackCollection(this.chooseCandies.bind(this)));
                break;
            case DragonStep.TALKING_CHALLENGE:
                // Draw the player
                this.drawPlayer(this.playerPos);
                // Draw the speech
                this.renderArea.drawSpeech(Database.getText("dragonTalkingChallengeSpeech"), 5, 50, 78, "dragonTalkingChallengeSpeech", Database.getTranslatedText("dragonTalkingChallengeSpeech"));
                // Add the button
                this.renderArea.addAsciiRealButton(Database.getText("dragonTalkingChallengeAnswer"), 82, 5, "dragonTalkingChallengeAnswer", Database.getTranslatedText("dragonTalkingChallengeAnswer"));
                this.renderArea.addLinkCall(".dragonTalkingChallengeAnswer", new CallbackCollection(this.goToHell.bind(this)));
                break;
            case DragonStep.TALKING_FAME:
                // Draw the player
                this.drawPlayer(this.playerPos);
                // Draw the speech
                this.renderArea.drawSpeech(Database.getText("dragonTalkingFameSpeech"), 5, 50, 78, "dragonTalkingFameSpeech", Database.getTranslatedText("dragonTalkingFameSpeech"));
                // Add the button
                this.renderArea.addAsciiRealButton(Database.getText("dragonTalkingFameAnswer"), 82, 7, "dragonTalkingFameAnswer", Database.getTranslatedText("dragonTalkingFameAnswer"));
                this.renderArea.addLinkCall(".dragonTalkingFameAnswer", new CallbackCollection(this.goToDeveloper.bind(this)));
                break;
            case DragonStep.TALKING_CANDIES:
                // Draw the player
                this.drawPlayer(this.playerPos);
                // Draw the speech
                this.renderArea.drawSpeech(Database.getText("dragonTalkingCandiesSpeech"), 5, 50, 78, "dragonTalkingCandiesSpeech", Database.getTranslatedText("dragonTalkingCandiesSpeech"));
                // Add the button
                this.renderArea.addAsciiRealButton(Database.getText("dragonTalkingCandiesAnswer"), 82, 9, "dragonTalkingCandiesAnswer", Database.getTranslatedText("dragonTalkingCandiesAnswer"));
                this.renderArea.addLinkCall(".dragonTalkingCandiesAnswer", new CallbackCollection(this.getGame().goToCastle.bind(this.getGame())));
                break;
        }
    };
    return Dragon;
})(CastleRoom);
var DragonStep;
(function (DragonStep) {
    DragonStep[DragonStep["PLAYER_MOVING"] = 0] = "PLAYER_MOVING";
    DragonStep[DragonStep["PLAYER_ATTACKING"] = 1] = "PLAYER_ATTACKING";
    DragonStep[DragonStep["STOP_TICKLING"] = 2] = "STOP_TICKLING";
    DragonStep[DragonStep["TALKING"] = 3] = "TALKING";
    DragonStep[DragonStep["TALKING_CHALLENGE"] = 4] = "TALKING_CHALLENGE";
    DragonStep[DragonStep["TALKING_FAME"] = 5] = "TALKING_FAME";
    DragonStep[DragonStep["TALKING_CANDIES"] = 6] = "TALKING_CANDIES";
})(DragonStep || (DragonStep = {}));
///<reference path="QuestEntity.ts"/>
var Egg = (function (_super) {
    __extends(Egg, _super);
    // Constructor
    function Egg(quest, globalPosition, callbackWhenDying) {
        // Call the mother constructor
        _super.call(this, quest, globalPosition, new Naming("An egg", "an egg"), new RenderArea(2, 1), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 0), new Pos(2, 1))), new QuestEntityMovement());
        // Set the callback from parameter
        this.callbackWhenDying = callbackWhenDying;
        // Set gravity
        this.getQuestEntityMovement().setGravity(true);
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(4);
        this.setHp(4);
        // Set the ascii art
        this.getRenderArea().drawArray(Database.getAscii("places/quests/castle/room3/egg"));
    }
    // willDie()
    Egg.prototype.willDie = function () {
        this.getQuest().getGame().getQuestLog().addMessage(new QuestLogMessage("An egg was destroyed."));
        this.callbackWhenDying.fire();
    };
    return Egg;
})(QuestEntity);
///<reference path="EqItem.ts"/>
var EnchantedKnightBodyArmour = (function (_super) {
    __extends(EnchantedKnightBodyArmour, _super);
    // Constructor
    function EnchantedKnightBodyArmour() {
        _super.call(this, "eqItemBodyArmoursEnchantedKnightBodyArmour", "eqItemBodyArmoursEnchantedKnightBodyArmourName", "eqItemBodyArmoursEnchantedKnightBodyArmourDescription", "eqItems/bodyArmours/enchantedKnightBodyArmour");
    }
    // Special ability
    EnchantedKnightBodyArmour.prototype.getSpecialAbility = function () {
        return "Dam. taken reduced by 80%, dam. inflicted divided by 2 (enchanted knight body armour)";
    };
    // hit()
    EnchantedKnightBodyArmour.prototype.hit = function (player, quest, questEntity, damage, reason) {
        return Math.ceil(damage / 2);
    };
    // inflictDamage()
    EnchantedKnightBodyArmour.prototype.inflictDamage = function (player, quest, damage, reason) {
        return Math.ceil(damage - damage * 80 / 100);
    };
    return EnchantedKnightBodyArmour;
})(EqItem);
///<reference path="EqItem.ts"/>
var MonkeyWizardStaffMotherClass = (function (_super) {
    __extends(MonkeyWizardStaffMotherClass, _super);
    function MonkeyWizardStaffMotherClass() {
        _super.apply(this, arguments);
    }
    // Public methods which the daughter classes can use
    MonkeyWizardStaffMotherClass.prototype.castPurpleBall = function (player, quest, target, speed) {
        if (speed === void 0) { speed = new Pos(2, 1); }
        var ball = new Fireball(quest, player.getSpellCastingPosition(), new Naming("An magical purple ball", "a magical purple ball"), new Color(ColorType.MONKEY_WIZARD_BALL), new Pos(2, 1), 15, player.getAndPossiblyCreateSpellCastingDamageReason(new Naming("An magical purple ball", "a magical purple ball")));
        // Set the target
        ball.setTargetTypeTargetEntity(target, null, speed);
        // Add it to the quest
        quest.addEntity(ball);
    };
    MonkeyWizardStaffMotherClass.prototype.getRandomEnemy = function (player, quest) {
        // Array which will contain the indices (in the entities array) of all possible enemies
        var indices = [];
        // Fill the indices array
        for (var i = 0; i < quest.getEntities().length; i++) {
            // If this entity is destructible and is from a different team then the player
            if (quest.getEntities()[i].getDestructible() && quest.getEntities()[i].getTeam() != player.getTeam()) {
                // We add its index
                indices.push(i);
            }
        }
        // We return a random entity from the indices index
        if (indices.length > 0)
            return quest.getEntities()[indices[Random.between(0, indices.length - 1)]];
        else
            return null;
    };
    return MonkeyWizardStaffMotherClass;
})(EqItem);
///<reference path="MonkeyWizardStaffMotherClass.ts"/>
var EnchantedMonkeyWizardStaff = (function (_super) {
    __extends(EnchantedMonkeyWizardStaff, _super);
    // Constructor
    function EnchantedMonkeyWizardStaff() {
        _super.call(this, "eqItemWeaponEnchantedMonkeyWizardStaff", "eqItemWeaponEnchantedMonkeyWizardStaffName", "eqItemWeaponEnchantedMonkeyWizardStaffDescription", "eqItems/weapons/enchantedMonkeyWizardStaff");
        // Set the timer
        this.timer = 0;
    }
    // Public getters
    EnchantedMonkeyWizardStaff.prototype.getQuestEntityWeapon = function (quest, player) {
        var qew = new QuestEntityWeapon(quest, player, new Naming("The monkey wizard staff (enchanted)", "the monkey wizard staff (enchanted)"), player.getClassicCollisionBoxCollection(), 2);
        qew.getCloseCombatDelay().setFixedDelay(0);
        return qew;
    };
    // update()
    EnchantedMonkeyWizardStaff.prototype.update = function (player, quest) {
        // Handle the timer
        if (this.timer < 4)
            this.timer += 1;
        else {
            this.timer = 0;
            var ent = this.getRandomEnemy(player, quest);
            if (ent != null)
                this.castPurpleBall(player, quest, ent);
        }
    };
    return EnchantedMonkeyWizardStaff;
})(MonkeyWizardStaffMotherClass);
var Enchantment = (function () {
    // Constructor
    function Enchantment(beforeItem, afterItem) {
        this.beforeItem = beforeItem;
        this.afterItem = afterItem;
    }
    // Public methods
    Enchantment.prototype.enchant = function () {
        // We check if we're currently wearing the before item. If so, we must stop wearing it !
        this.beforeItem.unequipIfEquipped();
        // We lose the before item and gain the after item
        Saving.saveBool(this.beforeItem.getSavingName(), false);
        Saving.saveBool(this.afterItem.getSavingName(), true);
    };
    Enchantment.prototype.isPossible = function () {
        // If we have the before item but not the after item, we return true
        if (this.beforeItem.isPossessed() == true && this.afterItem.isPossessed() == false)
            return true;
        // Else we return false
        return false;
    };
    // Public getters
    Enchantment.prototype.getAfterItem = function () {
        return this.afterItem;
    };
    Enchantment.prototype.getBeforeItem = function () {
        return this.beforeItem;
    };
    return Enchantment;
})();
var EnchantmentItem = (function () {
    // Constructor
    function EnchantmentItem(game, savingName, type) {
        this.game = game;
        this.savingName = savingName;
        this.type = type;
    }
    // Public methods
    EnchantmentItem.prototype.getText = function () {
        var text = Database.getText(this.game.getEqItemFromEqItemType(this.savingName, this.type).getDatabaseName());
        if (Database.isTranslated())
            text += " (" + Database.getTranslatedText(this.game.getEqItemFromEqItemType(this.savingName, this.type).getDatabaseName()) + ")";
        return text;
    };
    EnchantmentItem.prototype.isPossessed = function () {
        return Saving.loadBool(this.savingName);
    };
    EnchantmentItem.prototype.unequipIfEquipped = function () {
        this.game.unequipIfEquipped(this.savingName, this.type);
    };
    // Public getters
    EnchantmentItem.prototype.getSavingName = function () {
        return this.savingName;
    };
    return EnchantmentItem;
})();
// We can't use this class directly, we have to use a daughter class
var EnigmaAnswer = (function () {
    // Constructor
    function EnigmaAnswer() {
    }
    // Public methods
    EnigmaAnswer.prototype.isRight = function (answer) {
        return false;
    };
    return EnigmaAnswer;
})();
///<reference path="EnigmaAnswer.ts"/>
var EnigmaAnswerCandies = (function (_super) {
    __extends(EnigmaAnswerCandies, _super);
    // Constructor
    function EnigmaAnswerCandies(game) {
        _super.call(this);
        this.game = game;
    }
    // Public methods
    EnigmaAnswerCandies.prototype.isRight = function (answer) {
        // If the answer is the current number of candies we possess
        if (Algo.simplifyString(answer) == this.game.getCandies().getCurrent().toString() ||
            Algo.simplifyString(answer) == (this.game.getCandies().getCurrent() + 1).toString() ||
            Algo.simplifyString(answer) == (this.game.getCandies().getCurrent() + 2).toString() ||
            Algo.simplifyString(answer) == (this.game.getCandies().getCurrent() + 3).toString() ||
            Algo.simplifyString(answer) == (this.game.getCandies().getCurrent() - 1).toString() ||
            Algo.simplifyString(answer) == (this.game.getCandies().getCurrent() - 2).toString() ||
            Algo.simplifyString(answer) == (this.game.getCandies().getCurrent() - 3).toString())
            return true;
        // The answer isn't correct
        return false;
    };
    return EnigmaAnswerCandies;
})(EnigmaAnswer);
///<reference path="EnigmaAnswer.ts"/>
var EnigmaAnswerStrings = (function (_super) {
    __extends(EnigmaAnswerStrings, _super);
    // Constructor
    function EnigmaAnswerStrings(validStrings) {
        _super.call(this);
        this.validStrings = validStrings;
    }
    // Public methods
    EnigmaAnswerStrings.prototype.isRight = function (answer) {
        for (var i = 0; i < this.validStrings.length; i++) {
            if (Algo.simplifyString(answer) == this.validStrings[i]) {
                // The answer is correct
                return true;
            }
        }
        // The answer isn't correct
        return false;
    };
    return EnigmaAnswerStrings;
})(EnigmaAnswer);
var EqItemType;
(function (EqItemType) {
    EqItemType[EqItemType["WEAPON"] = 0] = "WEAPON";
    EqItemType[EqItemType["HAT"] = 1] = "HAT";
    EqItemType[EqItemType["BODYARMOUR"] = 2] = "BODYARMOUR";
    EqItemType[EqItemType["GLOVES"] = 3] = "GLOVES";
    EqItemType[EqItemType["BOOTS"] = 4] = "BOOTS";
})(EqItemType || (EqItemType = {}));
///<reference path="Item.ts"/>
var GridItem = (function (_super) {
    __extends(GridItem, _super);
    // Constructor
    function GridItem(savingName, databaseName, databaseDescriptionName, ascii, position) {
        _super.call(this, savingName, databaseName, databaseDescriptionName, ascii);
        this.position = position;
    }
    // Public methods
    GridItem.prototype.update = function (player, quest) {
    };
    // Public getters
    GridItem.prototype.getPosition = function () {
        return this.position;
    };
    return GridItem;
})(Item);
///<reference path="GridItem.ts"/>
var Feather = (function (_super) {
    __extends(Feather, _super);
    function Feather() {
        _super.apply(this, arguments);
    }
    Feather.prototype.getDatabaseDescriptionName = function () {
        // If we don't have the pogo stick yet, we return a special message
        if (Saving.loadBool("gridItemPossessedPogoStick") == false)
            return "gridItemFeatherDescriptionNoPogoStick";
        // Else we return the normal description name
        return _super.prototype.getDatabaseDescriptionName.call(this);
    };
    return Feather;
})(GridItem);
///<reference path="Place.ts"/>
var House = (function (_super) {
    __extends(House, _super);
    // Constructor
    function House(game) {
        _super.call(this, game);
    }
    // Special method used to add a button to go back to the village
    House.prototype.addBackToTheVillageButton = function (renderArea, otherClass) {
        this.addBackToButton(renderArea, new CallbackCollection(this.getGame().goToVillage.bind(this.getGame())), Database.getText("buttonBackToTheVillage"), Database.getTranslatedText("buttonBackToTheVillage"), otherClass);
    };
    return House;
})(Place);
///<reference path="House.ts"/>
var FifthHouse = (function (_super) {
    __extends(FifthHouse, _super);
    // Constructor
    function FifthHouse(game) {
        _super.call(this, game);
        this.renderArea = new RenderArea();
        this.renderArea.resizeFromArray(Database.getAscii("places/village/fifthHouse"), 0, 3);
        this.update();
    }
    // getRenderArea()
    FifthHouse.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // Public methods
    FifthHouse.prototype.willBeDisplayed = function () {
        // We need to update each time we're going to be displayed to avoid a "bug" in a very special case :
        // If the player is in the fifth house and the npc is asking for someone with a weapon
        // And then the player goes to its inventory, equip a weapon and then goes back to the fifth house
        // Here the fifth house must be updated so that the npc know that the player now has a weapon
        this.update();
    };
    // Private methods
    FifthHouse.prototype.beginQuest = function () {
        this.getGame().setPlace(new Cellar(this.getGame()));
    };
    FifthHouse.prototype.update = function () {
        // Erase everything
        this.renderArea.resetAllButSize();
        // Back to the village button
        this.addBackToTheVillageButton(this.renderArea, "fifthHouseBackToTheVillageButton");
        // Draw the house
        this.renderArea.drawArray(Database.getAscii("places/village/fifthHouse"), 0, 3);
        // If we haven't defeated the rats yet
        if (Saving.loadBool("cellarDone") == false) {
            // If we have a weapon
            if (this.getGame().getSelectedEqItems()["weapon"] != null) {
                // Draw the speech
                this.renderArea.drawSpeech(Database.getText("mapVillageFifthHouseWeaponSpeech"), 6, 44, 67, "fifthHouseSpeech", Database.getTranslatedText("mapVillageFifthHouseWeaponSpeech"));
                // Add the button
                this.renderArea.addAsciiRealButton(Database.getText("mapVillageFifthHouseAgree"), 69, 8, "mapVillageFifthHouseAgreeButton", Database.getTranslatedText("mapVillageFifthHouseAgree"), true);
                this.renderArea.addLinkCall(".mapVillageFifthHouseAgreeButton", new CallbackCollection(this.beginQuest.bind(this)));
            }
            else {
                // Draw the speech
                this.renderArea.drawSpeech(Database.getText("mapVillageFifthHouseNoWeaponSpeech"), 6, 44, 67, "fifthHouseSpeech", Database.getTranslatedText("mapVillageFifthHouseNoWeaponSpeech"));
            }
        }
        else {
            // Draw the speech
            this.renderArea.drawSpeech(Database.getText("mapVillageFifthHouseCellarDone"), 6, 44, 82, "fifthHouseSpeech", Database.getTranslatedText("mapVillageFifthHouseCellarDone"));
            // Change the NPC mouth
            this.renderArea.drawString("U", 52, 17);
        }
    };
    return FifthHouse;
})(House);
var FireballTargetType;
(function (FireballTargetType) {
    FireballTargetType[FireballTargetType["NO_TARGET"] = 0] = "NO_TARGET";
    FireballTargetType[FireballTargetType["TARGET_ENTITY"] = 1] = "TARGET_ENTITY";
    FireballTargetType[FireballTargetType["TARGET_STICK_ON_ENTITY"] = 2] = "TARGET_STICK_ON_ENTITY";
    FireballTargetType[FireballTargetType["TARGET_POSITION"] = 3] = "TARGET_POSITION";
})(FireballTargetType || (FireballTargetType = {}));
///<reference path="Quest.ts"/>
var Forest = (function (_super) {
    __extends(Forest, _super);
    // Constructor
    function Forest(game) {
        _super.call(this, game);
        // Various timers related to monsters handling
        this.timeSinceLastWolfAdding = 0;
        this.timeSinceLastTreeSpiritAdding = 40;
        // The ground y position
        this.groundYPosition = 20;
        // The mosquito timer (mosquitos will come when the timer reaches 0)
        this.mosquitoTimer = 250;
        // Resize the quest
        this.resizeQuest(294, this.groundYPosition + 2);
        // Add collision boxes around
        this.addPlayerCollisionBoxes(true, false, true, true);
        // Add the player
        this.getGame().getPlayer().loadCandyBoxCharacter(this);
        this.getGame().getPlayer().setGlobalPosition(new Pos(0, this.groundYPosition));
        this.configPlayerOrClone(this.getGame().getPlayer());
        this.addEntity(this.getGame().getPlayer());
        // Add the ground
        this.addGround();
        // We add some wolves
        for (var i = 0; i < 10; i++) {
            this.addWolf(Random.between(80, 280));
        }
        // Add the message
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You enter the forest."));
    }
    // Public methods
    Forest.prototype.castPlayerTeleport = function () {
        _super.prototype.castPlayerTeleport.call(this, new Pos(0, this.groundYPosition), new Pos(10, 1));
    };
    Forest.prototype.configPlayerOrClone = function (entity) {
        entity.setQuestEntityMovement(new QuestEntityMovement(new Pos(1, 0)));
        entity.getQuestEntityMovement().setGravity(true);
        entity.getQuestEntityMovement().setWormsLike(false);
    };
    Forest.prototype.endQuest = function (win) {
        // We add some messages
        if (win) {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You made your way through the forest!"));
            Saving.saveBool("mainMapDoneForest", true); // The desert is done
        }
        else {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You died in the forest. The tree's leaves should soon be covering your body."));
        }
        // We call the endQuest method of our mother class
        _super.prototype.endQuest.call(this, win);
    };
    Forest.prototype.update = function () {
        if (this.getQuestEnded() == false) {
            // Test if the player won the quest, if so, end the quest and return
            if (this.thePlayerWon()) {
                this.endQuest(true);
                return;
            }
            // Test if the player is dead, if so, end the quest and return
            if (this.getGame().getPlayer().shouldDie()) {
                this.endQuest(false);
                return;
            }
            // Monsters handling
            this.monstersHandling();
            // Update entities
            this.updateEntities();
        }
        // Draw
        this.preDraw();
        this.getRenderArea().drawArray(Database.getAscii("places/quests/forest/background"), this.getRealQuestPosition().x, this.getRealQuestPosition().y);
        this.getRenderArea().drawArray(Database.getAscii("places/quests/forest/background"), this.getRealQuestPosition().x + 98, this.getRealQuestPosition().y);
        this.getRenderArea().drawArray(Database.getAscii("places/quests/forest/background"), this.getRealQuestPosition().x + 98 * 2, this.getRealQuestPosition().y);
        this.drawEntities();
        this.drawAroundQuest();
        if (this.getQuestEnded() == false)
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestNoKeeping");
        else if (this.getQuestEndedAndWeWon() == false)
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestNoKeepingBecauseLose");
        else
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestKeeping");
        this.postDraw();
    };
    // Private methods
    Forest.prototype.addGround = function () {
        var ground = new Wall(this, new Pos(0, 0));
        ground.addBox(new Pos(0, this.groundYPosition + 1), new Pos(350, 1));
        this.addEntity(ground);
    };
    Forest.prototype.addMosquito = function () {
        return this.addEntity(new Mosquito(this, new Pos(0, this.groundYPosition - Random.between(3, 7)), this.groundYPosition));
    };
    Forest.prototype.addTreeSpirit = function (xPosition) {
        if (xPosition === void 0) { xPosition = 294; }
        var treeSpirit = new TreeSpirit(this, new Pos(xPosition, this.groundYPosition - 4), this.groundYPosition);
        treeSpirit.setHealthBar(new QuestEntityHealthBar(treeSpirit, new Pos(5, 1)));
        return this.addEntity(treeSpirit);
    };
    Forest.prototype.addWolf = function (xPosition) {
        if (xPosition === void 0) { xPosition = 294; }
        var wolf = new Wolf(this, new Pos(xPosition, this.groundYPosition - 2));
        wolf.setHealthBar(new QuestEntityHealthBar(wolf, new Pos(7, 1)));
        return this.addEntity(wolf);
    };
    Forest.prototype.monstersHandling = function () {
        // If it's time to add a tree spirit
        if (this.timeSinceLastTreeSpiritAdding > 70 && Random.flipACoin()) {
            this.addTreeSpirit(); // We add it
            this.timeSinceLastTreeSpiritAdding = 0; // We reset the timer
        }
        else
            this.timeSinceLastTreeSpiritAdding += 1; // We increase the timer
        // If it's time to add a wolf
        if (this.timeSinceLastWolfAdding > 30 && Random.oneChanceOutOf(5)) {
            this.addWolf(); // We add it
            this.timeSinceLastWolfAdding = 0; // We reset the timer
        }
        else
            this.timeSinceLastWolfAdding += 1; // We increase the timer
        // If it's time to add a mosquito
        if (this.mosquitoTimer <= 0) {
            this.addMosquito();
            this.mosquitoTimer = Random.between(5, 10);
        }
        else
            this.mosquitoTimer -= 1;
    };
    Forest.prototype.thePlayerWon = function () {
        // If the player is at the right of the desert, we return true
        if (this.getGame().getPlayer().getGlobalPosition().x >= 294)
            return true;
        // Else we return false
        return false;
    };
    return Forest;
})(Quest);
///<reference path="House.ts"/>
// The lollipop
Saving.registerBool("forgeFoundLollipop", false);
// Items sold
Saving.registerBool("forgeBoughtWoodenSword", false);
Saving.registerBool("forgeBoughtIronAxe", false);
Saving.registerBool("forgeBoughtPolishedSilverSword", false);
Saving.registerBool("forgeBoughtLightweightBodyArmour", false);
Saving.registerBool("forgeBoughtScythe", false);
var Forge = (function (_super) {
    __extends(Forge, _super);
    // Constructor
    function Forge(game) {
        _super.call(this, game);
        // The render area
        this.renderArea = new RenderArea();
        // If...
        // We didn't buy one of the first three items
        if ((Saving.loadBool("forgeBoughtWoodenSword") == false || Saving.loadBool("forgeBoughtIronAxe") == false || Saving.loadBool("forgeBoughtPolishedSilverSword") == false)
            ||
                // We didn't buy the armour and we made the cave entrance
                (Saving.loadBool("forgeBoughtLightweightBodyArmour") == false && Saving.loadBool("mainMapDoneCaveEntrance") == true)
            ||
                // We didn't buy the scythe and the dragon is done
                (Saving.loadBool("forgeBoughtScythe") == false && Saving.loadBool("dragonDone") == true)) {
            // We set the normal introduction speech
            this.currentSpeech = "mapVillageForgeIntroductionSpeech";
        }
        else {
            // We set the no more to sell introduction speech
            this.currentSpeech = "mapVillageForgeIntroductionSpeechNoMoreToSell";
        }
        this.renderArea.resizeFromArray(Database.getAscii("places/village/forge"), 0, 3);
        this.update();
    }
    // getRenderArea()
    Forge.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // Private methods
    Forge.prototype.clickedBuyIronAxeButton = function () {
        if (this.getGame().getCandies().getCurrent() >= 400) {
            this.getGame().getCandies().add(-400); // -400 candies
            Saving.saveBool("forgeBoughtIronAxe", true); // We bought the axe
            this.getGame().gainItem("eqItemWeaponIronAxe"); // We now own the axe
            this.currentSpeech = "mapVillageForgeBuyIronAxeSpeech"; // New speech
            // We update
            this.update();
            this.getGame().updatePlace();
        }
    };
    Forge.prototype.clickedBuyLightweightBodyArmourButton = function () {
        if (this.getGame().getCandies().getCurrent() >= 15000) {
            this.getGame().getCandies().add(-15000); // -15000 candies
            Saving.saveBool("forgeBoughtLightweightBodyArmour", true); // We bought the armour
            this.getGame().gainItem("eqItemBodyArmoursLightweightBodyArmour"); // We now own the armour
            this.currentSpeech = "mapVillageForgeBuyLightweightBodyArmourSpeech"; // New speech
            // We update
            this.update();
            this.getGame().updatePlace();
        }
    };
    Forge.prototype.clickedBuyPolishedSilverSwordButton = function () {
        if (this.getGame().getCandies().getCurrent() >= 2000) {
            this.getGame().getCandies().add(-2000); // -2000 candies
            Saving.saveBool("forgeBoughtPolishedSilverSword", true); // We bought the sword
            this.getGame().gainItem("eqItemWeaponPolishedSilverSword"); // We now own the sword
            this.currentSpeech = "mapVillageForgeBuyPolishedSilverSwordSpeech"; // New speech
            // We update
            this.update();
            this.getGame().updatePlace();
        }
    };
    Forge.prototype.clickedBuyScytheButton = function () {
        if (this.getGame().getCandies().getCurrent() >= 5000000) {
            this.getGame().getCandies().add(-5000000); // -5000000 candies
            Saving.saveBool("forgeBoughtScythe", true); // We bought the scythe
            this.getGame().gainItem("eqItemWeaponScythe"); // We now own the scythe
            this.currentSpeech = "mapVillageForgeBuyScytheSpeech"; // New speech
            // We update
            this.update();
            this.getGame().updatePlace();
        }
    };
    Forge.prototype.clickedBuyWoodenSwordButton = function () {
        if (this.getGame().getCandies().getCurrent() >= 150) {
            this.getGame().getCandies().add(-150); // -150 candies
            Saving.saveBool("forgeBoughtWoodenSword", true); // We bought the sword
            this.getGame().gainItem("eqItemWeaponWoodenSword"); // We now own the sword
            this.currentSpeech = "mapVillageForgeBuyWoodenSwordSpeech"; // New speech
            Saving.saveBool("statusBarUnlockedInventory", true); // We unlock the inventory
            this.getGame().updateStatusBar(true); // We update the status bar
            this.getGame().getStatusBar().selectTabByType(StatusBarTabType.MAP); // We re-select the map tab (because adding the inventory tab created a gap in tab selection..)
            // We update
            this.update();
            this.getGame().updatePlace();
        }
    };
    Forge.prototype.drawLollipopStuff = function (x, y) {
        // If we didn't find the lollipop yet
        if (Saving.loadBool("forgeFoundLollipop") == false) {
            // We add a button to take the lollipop on the cupboard
            this.renderArea.addAsciiButton(x, x + 5, y, "forgeLollipopButton");
            // We add the link
            this.renderArea.addLinkCall(".forgeLollipopButton", new CallbackCollection(this.takeLollipop.bind(this)));
        }
        else {
            // We erase the lollipop
            this.renderArea.drawString("      ", x, y);
        }
    };
    Forge.prototype.takeLollipop = function () {
        // If we didn't get the lollipop yet
        if (Saving.loadBool("forgeFoundLollipop") == false) {
            // Add one lollipop
            this.getGame().getLollipops().add(1);
            // Set the bool
            Saving.saveBool("forgeFoundLollipop", true);
            // Update
            this.update();
            this.getGame().updatePlace();
        }
    };
    Forge.prototype.update = function () {
        // Erase everything
        this.renderArea.resetAllButSize();
        // Back to the map button
        this.addBackToTheVillageButton(this.renderArea, "forgeBackToTheVillageButton");
        // Draw the house
        this.renderArea.drawArray(Database.getAscii("places/village/forge"), 0, 3);
        // Draw the stuff about the lollipop
        this.drawLollipopStuff(18, 15);
        // Draw the blacksmith's speech
        this.renderArea.drawSpeech(Database.getText(this.currentSpeech), 13, 44, 67, "forgeSpeech", Database.getTranslatedText(this.currentSpeech));
        // Draw the buttons
        // If we never bought the wooden sword and we don't have one
        if (Saving.loadBool("forgeBoughtWoodenSword") == false && Saving.loadBool("eqItemWeaponWoodenSword") == false) {
            this.renderArea.addAsciiRealButton(Database.getText("mapVillageForgeBuyWoodenSwordButton"), 8, 35, "mapVillageForgeBuyWoodenSwordButton", Database.getTranslatedText("mapVillageForgeBuyWoodenSwordButton"), true, -1, null, false);
            this.renderArea.addLinkCall(".mapVillageForgeBuyWoodenSwordButton", new CallbackCollection(this.clickedBuyWoodenSwordButton.bind(this)));
        }
        else if (Saving.loadBool("forgeBoughtWoodenSword") == true && Saving.loadBool("forgeBoughtIronAxe") == false && Saving.loadBool("eqItemWeaponIronAxe") == false) {
            this.renderArea.addAsciiRealButton(Database.getText("mapVillageForgeBuyIronAxeButton"), 8, 35, "mapVillageForgeBuyIronAxeButton", Database.getTranslatedText("mapVillageForgeBuyIronAxeButton"), true, -1, null, false);
            this.renderArea.addLinkCall(".mapVillageForgeBuyIronAxeButton", new CallbackCollection(this.clickedBuyIronAxeButton.bind(this)));
        }
        else if (Saving.loadBool("forgeBoughtIronAxe") == true && Saving.loadBool("forgeBoughtPolishedSilverSword") == false && Saving.loadBool("eqItemWeaponPolishedSilverSword") == false) {
            this.renderArea.addAsciiRealButton(Database.getText("mapVillageForgeBuyPolishedSilverSwordButton"), 8, 35, "mapVillageForgeBuyPolishedSilverSwordButton", Database.getTranslatedText("mapVillageForgeBuyPolishedSilverSwordButton"), true, -1, null, false);
            this.renderArea.addLinkCall(".mapVillageForgeBuyPolishedSilverSwordButton", new CallbackCollection(this.clickedBuyPolishedSilverSwordButton.bind(this)));
        }
        else if (Saving.loadBool("forgeBoughtPolishedSilverSword") == true && Saving.loadBool("forgeBoughtLightweightBodyArmour") == false && Saving.loadBool("eqItemBodyArmoursLightweightBodyArmour") == false && Saving.loadBool("mainMapDoneCaveEntrance")) {
            this.renderArea.addAsciiRealButton(Database.getText("mapVillageForgeBuyLightweightBodyArmourButton"), 8, 35, "mapVillageForgeBuyLightweightBodyArmourButton", Database.getTranslatedText("mapVillageForgeBuyLightweightBodyArmourButton"), true, -1, null, false);
            this.renderArea.addLinkCall(".mapVillageForgeBuyLightweightBodyArmourButton", new CallbackCollection(this.clickedBuyLightweightBodyArmourButton.bind(this)));
        }
        else if (Saving.loadBool("forgeBoughtLightweightBodyArmour") == true && Saving.loadBool("forgeBoughtScythe") == false && Saving.loadBool("eqItemWeaponScythe") == false && Saving.loadBool("dragonDone")) {
            this.renderArea.addAsciiRealButton(Database.getText("mapVillageForgeBuyScytheButton"), 8, 35, "mapVillageForgeBuyScytheButton", Database.getTranslatedText("mapVillageForgeBuyScytheButton"), true, -1, null, false);
            this.renderArea.addLinkCall(".mapVillageForgeBuyScytheButton", new CallbackCollection(this.clickedBuyScytheButton.bind(this)));
        }
    };
    return Forge;
})(House);
///<reference path="Quest.ts"/>
Saving.registerBool("fortressRoom1ChestFound", false);
var FortressRoom1 = (function (_super) {
    __extends(FortressRoom1, _super);
    // Constructor
    function FortressRoom1(game) {
        _super.call(this, game);
        // Did we open the chest?
        this.chestOpened = false;
        // Resize the quest
        this.resizeQuest(208, 31);
        // Add collision boxes around
        this.addPlayerCollisionBoxes(true, true, true, true);
        // Add the player
        this.getGame().getPlayer().loadCandyBoxCharacter(this);
        this.getGame().getPlayer().setGlobalPosition(new Pos(0, 7));
        this.configPlayerOrClone(this.getGame().getPlayer());
        this.addEntity(this.getGame().getPlayer());
        // Add the walls
        this.addWalls();
        // Add the spikes
        this.addSpikes(new Spikes(this, new Pos(16, 30), 18));
        this.addSpikes(new Spikes(this, new Pos(43, 30), 4));
        this.addSpikes(new Spikes(this, new Pos(53, 30), 4));
        this.addSpikes(new Spikes(this, new Pos(85, 30), 4));
        this.addSpikes(new Spikes(this, new Pos(161, 30), 12));
        this.addSpikes(new Spikes(this, new Pos(180, 30), 4));
        this.addSpikes(new Spikes(this, new Pos(117, 9), 4));
        this.addSpikes(new Spikes(this, new Pos(121, 14), 4));
        this.addSpikes(new Spikes(this, new Pos(125, 19), 4));
        this.addSpikes(new Spikes(this, new Pos(129, 24), 4));
        // Add the xinopherydon
        this.addXinopherydon(new Pos(181, 2));
        // Add the chest
        this.addEntity(new Chest(this, new Pos(203, 24), false, new CallbackCollection(this.openChest.bind(this)), Saving.loadBool("fortressRoom1ChestFound")));
        // Add the message
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You enter the first room. It seems tricky."));
    }
    // Public methods
    FortressRoom1.prototype.castPlayerTeleport = function () {
        _super.prototype.castPlayerTeleport.call(this, new Pos(2, 3), new Pos(1, 1));
    };
    FortressRoom1.prototype.configPlayerOrClone = function (entity) {
        entity.setQuestEntityMovement(new QuestEntityMovement(new Pos(1, 0)));
        entity.getQuestEntityMovement().setGravity(true);
        entity.getQuestEntityMovement().setWormsLike(true);
    };
    FortressRoom1.prototype.endQuest = function (win) {
        // We add some messages
        if (win) {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You exit the room."));
        }
        // We call the endQuest method of our mother class
        _super.prototype.endQuest.call(this, win);
        // If we won and we opened the chest, we confirm that we found it
        if (win && this.chestOpened) {
            Saving.saveBool("fortressRoom1ChestFound", true);
        }
    };
    FortressRoom1.prototype.update = function () {
        if (this.getQuestEnded() == false) {
            // Test if the player is dead, if so end the quest (he won) and return
            if (this.getGame().getPlayer().shouldDie()) {
                this.endQuest(true); // true because we always win
                return;
            }
            // Update entities
            this.updateEntities();
        }
        // Draw
        this.preDraw();
        this.getRenderArea().drawArray(Database.getAscii("places/quests/fortress/room1"), this.getRealQuestPosition().x, this.getRealQuestPosition().y);
        this.drawEntities();
        this.drawAroundQuest();
        this.addExitQuestButton(new CallbackCollection(this.endQuest.bind(this, true), this.getGame().goToInsideFortress.bind(this.getGame())), "buttonExitQuestKeeping");
        this.postDraw();
    };
    // Private methods
    FortressRoom1.prototype.addSpikes = function (spikes) {
        this.addEntity(spikes);
    };
    FortressRoom1.prototype.addWalls = function () {
        // Create the wall entity
        var wall = new Wall(this, new Pos(0, 0));
        // Add the boxes
        wall.addBox(new Pos(0, 0), new Pos(208, 2));
        wall.addBox(new Pos(0, 8), new Pos(15, 1));
        wall.addBox(new Pos(0, 9), new Pos(16, 22));
        wall.addBox(new Pos(34, 2), new Pos(5, 11));
        wall.addBox(new Pos(34, 15), new Pos(9, 16));
        wall.addBox(new Pos(47, 13), new Pos(6, 18));
        wall.addBox(new Pos(57, 11), new Pos(6, 20));
        wall.addBox(new Pos(63, 19), new Pos(22, 12));
        wall.addBox(new Pos(66, 11), new Pos(4, 7));
        wall.addBox(new Pos(74, 11), new Pos(3, 7));
        wall.addBox(new Pos(80, 11), new Pos(5, 7));
        wall.addBox(new Pos(89, 10), new Pos(14, 5));
        wall.addBox(new Pos(89, 15), new Pos(20, 5));
        wall.addBox(new Pos(89, 20), new Pos(26, 5));
        wall.addBox(new Pos(89, 25), new Pos(72, 6));
        wall.addBox(new Pos(106, 10), new Pos(37, 2));
        wall.addBox(new Pos(112, 15), new Pos(31, 2));
        wall.addBox(new Pos(118, 20), new Pos(25, 2));
        wall.addBox(new Pos(200, 2), new Pos(8, 1));
        wall.addBox(new Pos(201, 3), new Pos(7, 4));
        wall.addBox(new Pos(200, 7), new Pos(8, 1));
        wall.addBox(new Pos(157, 8), new Pos(51, 10));
        wall.addBox(new Pos(157, 18), new Pos(25, 1));
        wall.addBox(new Pos(157, 19), new Pos(24, 1));
        wall.addBox(new Pos(157, 20), new Pos(23, 1));
        wall.addBox(new Pos(157, 21), new Pos(22, 1));
        wall.addBox(new Pos(173, 25), new Pos(7, 6));
        wall.addBox(new Pos(184, 23), new Pos(3, 2));
        wall.addBox(new Pos(207, 18), new Pos(1, 6));
        wall.addBox(new Pos(206, 24), new Pos(2, 1));
        wall.addBox(new Pos(184, 25), new Pos(24, 6));
        // Add the wall entity
        this.addEntity(wall);
    };
    FortressRoom1.prototype.addXinopherydon = function (pos) {
        var xino = new Xinopherydon(this, pos);
        xino.setHealthBar(new QuestEntityHealthBar(xino, new Pos(41, 1), new Pos(158, 2), QuestEntityHealthBarPositionType.FIXED, false, true, BarType.HEALTH));
        this.addEntity(xino);
    };
    FortressRoom1.prototype.openChest = function () {
        this.chestOpened = true;
        this.foundGridOrEqItem(new QuestItemFound(this, "gridItemPossessedUnicornHorn", "You opened a chest and found a unicorn horn!", "You gain a unicorn horn."));
    };
    return FortressRoom1;
})(Quest);
///<reference path="Quest.ts"/>
var FortressRoom2 = (function (_super) {
    __extends(FortressRoom2, _super);
    // Constructor
    function FortressRoom2(game) {
        _super.call(this, game);
        // Resize the quest
        this.resizeQuest(100, 17);
        // Add collision boxes around
        this.addPlayerCollisionBoxes(true, true, true, true);
        // Add the player
        this.getGame().getPlayer().loadCandyBoxCharacter(this);
        this.getGame().getPlayer().setGlobalPosition(new Pos(0, 13));
        this.configPlayerOrClone(this.getGame().getPlayer());
        this.addEntity(this.getGame().getPlayer());
        // Add the ground
        this.addWalls();
        // Add the chest
        this.addTeapot();
        // Add the message
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You enter the second room. There's a giant teapot in the center."));
    }
    // Public methods
    FortressRoom2.prototype.configPlayerOrClone = function (entity) {
        entity.setQuestEntityMovement(new QuestEntityMovement(new Pos(1, 0)));
        entity.getQuestEntityMovement().setGravity(true);
        entity.getQuestEntityMovement().setWormsLike(true);
    };
    FortressRoom2.prototype.endQuest = function (win) {
        // We add some messages
        if (win) {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You exit the room."));
        }
        // We call the endQuest method of our mother class
        _super.prototype.endQuest.call(this, win);
    };
    FortressRoom2.prototype.update = function () {
        if (this.getQuestEnded() == false) {
            // Test if the player is dead, if so end the quest (he won) and return
            if (this.getGame().getPlayer().shouldDie()) {
                this.endQuest(true); // true because we always win
                return;
            }
            // Update entities
            this.updateEntities();
        }
        // Draw
        this.preDraw();
        this.getRenderArea().drawArray(Database.getAscii("places/quests/fortress/room2"), this.getRealQuestPosition().x, this.getRealQuestPosition().y);
        this.drawEntities();
        this.drawAroundQuest();
        this.addExitQuestButton(new CallbackCollection(this.endQuest.bind(this, true), this.getGame().goToInsideFortress.bind(this.getGame())), "buttonExitQuestKeeping");
        this.postDraw();
    };
    // Private methods
    FortressRoom2.prototype.addWalls = function () {
        // Create the wall entity
        var wall = new Wall(this, new Pos(0, 0));
        // Add the boxes
        wall.addBox(new Pos(0, 0), new Pos(100, 4));
        wall.addBox(new Pos(96, 4), new Pos(4, 1));
        wall.addBox(new Pos(97, 5), new Pos(3, 8));
        wall.addBox(new Pos(96, 13), new Pos(4, 1));
        wall.addBox(new Pos(0, 14), new Pos(20, 1));
        wall.addBox(new Pos(79, 14), new Pos(21, 1));
        wall.addBox(new Pos(0, 15), new Pos(37, 1));
        wall.addBox(new Pos(59, 15), new Pos(41, 1));
        wall.addBox(new Pos(0, 16), new Pos(100, 1));
        // Add the wall entity
        this.addEntity(wall);
    };
    FortressRoom2.prototype.addTeapot = function () {
        var teapot = new Teapot(this, new Pos(39, 9));
        teapot.setHealthBar(new QuestEntityHealthBar(teapot, new Pos(96, 1), new Pos(0, 5), QuestEntityHealthBarPositionType.FIXED_ON_PAGE, false, true, BarType.HEALTH));
        this.addEntity(teapot);
    };
    return FortressRoom2;
})(Quest);
///<reference path="Quest.ts"/>
Saving.registerBool("fortressRoom3ChestFound", false);
var FortressRoom3 = (function (_super) {
    __extends(FortressRoom3, _super);
    // Constructor
    function FortressRoom3(game) {
        _super.call(this, game);
        // Did we open the chest?
        this.chestOpened = false;
        // Resize the quest
        this.resizeQuest(100, 31);
        // Add collision boxes around
        this.addPlayerCollisionBoxes(true, true, true, true);
        // Add the player
        this.getGame().getPlayer().loadCandyBoxCharacter(this);
        this.getGame().getPlayer().setGlobalPosition(new Pos(0, 30));
        this.configPlayerOrClone(this.getGame().getPlayer());
        this.addEntity(this.getGame().getPlayer());
        // Add the ground
        this.addWalls();
        // Add the chest
        this.addEntity(new Chest(this, new Pos(87, 6), false, new CallbackCollection(this.openChest.bind(this)), Saving.loadBool("fortressRoom3ChestFound")));
        // Add the message
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You enter the third room. There's a chest up there. How to reach it?!"));
    }
    // Public methods
    FortressRoom3.prototype.castPlayerTeleport = function () {
        _super.prototype.castPlayerTeleport.call(this, new Pos(2, 26), new Pos(1, 1));
    };
    FortressRoom3.prototype.configPlayerOrClone = function (entity) {
        entity.setQuestEntityMovement(new QuestEntityMovement(new Pos(1, 0)));
        entity.getQuestEntityMovement().setGravity(true);
        entity.getQuestEntityMovement().setWormsLike(true);
    };
    FortressRoom3.prototype.endQuest = function (win) {
        // We add some messages
        if (win) {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You exit the room."));
        }
        // We call the endQuest method of our mother class
        _super.prototype.endQuest.call(this, win);
        // If we won and we opened the chest, we confirm that we found it
        if (win && this.chestOpened) {
            Saving.saveBool("fortressRoom3ChestFound", true);
        }
    };
    FortressRoom3.prototype.update = function () {
        if (this.getQuestEnded() == false) {
            // Test if the player is dead, if so end the quest (he won) and return
            if (this.getGame().getPlayer().shouldDie()) {
                this.endQuest(true); // true because we always win
                return;
            }
            // Update entities
            this.updateEntities();
        }
        // Draw
        this.preDraw();
        this.getRenderArea().drawArray(Database.getAscii("places/quests/fortress/room3"), this.getRealQuestPosition().x, this.getRealQuestPosition().y);
        this.drawEntities();
        this.drawAroundQuest();
        this.addExitQuestButton(new CallbackCollection(this.endQuest.bind(this, true), this.getGame().goToInsideFortress.bind(this.getGame())), "buttonExitQuestKeeping");
        this.postDraw();
    };
    // Private methods
    FortressRoom3.prototype.addWalls = function () {
        // Create the wall entity
        var wall = new Wall(this, new Pos(0, 0));
        // Add the boxes
        wall.addBox(new Pos(0, 0), new Pos(100, 2));
        wall.addBox(new Pos(0, 2), new Pos(16, 23));
        wall.addBox(new Pos(90, 2), new Pos(10, 1));
        wall.addBox(new Pos(91, 3), new Pos(9, 3));
        wall.addBox(new Pos(90, 6), new Pos(10, 1));
        wall.addBox(new Pos(82, 7), new Pos(18, 24));
        wall.addBox(new Pos(0, 31), new Pos(100, 1));
        // Add the wall entity
        this.addEntity(wall);
    };
    FortressRoom3.prototype.openChest = function () {
        this.chestOpened = true;
        this.foundGridOrEqItem(new QuestItemFound(this, "eqItemBootsRocketBoots", "You opened a chest and found rocket boots!", "You gain rocket boots."));
    };
    return FortressRoom3;
})(Quest);
///<reference path="House.ts"/>
Saving.registerBool("fourthHouseFoundLollipopOnCupboard", false);
Saving.registerNumber("fourthHouseCupboardStep", 0); // 0 : closed ; 1 : opened ; 2 : lollipop taken
Saving.registerNumber("fourthHouseCarpetStep", 0); // 0 : lollipop still under the carpet ; 1 : lollipop outside ; 2 : lollipop taken
var FourthHouse = (function (_super) {
    __extends(FourthHouse, _super);
    // Constructor
    function FourthHouse(game) {
        _super.call(this, game);
        this.renderArea = new RenderArea();
        this.renderArea.resizeFromArray(Database.getAscii("places/village/fourthHouse"), 0, 3);
        this.update();
    }
    // getRenderArea()
    FourthHouse.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // Private methods
    FourthHouse.prototype.clickOnCarpet = function () {
        // If we never clicked on the carpet
        if (Saving.loadNumber("fourthHouseCarpetStep") == 0) {
            // Set the step
            Saving.saveNumber("fourthHouseCarpetStep", 1);
            // Update
            this.update();
            this.getGame().updatePlace();
        }
    };
    FourthHouse.prototype.drawCarpetStuff = function (x, y) {
        // We do different things depending on the step
        switch (Saving.loadNumber("fourthHouseCarpetStep")) {
            case 0:
                // We add a button on the area of the carpet around the lollipop
                this.renderArea.addMultipleAsciiButtons("fourthHouseCarpetButton", x - 2, x + 2, y - 1, x - 6, x + 1, y, x - 4, x, y + 1);
                // We add the link
                this.renderArea.addLinkCall(".fourthHouseCarpetButton", new CallbackCollection(this.clickOnCarpet.bind(this)));
                break;
            case 1:
                // We draw the lollipop
                this.renderArea.drawArray(Database.getAscii("places/village/fourthHouseLollipopUnderCarpet"), x, y);
                // We add a button on the lollipop
                this.renderArea.addAsciiButton(x, x + 4, y, "fourthHouseLollipopUnderCarpetButton");
                // We add the link
                this.renderArea.addLinkCall(".fourthHouseLollipopUnderCarpetButton", new CallbackCollection(this.pickCarpetLollipop.bind(this)));
                break;
            case 2:
                break;
        }
    };
    FourthHouse.prototype.drawLollipopOnCupboardStuff = function (x, y) {
        // If we didn't find the lollipop yet
        if (Saving.loadBool("fourthHouseFoundLollipopOnCupboard") == false) {
            // We add a button to take the lollipop on the cupboard
            this.renderArea.addAsciiButton(x + 8, x + 13, y + 1, "fourthHouseLollipopOnCupboardButton");
            // We add the link
            this.renderArea.addLinkCall(".fourthHouseLollipopOnCupboardButton", new CallbackCollection(this.takeLollipopOnCupboard.bind(this)));
        }
        else {
            // We draw the no lollipop ascii art
            this.renderArea.drawArray(Database.getAscii("places/village/fourthHouseNoLollipopOnCupboard"), x, y);
        }
    };
    FourthHouse.prototype.drawOpenCupboardStuff = function (x, y) {
        // We do different things depending on the step
        switch (Saving.loadNumber("fourthHouseCupboardStep")) {
            case 0:
                // We add a button on the cupboard's door
                this.renderArea.addMultipleAsciiButtons("fourthHouseCupboardDoorButton", x, x + 7, y, x, x + 7, y + 1, x, x + 7, y + 2, x, x + 7, y + 3, x, x + 7, y + 4, x, x + 7, y + 5, x, x + 7, y + 6, x, x + 7, y + 7, x, x + 7, y + 8, x, x + 7, y + 9, x, x + 7, y + 10, x, x + 7, y + 11, x, x + 7, y + 12);
                // We add the link
                this.renderArea.addLinkCall(".fourthHouseCupboardDoorButton", new CallbackCollection(this.openCupboard.bind(this)));
                break;
            case 1:
                // We draw the opened cupboard with the lollipop in it
                this.renderArea.drawArray(Database.getAscii("places/village/fourthHouseCupboardOpenedWithLollipop"), x - 2, y);
                // We add a button on the lollipop
                this.renderArea.addAsciiButton(x + 4, x + 6, y + 7, "fourthHouseLollipopInsideCupboardButton");
                // We add the link
                this.renderArea.addLinkCall(".fourthHouseLollipopInsideCupboardButton", new CallbackCollection(this.takeLollipopInsideCupboard.bind(this)));
                break;
            case 2:
                // We draw the opened cupboard without lollipop
                this.renderArea.drawArray(Database.getAscii("places/village/fourthHouseCupboardOpenedWithoutLollipop"), x - 2, y);
                break;
        }
    };
    FourthHouse.prototype.openCupboard = function () {
        // If the cupboard isn't opened yet
        if (Saving.loadNumber("fourthHouseCupboardStep") == 0) {
            // Set the step
            Saving.saveNumber("fourthHouseCupboardStep", 1);
            // Update
            this.update();
            this.getGame().updatePlace();
        }
    };
    FourthHouse.prototype.pickCarpetLollipop = function () {
        // If the lollipop is outside the carpet
        if (Saving.loadNumber("fourthHouseCarpetStep") == 1) {
            // Set the step
            Saving.saveNumber("fourthHouseCarpetStep", 2);
            // Add one lollipop
            this.getGame().getLollipops().add(1);
            // Update
            this.update();
            this.getGame().updatePlace();
        }
    };
    FourthHouse.prototype.takeLollipopInsideCupboard = function () {
        // If the cupboard is opened with the lollipop inside it
        if (Saving.loadNumber("fourthHouseCupboardStep") == 1) {
            // Set the step
            Saving.saveNumber("fourthHouseCupboardStep", 2);
            // Add one lollipop
            this.getGame().getLollipops().add(1);
            // Update
            this.update();
            this.getGame().updatePlace();
        }
    };
    FourthHouse.prototype.takeLollipopOnCupboard = function () {
        // If we didn't get the lollipop yet
        if (Saving.loadBool("fourthHouseFoundLollipopOnCupboard") == false) {
            // Add one lollipop
            this.getGame().getLollipops().add(1);
            // Set the bool
            Saving.saveBool("fourthHouseFoundLollipopOnCupboard", true);
            // Update
            this.update();
            this.getGame().updatePlace();
        }
    };
    FourthHouse.prototype.update = function () {
        // Erase everything
        this.renderArea.resetAllButSize();
        // Back to the map button
        this.addBackToTheVillageButton(this.renderArea, "fourthHouseBackToTheVillageButton");
        // Draw the house
        this.renderArea.drawArray(Database.getAscii("places/village/fourthHouse"), 0, 3);
        // Draw stuff about the lollipop on the cupboard
        this.drawLollipopOnCupboardStuff(35, 11);
        // Draw stuff about opening the cupboard
        this.drawOpenCupboardStuff(35, 14);
        // Draw stuff about the lollipop under the carpet
        this.drawCarpetStuff(41, 32);
    };
    return FourthHouse;
})(House);
var ThirdHouseGame = (function () {
    // Constructor
    function ThirdHouseGame(thirdHouse) {
        // Set the third house from parameter
        this.thirdHouse = thirdHouse;
        // Create the area
        this.renderArea = new RenderArea(53, 12);
        // Set the quest slowed down variable at the game level (and the quest speed up too)
        this.thirdHouse.getGame().setQuestSlowedDown(false);
        this.thirdHouse.getGame().setQuestSpeedUp(0);
    }
    // Public methods
    ThirdHouseGame.prototype.pressedDownButton = function () {
    };
    ThirdHouseGame.prototype.pressedSpaceButton = function () {
    };
    ThirdHouseGame.prototype.pressedUpButton = function () {
    };
    ThirdHouseGame.prototype.run = function () {
        return true;
    };
    // Public getters
    ThirdHouseGame.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    ThirdHouseGame.prototype.getThirdHouse = function () {
        return this.thirdHouse;
    };
    return ThirdHouseGame;
})();
///<reference path="ThirdHouseGame.ts"/>
Saving.registerNumber("galacticWarsBestScore", 0);
var GalacticWars = (function (_super) {
    __extends(GalacticWars, _super);
    function GalacticWars() {
        _super.apply(this, arguments);
        // The global step of the game (splash screen, the menu, or the game itself
        this.step = GalacticWarsStep.SPLASH_SCREEN;
        // The timer used for the splash screen
        this.splashScreenTimer = 47;
        // Asteroids
        this.asteroids = [];
        // Should we exit the game?
        this.exitGame = false;
    }
    // Public methods
    GalacticWars.prototype.run = function () {
        // To store the return value
        var returnValue = false;
        // If we should exit the game, we return true
        if (this.exitGame)
            return true;
        // Reset the area
        this.getRenderArea().resetAllButSize();
        // Do something different depending on the step
        switch (this.step) {
            case GalacticWarsStep.SPLASH_SCREEN:
                this.drawSplashScreen();
                returnValue = this.runSplashScreen();
                break;
            case GalacticWarsStep.GAME:
                this.drawGame();
                returnValue = this.runGame();
                break;
            case GalacticWarsStep.LOSE:
                this.drawLose();
                returnValue = false;
                break;
        }
        // We return
        return returnValue;
    };
    // Private methods
    GalacticWars.prototype.addAsteroids = function () {
        // Get the space sector we're in (0 to 3)
        var spaceSector = Math.floor(this.score / 100) % 4;
        // Get the space difficulty (0 to x)
        var spaceDifficulty = Math.floor(Math.floor(this.score / 100) / 4);
        // Get the spaceSeed43 (0 to 43), the spaceSeed21 (0 to 21) and the spaceSeed10 (0 to 10)
        var spaceSeed43 = this.score % 44;
        var spaceSeed21 = Math.floor(spaceSeed43 / 2);
        var spaceSeed10 = Math.floor(spaceSeed21 / 2);
        // Add different asteroids depending on the sector, the difficulty, and the seed
        switch (spaceSector) {
            // First sector : the seed is riding our tunnels, officer!
            case 0:
                switch (spaceDifficulty) {
                    case 0:
                        if (spaceSeed43 < 11 && spaceSeed21 < 6)
                            this.addAsteroid(spaceSeed10);
                        else if (spaceSeed43 > 29 && spaceSeed21 > 14)
                            this.addAsteroid(spaceSeed10);
                        break;
                    case 1:
                        if (spaceSeed43 < 13 && spaceSeed21 < 7)
                            this.addAsteroid(spaceSeed10);
                        else if (spaceSeed43 > 27 && spaceSeed21 > 13)
                            this.addAsteroid(spaceSeed10);
                        break;
                    default:
                        if (spaceSeed43 < 15 && spaceSeed21 < 8)
                            this.addAsteroid(spaceSeed10);
                        else if (spaceSeed43 > 25 && spaceSeed21 > 12)
                            this.addAsteroid(spaceSeed10);
                        break;
                }
                break;
            // Second sector
            case 1:
                switch (spaceDifficulty) {
                    case 0:
                        if (spaceSeed43 % 3 == 0 && (this.score * 7) % 25 > 15) {
                            for (var i = spaceSeed10 - 1; i <= spaceSeed10 + 1; i++) {
                                if (i >= 0 && i <= 10)
                                    this.addAsteroid(i);
                            }
                        }
                        break;
                    case 1:
                        if (spaceSeed43 % 3 == 0 && (this.score * 7) % 25 > 12) {
                            for (var i = spaceSeed10 - 1; i <= spaceSeed10 + 1; i++) {
                                if (i >= 0 && i <= 10)
                                    this.addAsteroid(i);
                            }
                        }
                        break;
                    default:
                        if (spaceSeed43 % 3 == 0 && (this.score * 7) % 25 > 10) {
                            for (var i = spaceSeed10 - 1; i <= spaceSeed10 + 1; i++) {
                                if (i >= 0 && i <= 10)
                                    this.addAsteroid(i);
                            }
                        }
                        break;
                }
                break;
            // Third sector
            case 2:
                switch (spaceDifficulty) {
                    case 0:
                        if (this.score % 25 == 0) {
                            var holePos = Random.between(0, 9);
                            for (var i = 0; i <= 10; i++) {
                                if (i != holePos && i != holePos + 1) {
                                    this.addAsteroid(i);
                                }
                            }
                        }
                        break;
                    case 1:
                        if (this.score % 20 == 0) {
                            var holePos = Random.between(0, 9);
                            for (var i = 0; i <= 10; i++) {
                                if (i != holePos && i != holePos + 1) {
                                    this.addAsteroid(i);
                                }
                            }
                        }
                        break;
                    default:
                        if (this.score % 15 == 0) {
                            var holePos = Random.between(0, 9);
                            for (var i = 0; i <= 10; i++) {
                                if (i != holePos && i != holePos + 1) {
                                    this.addAsteroid(i);
                                }
                            }
                        }
                        break;
                }
                break;
            // Fourth sector : a bit of randomness
            case 3:
                switch (spaceDifficulty) {
                    case 0:
                        if (Random.oneChanceOutOf(15))
                            this.addAsteroid(Random.between(0, 10));
                        break;
                    case 1:
                        if (Random.oneChanceOutOf(10))
                            this.addAsteroid(Random.between(0, 10));
                        break;
                    case 2:
                        if (Random.oneChanceOutOf(7))
                            this.addAsteroid(Random.between(0, 10));
                        break;
                    default:
                        if (Random.oneChanceOutOf(5))
                            this.addAsteroid(Random.between(0, 10));
                        break;
                }
                break;
        }
    };
    GalacticWars.prototype.addAsteroid = function (y) {
        this.asteroids.push(new Pos(53, y));
    };
    GalacticWars.prototype.checkCollision = function () {
        // If the ship is outside the screen, we return true
        if (this.shipYPosition < 0)
            return true;
        if (this.shipYPosition > 9)
            return true;
        // No collision, we return false
        return false;
    };
    GalacticWars.prototype.checkCollisionWithAsteroids = function () {
        // Boolean used to know if we already lose one hp or not
        var loseOneHp = false;
        for (var i = 0; i < this.asteroids.length; i++) {
            // There's a collision
            if (this.shipCollidesWithThisPos(this.asteroids[i])) {
                if (loseOneHp == false) {
                    // We lose one hp
                    this.hp -= 1;
                    loseOneHp = true;
                }
                // We destroy the asteroid
                this.asteroids.splice(i, 1);
                i--;
            }
        }
        // If we have less than 1 hp, we return true
        if (this.hp < 1)
            return true;
        // Else, we return false
        return false;
    };
    GalacticWars.prototype.drawGame = function () {
        // Draw the score
        this.getRenderArea().drawString("Score : " + this.score.toString(), 0, 0);
        // Draw hp
        this.getRenderArea().drawString("| HP : " + this.hp.toString(), 43, 0);
        // Draw the power
        this.getRenderArea().drawString("| Power : [", 14, 0);
        this.getRenderArea().drawHorizontalLine("x", 25, 25 + Math.floor(this.power / 150 * 16), 0);
        this.getRenderArea().drawString("]", 41, 0);
        // Draw the ship
        this.getRenderArea().drawArray(Database.getAscii("places/village/thirdHouseGames/GalacticWars/ship"), 0, 1 + this.shipYPosition);
        // Draw asteroids
        for (var i = 0; i < this.asteroids.length; i++) {
            this.getRenderArea().drawString("O", this.asteroids[i].x, 1 + this.asteroids[i].y);
        }
    };
    GalacticWars.prototype.drawLose = function () {
        // Draw "you lose"
        this.getRenderArea().drawArray(Database.getAscii("places/village/thirdHouseGames/GalacticWars/youLose"), 8, 1);
        // Draw the candies we won
        this.getRenderArea().drawString("Score : " + this.score + ".", 8, 7);
        this.getRenderArea().drawString("You gain " + (this.score + Algo.correctIfUnderZero(this.score - 1000) * 30) + " candies.", 8, 8);
        this.getRenderArea().drawString("Best score : " + Saving.loadNumber("galacticWarsBestScore") + ".", 8, 10);
    };
    GalacticWars.prototype.drawSplashScreen = function () {
        this.getRenderArea().drawArray(Database.getAscii("places/village/thirdHouseGames/GalacticWars/splashScreen"), -87 + this.splashScreenTimer * 3, 2);
    };
    GalacticWars.prototype.goToLose = function () {
        // Change the step
        this.step = GalacticWarsStep.LOSE;
        // Get the candies
        this.getThirdHouse().getGame().getCandies().add(this.score + Algo.correctIfUnderZero(this.score - 1000) * 30);
        // Update the best score
        if (this.score > Saving.loadNumber("galacticWarsBestScore"))
            Saving.saveNumber("galacticWarsBestScore", this.score);
    };
    GalacticWars.prototype.goToGame = function () {
        // Change the step
        this.step = GalacticWarsStep.GAME;
        // Set some useful parameters
        this.score = 2;
        this.shipYPosition = 4;
        this.hp = 10;
        this.power = 150;
        this.maxPower = 150;
        // Set the quest speedup
        this.getThirdHouse().getGame().setQuestSpeedUp(-50);
    };
    GalacticWars.prototype.pressedDownButton = function () {
    };
    GalacticWars.prototype.pressedSpaceButton = function () {
        // Variable used when deleting asteroids
        var oldI;
        // If we pressed space and we were losing, we should now exit the game
        if (this.step == GalacticWarsStep.LOSE)
            this.exitGame = true;
        else if (this.step == GalacticWarsStep.GAME) {
            // If we have enough power
            if (this.power == this.maxPower) {
                // We delete 3/4 of the asteroids
                oldI = 0;
                for (var i = 0; i < this.asteroids.length; i++) {
                    if ((oldI % 5) != 0) {
                        this.asteroids.splice(i, 1);
                        i--;
                    }
                    oldI++;
                }
                // We have no more power
                this.power = 0;
            }
        }
    };
    GalacticWars.prototype.pressedUpButton = function () {
    };
    GalacticWars.prototype.runGame = function () {
        // Variable used to calc the quest speedup later
        var questSpeedUp = 0;
        // Handle the keys
        if (Keyboard.isKeyPressed("down")) {
            // We try to make the ship go down
            this.shipYPosition += 1;
            // If there's a collision, we revert
            if (this.checkCollision())
                this.shipYPosition -= 1;
        }
        else if (Keyboard.isKeyPressed("up")) {
            // We try to make the ship go up
            this.shipYPosition -= 1;
            // If there's a collision, we revert
            if (this.checkCollision())
                this.shipYPosition += 1;
        }
        // Shift asteroids on the left
        for (var i = 0; i < this.asteroids.length; i++) {
            // If we can shift it, we do so
            if (this.asteroids[i].x > 0)
                this.asteroids[i].x -= 1;
            else {
                this.asteroids.splice(i, 1);
                i--;
            }
        }
        // Add asteroids
        this.addAsteroids();
        // Increase the score
        this.score = Math.ceil(Math.pow(this.score, 1.00015));
        // Increase the power
        if (this.power < this.maxPower)
            this.power += 1;
        // Check the collision of the player with asteroids
        if (this.checkCollisionWithAsteroids())
            this.goToLose();
        return false;
    };
    GalacticWars.prototype.runSplashScreen = function () {
        // If the timer is >= 0
        if (this.splashScreenTimer >= 0) {
            // Reduce the timer
            this.splashScreenTimer -= 1;
        }
        else {
            // Switch to the next step
            this.goToGame();
        }
        // We can't end the game during the splash screen
        return false;
    };
    GalacticWars.prototype.shipCollidesWithThisPos = function (pos) {
        if (pos.x < 0)
            return false;
        if (pos.x > 10)
            return false;
        if (pos.y < this.shipYPosition)
            return false;
        if (pos.y > this.shipYPosition + 1)
            return false;
        return true;
    };
    return GalacticWars;
})(ThirdHouseGame);
var GalacticWarsStep;
(function (GalacticWarsStep) {
    GalacticWarsStep[GalacticWarsStep["SPLASH_SCREEN"] = 0] = "SPLASH_SCREEN";
    GalacticWarsStep[GalacticWarsStep["GAME"] = 1] = "GAME";
    GalacticWarsStep[GalacticWarsStep["LOSE"] = 2] = "LOSE";
})(GalacticWarsStep || (GalacticWarsStep = {}));
///<reference path="./../../libs/jquery.d.ts"/>
var RenderLocation = (function () {
    // Constructor
    function RenderLocation(locationString, scrolling) {
        if (scrolling === void 0) { scrolling = false; }
        this.scrolling = null;
        this.setLocationString(locationString);
        this.setScrolling(scrolling);
    }
    // Public methods
    RenderLocation.prototype.render = function (renderArea) {
        $(this.locationString).html(renderArea.getForRendering());
        renderArea.runLinks();
    };
    RenderLocation.prototype.setContentGap = function (gap) {
        var ex, outerWidth, addGap = 0;
        // Get our outer width
        outerWidth = $(this.locationString).outerWidth();
        // Get the real ex value
        ex = this.getRealExValueFromTheStatusBar();
        // If our outerWidth is bigger than the window, calc an additional gap
        if (outerWidth > $(window).width())
            addGap = -(outerWidth - $(window).width()) / 2;
        // Finally change the "left" value of our div
        $(this.locationString).css({ "left": ((gap / 2) * ex + addGap).toString() + "px" });
    };
    // Public setters    
    RenderLocation.prototype.setLocationString = function (locationString) {
        this.locationString = locationString;
    };
    RenderLocation.prototype.setScrolling = function (scrolling, defaultScroll) {
        if (defaultScroll === void 0) { defaultScroll = 0; }
        // If the scrolling is different
        if (this.scrolling != scrolling) {
            this.scrolling = scrolling;
            // We initialize or stop scrolling, depending on the new scrolling value
            if (this.scrolling)
                this.initScrolling(defaultScroll);
            else
                this.stopScrolling();
        }
    };
    // Public getters
    RenderLocation.prototype.getScroll = function () {
        return $("html").scrollTop();
    };
    RenderLocation.prototype.getScrolling = function () {
        return this.scrolling;
    };
    // Private methods
    RenderLocation.prototype.getRealExValueFromTheStatusBar = function () {
        // DISCLAIMER
        // Yes, I know that this method is really ugly
        // But if I don't do this way, there are some stupid gaps in long quests and the browser zooms in and out (or even without zooming in Chrome)
        // If anyone has a better cross-browser solution, please tell me!
        // Return the real "ex" value in pixels
        return $("#statusBar").outerWidth() / 100;
    };
    RenderLocation.prototype.initScrolling = function (defaultScroll) {
        // Scroll to the default scroll
        $("html").scrollTop(defaultScroll);
        // Set css for our location string
        $(this.locationString).css({
            'position': 'absolute',
            'left': '0',
            'top': '0',
            'overflow-x': 'scroll'
        });
        // Set css for around the status bar
        $("#aroundStatusBar").css({
            'position': 'fixed',
            'top': '0',
            'left': '0',
            'right': '0',
            'height': '0'
        });
    };
    RenderLocation.prototype.stopScrolling = function () {
        // Set the scroll to 0
        $("html").scrollTop(0);
        // Reset css for our location string
        $(this.locationString).css({
            'position': 'relative',
            'overflow-x': 'hidden'
        });
        // Reset css for around the status bar
        $("#aroundStatusBar").css({
            'position': 'relative',
            'top': 'auto',
            'left': 'auto',
            'right': 'auto',
            'height': 'auto'
        });
    };
    return RenderLocation;
})();
///<reference path="Place.ts"/>
///<reference path="RenderLocation.ts"/>
///<reference path="RenderArea.ts"/>
///<reference path="Resource.ts"/>
// Config
Saving.registerBool("gameDebug", false);
Saving.registerString("gameLanguage", "en");
Saving.registerBool("gameInvertedColors", false);
// EqItems
Saving.registerString("gameWeaponSelected", "inventorySpecialNothingWeapon");
Saving.registerString("gameHatSelected", "inventorySpecialNothingHat");
Saving.registerString("gameBodyArmourSelected", "inventorySpecialNothingBodyArmour");
Saving.registerString("gameGlovesSelected", "inventorySpecialNothingGloves");
Saving.registerString("gameBootsSelected", "inventorySpecialNothingBoots");
// Stuff about gaining lollipops each second
Saving.registerNumber("gameSecondsElapsedSinceLastLollipopsProduction", 0);
// Resources
Saving.registerNumber("gameCandiesAccumulated", 0);
Saving.registerNumber("gameCandiesCurrent", 0);
Saving.registerNumber("gameCandiesMax", 0);
Saving.registerNumber("gameLollipopsAccumulated", 0);
Saving.registerNumber("gameLollipopsCurrent", 0);
Saving.registerNumber("gameLollipopsMax", 0);
Saving.registerNumber("gameChocolateBarsAccumulated", 0);
Saving.registerNumber("gameChocolateBarsCurrent", 0);
Saving.registerNumber("gameChocolateBarsMax", 0);
Saving.registerNumber("gamePainsAuChocolatAccumulated", 0);
Saving.registerNumber("gamePainsAuChocolatCurrent", 0);
Saving.registerNumber("gamePainsAuChocolatMax", 0);
Saving.registerNumber("gameCandiesEatenAccumulated", 0);
Saving.registerNumber("gameCandiesEatenCurrent", 0);
Saving.registerNumber("gameCandiesEatenMax", 0);
Saving.registerNumber("gameCandiesThrownAccumulated", 0);
Saving.registerNumber("gameCandiesThrownCurrent", 0);
Saving.registerNumber("gameCandiesThrownMax", 0);
Saving.registerNumber("gameCandiesUsedToRequestFeaturesAccumulated", 0);
Saving.registerNumber("gameCandiesUsedToRequestFeaturesCurrent", 0);
Saving.registerNumber("gameCandiesUsedToRequestFeaturesMax", 0);
Saving.registerNumber("gameCandiesInCauldronAccumulated", 0);
Saving.registerNumber("gameCandiesInCauldronCurrent", 0);
Saving.registerNumber("gameCandiesInCauldronMax", 0);
Saving.registerNumber("gameLollipopsInCauldronAccumulated", 0);
Saving.registerNumber("gameLollipopsInCauldronCurrent", 0);
Saving.registerNumber("gameLollipopsInCauldronMax", 0);
// Gifts
Saving.registerNumber("gameGiftPower", 0);
Saving.registerNumber("gameGiftHealth", 0);
Saving.registerNumber("gameGiftMagic", 0);
// The gamemode
Saving.registerString("gameGameMode", "normal");
var Game = (function () {
    // Constructor
    function Game(gameMode) {
        // Render locations
        this.statusBarLocation = new RenderLocation("#statusBar");
        this.mainContentLocation = new RenderLocation("#mainContent");
        this.candiesUsedToRequestFeatures = new Resource("gameCandiesUsedToRequestFeatures");
        this.candiesInCauldron = new Resource("gameCandiesInCauldron");
        this.lollipopsInCauldron = new Resource("gameLollipopsInCauldron");
        // Grid items
        this.gridItems = {};
        // EqItems
        this.weapons = {};
        this.hats = {};
        this.bodyArmours = {};
        this.gloves = {};
        this.boots = {};
        // EqItems selected from the various arrays above (the selection being made in the inventory tab)
        this.selectedEqItems = {};
        // The quest log
        this.questLog = new QuestLog();
        // Locations
        this.place = null;
        this.savedPlace = null;
        // Hotkeys
        this.hotkeys = {}; // Hotkeys used by the places
        this.specialHotkeys = []; // Special hotkeys, not linked to the places we visit (used to switch tabs, for example)
        // Some info bools
        this.weAreQuesting = false;
        // Callbacks
        this.oneSecondCallbackCollection = new CallbackCollection();
        this.questCallbackCollection = new CallbackCollection();
        // Is the quest slowed down ?
        this.questSlowedDown = false;
        // Local autosave
        this.localAutosaveEnabled = false;
        this.localAutosaveSlot = null;
        this.localAutosaveTime = null; // Time in seconds before the next save
        // Is the status bar allowed to use the n key to go to the next tab? (this is set to false when using the computer...)
        this.isStatusBarAllowedToUseTheNKey = true;
        // We save the game mode given in parameter
        if (gameMode != null)
            Saving.saveString("gameGameMode", gameMode);
        // We create the grid items
        this.createGridItems();
        // We create the eqItems
        this.createEqItems();
        // We create the status bar
        this.statusBar = new StatusBar(this, 0);
        // We create the player
        this.player = new Player(this);
        // We create the resources
        this.candies = new Candies(this, "gameCandies");
        this.lollipops = new Lollipops(this, "gameLollipops");
        this.chocolateBars = new ChocolateBars(this, "gameChocolateBars");
        this.painsAuChocolat = new PainsAuChocolat(this, "gamePainsAuChocolat");
        this.candiesEaten = new CandiesEaten(this, "gameCandiesEaten");
        this.candiesThrown = new CandiesThrown(this, "gameCandiesThrown");
        // We update the status bar
        this.updateStatusBar();
        // We launch timeouts & intervals methods
        this.oneSecondIntervalId = window.setInterval(this.oneSecondMethod.bind(this), 1000);
        window.setTimeout(this.questMethod.bind(this), 100);
    }
    // Public methods
    Game.prototype.addHotkey = function (hotkey) {
        this.hotkeys[hotkey.getKeyString()] = hotkey;
    };
    Game.prototype.addSpecialHotkey = function (hotkey) {
        this.specialHotkeys.push(hotkey);
    };
    Game.prototype.applyInvertedColorsToCss = function () {
        if (Saving.loadBool("gameInvertedColors") == false)
            $('#invertColorsStylesheet').remove();
        else
            $('head').append('<link href="css/invertColors.css" rel="stylesheet" id="invertColorsStylesheet"/>');
    };
    Game.prototype.calcLollipopFarmProduction = function () {
        // Is the production each second ?
        Saving.saveBool("lollipopFarmIsProductionEachSecond", this.isLollipopFarmProductionEachSecond());
        // If we produce x lollipops each second
        if (Saving.loadBool("lollipopFarmIsProductionEachSecond")) {
            Saving.saveNumber("lollipopFarmProduction", (Saving.loadBool("gridItemPossessedShellPowder") ? 3 : 1) *
                (Saving.loadBool("gridItemPossessedPitchfork") ? 3 : 1) *
                (Saving.loadBool("gridItemPossessedGreenSharkFin") ? 5 : 1) *
                Math.ceil(100 * (1 - Math.exp(-(Saving.loadNumber("lollipopFarmLollipopsPlanted") - 20) / 5000))));
        }
        else {
            switch (Saving.loadNumber("lollipopFarmLollipopsPlanted")) {
                case 1:
                    Saving.saveNumber("lollipopFarmProduction", 3600 * 8);
                    break;
                case 2:
                    Saving.saveNumber("lollipopFarmProduction", 3600 * 5);
                    break;
                case 3:
                    Saving.saveNumber("lollipopFarmProduction", 3600 * 2);
                    break;
                case 4:
                    Saving.saveNumber("lollipopFarmProduction", 3600);
                    break;
                case 5:
                    Saving.saveNumber("lollipopFarmProduction", 60 * 40);
                    break;
                case 6:
                    Saving.saveNumber("lollipopFarmProduction", 60 * 25);
                    break;
                case 7:
                    Saving.saveNumber("lollipopFarmProduction", 60 * 12);
                    break;
                case 8:
                    Saving.saveNumber("lollipopFarmProduction", 60 * 8);
                    break;
                case 9:
                    Saving.saveNumber("lollipopFarmProduction", 60 * 5);
                    break;
                case 10:
                    Saving.saveNumber("lollipopFarmProduction", 60 * 2);
                    break;
                case 11:
                    Saving.saveNumber("lollipopFarmProduction", 60);
                    break;
                case 12:
                    Saving.saveNumber("lollipopFarmProduction", 52);
                    break;
                case 13:
                    Saving.saveNumber("lollipopFarmProduction", 42);
                    break;
                case 14:
                    Saving.saveNumber("lollipopFarmProduction", 30);
                    break;
                case 15:
                    Saving.saveNumber("lollipopFarmProduction", 16);
                    break;
                case 16:
                    Saving.saveNumber("lollipopFarmProduction", 8);
                    break;
                case 17:
                    Saving.saveNumber("lollipopFarmProduction", 5);
                    break;
                case 18:
                    Saving.saveNumber("lollipopFarmProduction", 4);
                    break;
                case 19:
                    Saving.saveNumber("lollipopFarmProduction", 3);
                    break;
                case 20:
                    Saving.saveNumber("lollipopFarmProduction", 2);
                    break;
            }
        }
    };
    Game.prototype.canStartQuest = function () {
        if (this.player.getHp() == 0)
            return false;
        return true;
    };
    Game.prototype.clearAllIntervals = function () {
        clearInterval(this.oneSecondIntervalId);
    };
    Game.prototype.disableLocalAutosave = function () {
        this.localAutosaveEnabled = false;
        this.localAutosaveSlot = null;
    };
    Game.prototype.emptyAndFillSelectedEqItemsArray = function () {
        // Empty
        this.selectedEqItems = {};
        // Fill
        if (Saving.loadString("gameWeaponSelected") != "inventorySpecialNothingWeapon")
            this.selectedEqItems["weapon"] = this.weapons[Saving.loadString("gameWeaponSelected")];
        if (Saving.loadString("gameHatSelected") != "inventorySpecialNothingHat")
            this.selectedEqItems["hat"] = this.hats[Saving.loadString("gameHatSelected")];
        if (Saving.loadString("gameBodyArmourSelected") != "inventorySpecialNothingBodyArmour")
            this.selectedEqItems["bodyArmour"] = this.bodyArmours[Saving.loadString("gameBodyArmourSelected")];
        if (Saving.loadString("gameGlovesSelected") != "inventorySpecialNothingGloves")
            this.selectedEqItems["gloves"] = this.gloves[Saving.loadString("gameGlovesSelected")];
        if (Saving.loadString("gameBootsSelected") != "inventorySpecialNothingBoots")
            this.selectedEqItems["boots"] = this.boots[Saving.loadString("gameBootsSelected")];
    };
    Game.prototype.enableLocalAutosave = function (localAutosaveSlot) {
        this.localAutosaveEnabled = true;
        this.localAutosaveSlot = localAutosaveSlot;
        this.setDefaultLocalAutosaveTime();
    };
    Game.prototype.gainItem = function (itemSavingName) {
        Saving.saveBool(itemSavingName, true);
        this.player.reCalcMaxHp(); // We re calc the player max hp just in case
        this.calcLollipopFarmProduction(); // Idem for the farm production
    };
    Game.prototype.getEqItemFromEqItemType = function (savingName, type) {
        switch (type) {
            case EqItemType.WEAPON:
                return this.weapons[savingName];
                break;
            case EqItemType.HAT:
                return this.hats[savingName];
                break;
            case EqItemType.BODYARMOUR:
                return this.bodyArmours[savingName];
                break;
            case EqItemType.GLOVES:
                return this.gloves[savingName];
                break;
            case EqItemType.BOOTS:
                return this.boots[savingName];
                break;
        }
    };
    Game.prototype.isEquipped = function (type, savingName) {
        if (this.selectedEqItems[type] == undefined || this.selectedEqItems[type] == null)
            return false;
        else
            return (this.selectedEqItems[type].getSavingName() == savingName);
    };
    Game.prototype.isLollipopFarmProductionEachSecond = function () {
        if (Saving.loadNumber("lollipopFarmLollipopsPlanted") > 20) {
            return true;
        }
        return false;
    };
    Game.prototype.load = function () {
        // Resources
        this.candies.load();
        this.lollipops.load();
        this.chocolateBars.load();
        this.painsAuChocolat.load();
        this.candiesEaten.load();
        this.candiesThrown.load();
        this.candiesUsedToRequestFeatures.load();
        this.candiesInCauldron.load();
        this.lollipopsInCauldron.load();
        // Handle inverted colors (we have to change the css now depending on the gameInvertedColors bool from the Saving module)
        this.applyInvertedColorsToCss();
    };
    Game.prototype.postLoad = function () {
        // We re calc the player hp
        this.player.reCalcMaxHp();
        // We update the status bar
        this.updateStatusBar(true);
        // Select correct items
        this.emptyAndFillSelectedEqItemsArray();
        // We go to the candy box
        this.goToCandyBox();
        // And we set the saved place (the village)
        this.savedPlace = new Village(this);
    };
    Game.prototype.resetPlayer = function () {
        // Save some important things
        var hp = this.player.getHp();
        var maxHp = this.player.getMaxHp();
        // Re-create the player
        this.player = new Player(this);
        // Restore the important things saved
        this.player.setHp(hp);
        this.player.setMaxHp(maxHp);
    };
    Game.prototype.resetSpecialHotkeys = function () {
        this.specialHotkeys = [];
    };
    Game.prototype.save = function () {
        // Resources
        this.candies.save();
        this.lollipops.save();
        this.chocolateBars.save();
        this.painsAuChocolat.save();
        this.candiesEaten.save();
        this.candiesThrown.save();
        this.candiesUsedToRequestFeatures.save();
        this.candiesInCauldron.save();
        this.lollipopsInCauldron.save();
    };
    Game.prototype.setPlace = function (place) {
        // If the current place isn't null, we warn it that we're going to stop displaying it
        if (this.place != null) {
            this.place.willStopBeingDisplayed();
            this.resetHotkeys();
            // If we didn't save this place we're not displaying anymore
            if (this.savedPlace == null) {
                // It means we're closing it actually, so we tell it that we're closing it
                this.place.willBeClosed();
            }
        }
        // Set the place
        this.place = place;
        // Callbacks
        this.resetResourcesCallbacks();
        this.place.willBeDisplayed();
        // Display the place for the first time
        this.displayPlace();
    };
    Game.prototype.unequipIfEquipped = function (savingName, type) {
        switch (type) {
            case EqItemType.WEAPON:
                if (this.selectedEqItems["weapon"] != null && this.selectedEqItems["weapon"].getSavingName() == savingName)
                    Saving.saveString("gameWeaponSelected", "inventorySpecialNothingWeapon");
                break;
            case EqItemType.HAT:
                if (this.selectedEqItems["hat"] != null && this.selectedEqItems["hat"].getSavingName() == savingName)
                    Saving.saveString("gameHatSelected", "inventorySpecialNothingHat");
                break;
            case EqItemType.BODYARMOUR:
                if (this.selectedEqItems["bodyArmour"] != null && this.selectedEqItems["bodyArmour"].getSavingName() == savingName)
                    Saving.saveString("gameBodyArmourSelected", "inventorySpecialNothingBodyArmour");
                break;
            case EqItemType.GLOVES:
                if (this.selectedEqItems["gloves"] != null && this.selectedEqItems["gloves"].getSavingName() == savingName)
                    Saving.saveString("gameGlovesSelected", "inventorySpecialNothingGloves");
                break;
            case EqItemType.BOOTS:
                if (this.selectedEqItems["boots"] != null && this.selectedEqItems["boots"].getSavingName() == savingName)
                    Saving.saveString("gameBootsSelected", "inventorySpecialNothingBoots");
                break;
        }
        this.emptyAndFillSelectedEqItemsArray();
    };
    Game.prototype.updatePlace = function () {
        this.displayPlace();
    };
    Game.prototype.updateStatusBar = function (reAdd) {
        if (reAdd === void 0) { reAdd = false; }
        if (reAdd)
            this.statusBar.deleteAndReAddEverything();
        this.statusBar.updateAll();
        this.statusBarLocation.render(this.statusBar.getRenderArea());
    };
    // "go to" methods
    Game.prototype.goToCandyBox = function () {
        this.saveCurrentMapPlace();
        this.setPlace(new CandyBox(this));
    };
    Game.prototype.goToCastle = function () {
        this.setPlace(new Castle(this));
    };
    Game.prototype.goToCastleEntrance = function () {
        this.setPlace(new CastleEntrance(this));
    };
    Game.prototype.goToCauldron = function () {
        this.saveCurrentMapPlace();
        this.setPlace(new Cauldron(this));
    };
    Game.prototype.goToCfg = function () {
        this.saveCurrentMapPlace();
        this.setPlace(new Cfg(this));
    };
    Game.prototype.goToInsideFortress = function () {
        this.setPlace(new InsideFortress(this));
    };
    Game.prototype.goToInsideYourBox = function () {
        this.saveCurrentMapPlace();
        this.setPlace(new InsideYourBox(this));
    };
    Game.prototype.goToInventory = function () {
        this.saveCurrentMapPlace();
        this.setPlace(new Inventory(this));
    };
    Game.prototype.goToLighthouse = function () {
        this.setPlace(new Lighthouse(this));
    };
    Game.prototype.goToLollipopFarm = function () {
        this.saveCurrentMapPlace();
        this.setPlace(new LollipopFarm(this));
    };
    Game.prototype.goToMainMap = function () {
        this.setPlace(new MainMap(this));
    };
    Game.prototype.goToMap = function () {
        this.setPlaceFromSavedMapPlace();
    };
    Game.prototype.goToSave = function () {
        this.saveCurrentMapPlace();
        this.setPlace(new Save(this));
    };
    Game.prototype.goToSorceressHut = function () {
        this.setPlace(new SorceressHut(this));
    };
    Game.prototype.goToTheArena = function () {
        this.saveCurrentMapPlace();
        this.setPlace(new TheArena(this));
    };
    Game.prototype.goToTheCave = function () {
        this.setPlace(new TheCave(this));
    };
    Game.prototype.goToTheComputer = function () {
        this.saveCurrentMapPlace();
        this.setPlace(new TheComputer(this));
    };
    Game.prototype.goToVillage = function () {
        this.setPlace(new Village(this));
    };
    Game.prototype.goToYourself = function () {
        this.setPlace(new Yourself(this));
    };
    // Public getters
    Game.prototype.getBodyArmours = function () {
        return this.bodyArmours;
    };
    Game.prototype.getBoots = function () {
        return this.boots;
    };
    Game.prototype.getCandies = function () {
        return this.candies;
    };
    Game.prototype.getCandiesEaten = function () {
        return this.candiesEaten;
    };
    Game.prototype.getCandiesInCauldron = function () {
        return this.candiesInCauldron;
    };
    Game.prototype.getCandiesThrown = function () {
        return this.candiesThrown;
    };
    Game.prototype.getCandiesUsedToRequestFeatures = function () {
        return this.candiesUsedToRequestFeatures;
    };
    Game.prototype.getChocolateBars = function () {
        return this.chocolateBars;
    };
    Game.prototype.getGloves = function () {
        return this.gloves;
    };
    Game.prototype.getHats = function () {
        return this.hats;
    };
    Game.prototype.getHotkeys = function () {
        return this.hotkeys;
    };
    Game.prototype.getGridItems = function () {
        return this.gridItems;
    };
    Game.prototype.getIsStatusBarAllowedToUseTheNKey = function () {
        return this.isStatusBarAllowedToUseTheNKey;
    };
    Game.prototype.getLocalAutosaveEnabled = function () {
        return this.localAutosaveEnabled;
    };
    Game.prototype.getLocalAutosaveSlot = function () {
        return this.localAutosaveSlot;
    };
    Game.prototype.getLocalAutosaveTime = function () {
        return this.localAutosaveTime;
    };
    Game.prototype.getLollipops = function () {
        return this.lollipops;
    };
    Game.prototype.getLollipopsInCauldron = function () {
        return this.lollipopsInCauldron;
    };
    Game.prototype.getPainsAuChocolat = function () {
        return this.painsAuChocolat;
    };
    Game.prototype.getQuestCallbackCollection = function () {
        return this.questCallbackCollection;
    };
    Game.prototype.getQuestLog = function () {
        return this.questLog;
    };
    Game.prototype.getQuestSlowedDown = function () {
        return this.questSlowedDown;
    };
    Game.prototype.getQuestSpeedUp = function () {
        return this.questSpeedUp;
    };
    Game.prototype.getOneSecondCallbackCollection = function () {
        return this.oneSecondCallbackCollection;
    };
    Game.prototype.getPlayer = function () {
        return this.player;
    };
    Game.prototype.getMainContentLocation = function () {
        return this.mainContentLocation;
    };
    Game.prototype.getSelectedEqItems = function () {
        return this.selectedEqItems;
    };
    Game.prototype.getSpecialHotkeys = function () {
        return this.specialHotkeys;
    };
    Game.prototype.getStatusBar = function () {
        return this.statusBar;
    };
    Game.prototype.getWeapons = function () {
        return this.weapons;
    };
    Game.prototype.getWeAreQuesting = function () {
        return this.weAreQuesting;
    };
    // Public setters
    Game.prototype.setIsStatusBarAllowedToUseTheNKey = function (isStatusBarAllowedToUseTheNKey) {
        this.isStatusBarAllowedToUseTheNKey = isStatusBarAllowedToUseTheNKey;
    };
    Game.prototype.setQuestSlowedDown = function (questSlowedDown) {
        this.questSlowedDown = questSlowedDown;
    };
    Game.prototype.setQuestSpeedUp = function (questSpeedUp) {
        this.questSpeedUp = questSpeedUp;
    };
    Game.prototype.setWeAreQuesting = function (weAreQuesting) {
        this.weAreQuesting = weAreQuesting;
    };
    // Private methods
    Game.prototype.addEqItem = function (eqItem, array) {
        array[eqItem.getSavingName()] = eqItem;
    };
    Game.prototype.addGridItem = function (gridItem) {
        this.gridItems[gridItem.getSavingName()] = gridItem;
    };
    Game.prototype.createEqItems = function () {
        // Create weapons
        this.addEqItem(new WoodenSword(), this.weapons);
        this.addEqItem(new IronAxe(), this.weapons);
        this.addEqItem(new PolishedSilverSword(), this.weapons);
        this.addEqItem(new TrollBludgeon(), this.weapons);
        this.addEqItem(new MonkeyWizardStaff(), this.weapons);
        this.addEqItem(new EnchantedMonkeyWizardStaff(), this.weapons);
        this.addEqItem(new TribalSpear(), this.weapons);
        this.addEqItem(new SummoningTribalSpear(), this.weapons);
        this.addEqItem(new GiantSpoon(), this.weapons);
        this.addEqItem(new Scythe(), this.weapons);
        this.addEqItem(new GiantSpoonOfDoom(), this.weapons);
        // Create hats
        this.addEqItem(new OctopusKingCrown(), this.hats);
        this.addEqItem(new OctopusKingCrownWithJaspers(), this.hats);
        this.addEqItem(new OctopusKingCrownWithObsidian(), this.hats);
        this.addEqItem(new MerchantHat(), this.hats);
        this.addEqItem(new SorceressHat(), this.hats);
        // Create body armours
        this.addEqItem(new LightweightBodyArmour(), this.bodyArmours);
        this.addEqItem(new KnightBodyArmour(), this.bodyArmours);
        this.addEqItem(new EnchantedKnightBodyArmour(), this.bodyArmours);
        // Create gloves
        this.addEqItem(new LeatherGloves(), this.gloves);
        this.addEqItem(new RedEnchantedGloves(), this.gloves);
        this.addEqItem(new PinkEnchantedGloves(), this.gloves);
        // Create boots
        this.addEqItem(new LeatherBoots(), this.boots);
        this.addEqItem(new RocketBoots(), this.boots);
        this.addEqItem(new BootsOfIntrospection(), this.boots);
    };
    Game.prototype.createGridItems = function () {
        // First line
        this.addGridItem(new GridItem("gridItemPossessedMainMap", "gridItemMainMapName", "gridItemMainMapDescription", "gridItems/mainMap", new Pos(0, 0)));
        this.addGridItem(new GridItem("gridItemPossessedTimeRing", "gridItemTimeRingName", "gridItemTimeRingDescription", "gridItems/timeRing", new Pos(1, 0)));
        this.addGridItem(new GridItem("gridItemPossessedThirdHouseKey", "gridItemThirdHouseKeyName", "gridItemThirdHouseKeyDescription", "gridItems/thirdHouseKey", new Pos(2, 0)));
        this.addGridItem(new GridItem("gridItemPossessedBeginnersGrimoire", "gridItemBeginnersGrimoireName", "gridItemBeginnersGrimoireDescription", "gridItems/beginnersGrimoire", new Pos(3, 0)));
        // Second line
        this.addGridItem(new Feather("gridItemPossessedFeather", "gridItemFeatherName", "gridItemFeatherDescription", "gridItems/feather", new Pos(0, 1)));
        this.addGridItem(new GridItem("gridItemPossessedPogoStick", "gridItemPogoStickName", "gridItemPogoStickDescription", "gridItems/pogoStick", new Pos(1, 1)));
        this.addGridItem(new GridItem("gridItemPossessedHeartPlug", "gridItemHeartPlugName", "gridItemHeartPlugDescription", "gridItems/heartPlug", new Pos(2, 1)));
        this.addGridItem(new GridItem("gridItemPossessedAdvancedGrimoire", "gridItemAdvancedGrimoireName", "gridItemAdvancedGrimoireDescription", "gridItems/advancedGrimoire", new Pos(3, 1)));
        // Third line
        this.addGridItem(new GridItem("gridItemPossessedSponge", "gridItemSpongeName", "gridItemSpongeDescription", "gridItems/sponge", new Pos(0, 2)));
        this.addGridItem(new GridItem("gridItemPossessedShellPowder", "gridItemShellPowderName", "gridItemShellPowderDescription", "gridItems/shellPowder", new Pos(1, 2)));
        this.addGridItem(new GridItem("gridItemPossessedRedSharkFin", "gridItemRedSharkFinName", "gridItemRedSharkFinDescription", "gridItems/redSharkFin", new Pos(2, 2)));
        this.addGridItem(new GridItem("gridItemPossessedBlackMagicGrimoire", "gridItemBlackMagicGrimoireName", "gridItemBlackMagicGrimoireDescription", "gridItems/blackMagicGrimoire", new Pos(3, 2)));
        // Fourth line
        this.addGridItem(new GridItem("gridItemPossessedGreenSharkFin", "gridItemGreenSharkFinName", "gridItemGreenSharkFinDescription", "gridItems/greenSharkFin", new Pos(0, 3)));
        this.addGridItem(new GridItem("gridItemPossessedPurpleSharkFin", "gridItemPurpleSharkFinName", "gridItemPurpleSharkFinDescription", "gridItems/purpleSharkFin", new Pos(1, 3)));
        this.addGridItem(new GridItem("gridItemPossessedHeartPendant", "gridItemHeartPendantName", "gridItemHeartPendantDescription", "gridItems/heartPendant", new Pos(2, 3)));
        this.addGridItem(new GridItem("gridItemPossessedFortressKey", "gridItemFortressKeyName", "gridItemFortressKeyDescription", "gridItems/fortressKey", new Pos(3, 3)));
        // Fifth line
        this.addGridItem(new UnicornHorn("gridItemPossessedUnicornHorn", "gridItemUnicornHornName", "gridItemUnicornHornDescription", "gridItems/unicornHorn", new Pos(0, 4)));
        this.addGridItem(new XinopherydonClaw("gridItemPossessedXinopherydonClaw", "gridItemXinopherydonClawName", "gridItemXinopherydonClawDescription", "gridItems/xinopherydonClaw", new Pos(1, 4)));
        this.addGridItem(new GridItem("gridItemPossessedPitchfork", "gridItemPitchforkName", "gridItemPitchforkDescription", "gridItems/pitchfork", new Pos(2, 4)));
        this.addGridItem(new GridItem("gridItemPossessedTalkingCandy", "gridItemTalkingCandyName", "gridItemTalkingCandyDescription", "gridItems/talkingCandy", new Pos(3, 4)));
        // Sixth line
        this.addGridItem(new GridItem("gridItemPossessedP", "gridItemPName", "gridItemPDescription", "gridItems/p", new Pos(0, 5)));
        this.addGridItem(new GridItem("gridItemPossessedL", "gridItemLName", "gridItemLDescription", "gridItems/l", new Pos(1, 5)));
        this.addGridItem(new GridItem("gridItemPossessedA", "gridItemAName", "gridItemADescription", "gridItems/a", new Pos(2, 5)));
        this.addGridItem(new GridItem("gridItemPossessedY", "gridItemYName", "gridItemYDescription", "gridItems/y", new Pos(3, 5)));
    };
    Game.prototype.displayArea = function (renderArea, scrolling, gap, defaultScroll) {
        if (scrolling === void 0) { scrolling = false; }
        if (gap === void 0) { gap = 0; }
        if (defaultScroll === void 0) { defaultScroll = 0; }
        this.mainContentLocation.render(renderArea);
        this.mainContentLocation.setScrolling(scrolling, defaultScroll);
        if (scrolling == false)
            this.mainContentLocation.setContentGap(gap);
        else
            this.mainContentLocation.setContentGap(0);
    };
    Game.prototype.displayPlace = function () {
        this.displayArea(this.place.getRenderArea(), this.place.getScrolling(), this.place.getGap(), this.place.getDefaultScroll());
    };
    Game.prototype.handleCandiesProduction = function () {
        this.candies.add(Saving.loadNumber("lollipopFarmCurrentCandiesProduction"));
    };
    Game.prototype.handleLollipopProduction = function () {
        // If at least one lollipop is planted
        if (Saving.loadNumber("lollipopFarmLollipopsPlanted") > 0) {
            // If the production is each second
            if (Saving.loadBool("lollipopFarmIsProductionEachSecond")) {
                // We just add the production as lollipops
                this.lollipops.add(Saving.loadNumber("lollipopFarmProduction"));
            }
            else {
                // If it's time for a new production
                if (Saving.loadNumber("lollipopFarmTimeSinceLastProduction") >= Saving.loadNumber("lollipopFarmProduction") - 1) {
                    // We reset the time
                    Saving.saveNumber("lollipopFarmTimeSinceLastProduction", 0);
                    // We add one lollipop
                    this.lollipops.add(1);
                }
                else {
                    // We increase the time
                    Saving.saveNumber("lollipopFarmTimeSinceLastProduction", Saving.loadNumber("lollipopFarmTimeSinceLastProduction") + 1);
                }
            }
        }
    };
    Game.prototype.handlePondConversion = function () {
        // Variables
        var conversionAmount;
        // If the conversion is activated
        if (Saving.loadBool("lollipopFarmPondFeedingLolligators")) {
            // Set the conversion amount
            conversionAmount = Saving.loadNumber("lollipopFarmPondConversionRate");
            // If we don't have enough candies, lower this conversion rate
            if (this.candies.getCurrent() < conversionAmount)
                conversionAmount = this.candies.getCurrent();
            // If the conversionAmount is > 0, we convert
            if (conversionAmount > 0) {
                this.candies.add(-conversionAmount);
                this.lollipops.add(conversionAmount);
            }
        }
    };
    Game.prototype.localAutosave = function () {
        // If local autosave is enabled and there's a local auto save slot and there's a local autosave time
        if (this.localAutosaveEnabled == true && this.localAutosaveSlot != null && this.localAutosaveTime != null) {
            // If it's time to save
            if (this.localAutosaveTime <= 0) {
                // We save
                Saving.save(this, MainLoadingType.LOCAL, this.localAutosaveSlot);
                // We reset the time
                this.setDefaultLocalAutosaveTime();
            }
            else
                this.localAutosaveTime -= 1;
        }
    };
    Game.prototype.questMethod = function () {
        // Re set the timeout, depending on if the time is slowed down or not
        window.setTimeout(this.questMethod.bind(this), ((this.questSlowedDown && this.weAreQuesting) ? 200 : 100 + this.getQuestSpeedUp()));
        // Special place callbacks
        this.questCallbackCollection.fire();
    };
    Game.prototype.oneSecondMethod = function () {
        // Our methods
        this.player.magicHealthRegain();
        this.handleCandiesProduction();
        this.handleLollipopProduction();
        this.handlePondConversion();
        this.localAutosave();
        // Special place callbacks
        this.oneSecondCallbackCollection.fire();
    };
    Game.prototype.resetHotkeys = function () {
        this.hotkeys = {};
    };
    Game.prototype.resetResourcesCallbacks = function () {
        // Reset status bar resources callbacks
        this.candies.getCallbackCollection().reset();
        this.lollipops.getCallbackCollection().reset();
        // Reset other resources callbacks
        this.candiesEaten.getCallbackCollection().reset();
        this.candiesThrown.getCallbackCollection().reset();
        // Reset interval callbacks
        this.oneSecondCallbackCollection.reset();
        this.questCallbackCollection.reset();
    };
    Game.prototype.saveCurrentMapPlace = function () {
        if (this.savedPlace == null)
            this.savedPlace = this.place;
    };
    Game.prototype.setDefaultLocalAutosaveTime = function () {
        this.localAutosaveTime = 600;
    };
    Game.prototype.setPlaceFromSavedMapPlace = function () {
        // If there's a saved place
        if (this.savedPlace != null) {
            this.setPlace(this.savedPlace); // We set the saved place as the current place
            this.savedPlace = null; // There's no saved place anymore
        }
    };
    return Game;
})();
///<reference path="QuestEntity.ts"/>
var GiantNougatMonster = (function (_super) {
    __extends(GiantNougatMonster, _super);
    // Constructor
    function GiantNougatMonster(quest, pos) {
        _super.call(this, quest, pos, new Naming("The giant nougat monster", "the giant nougat monster"), new RenderArea(15, 4), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(1, 0), new Pos(12, 1)), new CollisionBox(this, new Pos(0, 1), new Pos(15, 2)), new CollisionBox(this, new Pos(1, 3), new Pos(12, 1))), new QuestEntityMovement());
        // Set the default step
        this.step = GiantNougatMonsterStep.ASLEEP;
        // Set gravity
        this.getQuestEntityMovement().setGravity(true);
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(2000);
        this.setHp(2000);
        // Set the ascii art and the transparent character
        this.reDrawAscii();
        this.setTransparency(new RenderTransparency(" ", "%"));
    }
    // update()
    GiantNougatMonster.prototype.update = function () {
        // Do something different depending on the current step
        switch (this.step) {
            case GiantNougatMonsterStep.ASLEEP:
                // If we have less then 1577 hp (1577 was the number of bytes of the wikipedia article "Nougat" on the fifth of november, 2005 according to the article revision history. See here : https://en.wikipedia.org/w/index.php?title=Nougat&oldid=27465563)
                if (this.getHp() < 1577) {
                    // We go to awake mode
                    this.step = GiantNougatMonsterStep.AWAKE;
                    this.reDrawAscii(); // Re draw the ascii art
                    this.addWeapon(); // Add the weapon
                }
                break;
            case GiantNougatMonsterStep.AWAKE:
                // If we have less than 500 hp
                if (this.getHp() < 500) {
                    // We go to angry mode
                    this.step = GiantNougatMonsterStep.ANGRY;
                    this.reDrawAscii(); // Re draw the ascii art
                }
                // Go towards the player (speed : 1)
                this.goTowards(this.getGlobalPosition().plus(new Pos(6, 2)), this.getQuest().getGame().getPlayer().getGlobalPosition().plus(new Pos(1, 0)), 0, new Pos(1, 0));
                break;
            case GiantNougatMonsterStep.ANGRY:
                // Go towards the player (speed : 3)
                this.goTowards(this.getGlobalPosition().plus(new Pos(6, 2)), this.getQuest().getGame().getPlayer().getGlobalPosition().plus(new Pos(1, 0)), 0, new Pos(3, 0));
                break;
        }
        // Call the mother class update method
        _super.prototype.update.call(this);
    };
    // willDie()
    GiantNougatMonster.prototype.willDie = function () {
        this.getQuest().getGame().getQuestLog().addMessage(new QuestLogMessage(this.getDeathMessage() + " (and found " + Algo.pluralFormat(this.getQuest().foundCandies(Random.upTo(123456)), " candy", " candies") + ")", this.getQuest().getCandiesFoundMessage()));
    };
    // Private methods
    GiantNougatMonster.prototype.addWeapon = function () {
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("Nougat", "nougat"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(17, 6))), 3000));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setBetweenDelay(20, 40);
    };
    GiantNougatMonster.prototype.reDrawAscii = function () {
        // Draw a different ascii art depending on the step
        switch (this.step) {
            case GiantNougatMonsterStep.ASLEEP:
                this.getRenderArea().drawArray(Database.getAscii("places/quests/giantNougatMonster/monster"));
                break;
            case GiantNougatMonsterStep.AWAKE:
                this.getRenderArea().drawArray(Database.getAscii("places/quests/giantNougatMonster/monsterAwake"));
                break;
            case GiantNougatMonsterStep.ANGRY:
                this.getRenderArea().drawArray(Database.getAscii("places/quests/giantNougatMonster/monsterAngry"));
                break;
        }
    };
    return GiantNougatMonster;
})(QuestEntity);
///<reference path="Quest.ts"/>
var GiantNougatMonsterQuest = (function (_super) {
    __extends(GiantNougatMonsterQuest, _super);
    // Constructor
    function GiantNougatMonsterQuest(game) {
        _super.call(this, game);
        // Resize the quest
        this.resizeQuest(100, 20);
        // Add collision boxes around
        this.addPlayerCollisionBoxes(true, true, true, true);
        // Add the player
        this.getGame().getPlayer().loadCandyBoxCharacter(this);
        this.getGame().getPlayer().setGlobalPosition(new Pos(0, 19));
        this.configPlayerOrClone(this.getGame().getPlayer());
        this.addEntity(this.getGame().getPlayer());
        // Add the walls
        this.addWalls();
        // Add the monster
        this.addMonster();
        // Add the message
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You attack the giant nougat monster. It seems to be asleep."));
    }
    // Public methods
    GiantNougatMonsterQuest.prototype.configPlayerOrClone = function (entity) {
        entity.setQuestEntityMovement(new QuestEntityMovement(new Pos(1, 0)));
        entity.getQuestEntityMovement().setGravity(true);
        entity.getQuestEntityMovement().setWormsLike(true);
    };
    GiantNougatMonsterQuest.prototype.endQuest = function (win) {
        // We add some messages
        if (win) {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You killed the giant nougat monster and gained access to the tower!"));
            Saving.saveBool("castleKilledNougatMonster", true);
        }
        else
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You failed."));
        // We call the endQuest method of our mother class
        _super.prototype.endQuest.call(this, win);
    };
    GiantNougatMonsterQuest.prototype.update = function () {
        if (this.getQuestEnded() == false) {
            // Test if the player won the quest, if so, end the quest and return
            if (this.thePlayerWon()) {
                this.endQuest(true);
                return;
            }
            // Test if the player is dead, if so, end the quest and return
            if (this.getGame().getPlayer().shouldDie()) {
                this.endQuest(false);
                return;
            }
            // Update entities
            this.updateEntities();
        }
        // Draw
        this.preDraw();
        this.drawEntities();
        this.drawAroundQuest();
        if (this.getQuestEnded() == false)
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestNoKeeping");
        else if (this.getQuestEndedAndWeWon() == false)
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestNoKeepingBecauseLose");
        else
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestKeeping");
        this.postDraw();
    };
    // Private methods
    GiantNougatMonsterQuest.prototype.addMonster = function () {
        this.giantNougatMonster = new GiantNougatMonster(this, new Pos(78, 16));
        this.giantNougatMonster.setHealthBar(new QuestEntityHealthBar(this.giantNougatMonster, new Pos(100, 1), new Pos(0, 0), QuestEntityHealthBarPositionType.FIXED_ON_PAGE, true, true, BarType.HEALTH));
        this.addEntity(this.giantNougatMonster);
    };
    GiantNougatMonsterQuest.prototype.addWalls = function () {
        // Create the wall entity
        var wall = new Wall(this, new Pos(-20, 20));
        // Add the boxes
        wall.addBox(new Pos(0, 0), new Pos(140, 1));
        // Add the wall entity
        this.addEntity(wall);
    };
    GiantNougatMonsterQuest.prototype.thePlayerWon = function () {
        if (this.giantNougatMonster.shouldDie())
            return true;
        return false;
    };
    return GiantNougatMonsterQuest;
})(Quest);
var GiantNougatMonsterStep;
(function (GiantNougatMonsterStep) {
    GiantNougatMonsterStep[GiantNougatMonsterStep["ASLEEP"] = 0] = "ASLEEP";
    GiantNougatMonsterStep[GiantNougatMonsterStep["AWAKE"] = 1] = "AWAKE";
    GiantNougatMonsterStep[GiantNougatMonsterStep["ANGRY"] = 2] = "ANGRY";
})(GiantNougatMonsterStep || (GiantNougatMonsterStep = {}));
///<reference path="EqItem.ts"/>
var GiantSpoon = (function (_super) {
    __extends(GiantSpoon, _super);
    // Constructor
    function GiantSpoon() {
        _super.call(this, "eqItemWeaponGiantSpoon", "eqItemWeaponGiantSpoonName", "eqItemWeaponGiantSpoonDescription", "eqItems/weapons/giantSpoon");
    }
    // Public getters
    GiantSpoon.prototype.getQuestEntityWeapon = function (quest, player) {
        var qew = new QuestEntityWeapon(quest, player, new Naming("A giant spoon", "a giant spoon"), player.getClassicCollisionBoxCollection(), 70);
        qew.getCloseCombatDelay().setFixedDelay(7, 0);
        return qew;
    };
    return GiantSpoon;
})(EqItem);
///<reference path="EqItem.ts"/>
var GiantSpoonOfDoom = (function (_super) {
    __extends(GiantSpoonOfDoom, _super);
    // Constructor
    function GiantSpoonOfDoom() {
        _super.call(this, "eqItemWeaponGiantSpoonOfDoom", "eqItemWeaponGiantSpoonOfDoomName", "eqItemWeaponGiantSpoonOfDoomDescription", "eqItems/weapons/giantSpoonOfDoom");
    }
    // Public getters
    GiantSpoonOfDoom.prototype.getQuestEntityWeapon = function (quest, player) {
        var qew = new QuestEntityWeapon(quest, player, new Naming("The giant Spoon of Doom", "the giant Spoon of Doom"), player.getClassicCollisionBoxCollection(), 315);
        qew.getCloseCombatDelay().setFixedDelay(14, 0);
        return qew;
    };
    return GiantSpoonOfDoom;
})(EqItem);
///<reference path="Quest.ts"/>
var Hell = (function (_super) {
    __extends(Hell, _super);
    // Constructor
    function Hell(game) {
        _super.call(this, game);
        // Resize the quest
        this.resizeQuest(150, 30);
        // Add collision boxes around
        this.addPlayerCollisionBoxes(true, true, true, true);
        // Add the player
        this.getGame().getPlayer().loadCandyBoxCharacter(this);
        this.getGame().getPlayer().setGlobalPosition(new Pos(0, 23));
        this.configPlayerOrClone(this.getGame().getPlayer());
        this.addEntity(this.getGame().getPlayer());
        // Add the floor
        this.addFloor(0, 20);
        // Add the lava entities
        this.addLava(new Pos(53, 27), new Pos(20, 2));
        this.addLava(new Pos(92, 27), new Pos(16, 2));
        // Add the devil
        this.addDevil(new Pos(130, 2));
        // Add Camazotz
        this.addCamazotz(new Pos(Random.between(70, 100), 2));
        // Add the message
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You enter Hell."));
    }
    // Public methods
    Hell.prototype.castPlayerTeleport = function () {
        _super.prototype.castPlayerTeleport.call(this, new Pos(0, 0), new Pos(20, 21));
    };
    Hell.prototype.configPlayerOrClone = function (entity) {
        entity.setQuestEntityMovement(new QuestEntityMovement(new Pos(1, 0)));
        entity.getQuestEntityMovement().setGravity(true);
        entity.getQuestEntityMovement().setWormsLike(true);
    };
    Hell.prototype.endQuest = function (win) {
        // We add some messages
        if (win) {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You managed to beat the devil itself!"));
        }
        else {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You died in Hell. Your soul will wander here for all eternity."));
        }
        // We call the endQuest method of our mother class
        _super.prototype.endQuest.call(this, win);
    };
    Hell.prototype.update = function () {
        if (this.getQuestEnded() == false) {
            // Test if the player won the quest, if so, end the quest and return
            if (this.thePlayerWon()) {
                this.endQuest(true);
                return;
            }
            // Test if the player is dead, if so, end the quest and return
            if (this.getGame().getPlayer().shouldDie()) {
                this.endQuest(false);
                return;
            }
            // Update entities
            this.updateEntities();
        }
        // Draw
        this.preDraw();
        this.drawBackground(0, 20);
        this.drawEntities();
        this.drawAroundQuest();
        if (this.getQuestEnded() == false)
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestNoKeeping");
        else if (this.getQuestEndedAndWeWon() == false)
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestNoKeepingBecauseLose");
        else
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestKeeping");
        this.postDraw();
    };
    // Private methods
    Hell.prototype.addCamazotz = function (pos) {
        var camazotz;
        camazotz = new Camazotz(this, pos);
        camazotz.setHealthBar(new QuestEntityHealthBar(camazotz, new Pos(22, 1), new Pos(0, 0)));
        this.addEntity(camazotz);
    };
    Hell.prototype.addDevil = function (pos) {
        this.devil = new Devil(this, pos, 2, 19);
        this.devil.setHealthBar(new QuestEntityHealthBar(this.devil, new Pos(100, 1), new Pos(0, 0), QuestEntityHealthBarPositionType.FIXED_ON_PAGE, true, true, BarType.HEALTH));
        this.addEntity(this.devil);
    };
    Hell.prototype.addFloor = function (x, y) {
        // Create the wall entity
        var wall = new Wall(this, new Pos(x, y));
        // Add the floor
        wall.addBox(new Pos(0, 4), new Pos(53, 6));
        wall.addBox(new Pos(73, 4), new Pos(19, 6));
        wall.addBox(new Pos(108, 4), new Pos(42, 6));
        wall.addBox(new Pos(0, 9), new Pos(150, 1));
        // Add the wall entity
        this.addEntity(wall);
    };
    Hell.prototype.addLava = function (pos, size) {
        this.addEntity(new Lava(this, pos, size));
    };
    Hell.prototype.drawBackground = function (x, y) {
        // Draw the ascii
        this.getRenderArea().drawArray(Database.getAscii("places/quests/hell/background"), this.getRealQuestPosition().x + x, this.getRealQuestPosition().y + y);
        // Add the red color for the first lava pit
        this.drawLava(x + 55, x + 71, y + 4);
        this.drawLava(x + 54, x + 72, y + 5);
        this.drawLava(x + 53, x + 73, y + 6);
        this.drawLava(x + 52, x + 74, y + 7);
        this.drawLava(x + 51, x + 75, y + 8);
        this.drawLava(x + 51, x + 75, y + 9);
        // Same thing for the second pit
        this.drawLava(x + 94, x + 106, y + 4);
        this.drawLava(x + 93, x + 107, y + 5);
        this.drawLava(x + 92, x + 108, y + 6);
        this.drawLava(x + 91, x + 109, y + 7);
        this.drawLava(x + 90, x + 110, y + 8);
        this.drawLava(x + 90, x + 110, y + 9);
    };
    Hell.prototype.drawLava = function (x1, x2, y) {
        this.getRenderArea().addBackgroundColor(this.getRealQuestPosition().x + x1, this.getRealQuestPosition().x + x2, this.getRealQuestPosition().y + y, new Color(ColorType.HELL_RED_LAVA));
    };
    Hell.prototype.thePlayerWon = function () {
        // If the devil is dead, we return true
        if (this.devil.shouldDie() == true)
            return true;
        // Else we return false
        return false;
    };
    return Hell;
})(Quest);
var Hotkey = (function () {
    // Constructor
    function Hotkey(keyString, callbackCollection) {
        this.pressed = false; // Is this hotkey pressed ?
        // Set the key string
        this.keyString = keyString;
        // Handle special keys
        switch (this.keyString) {
            case "up":
                this.key = 38;
                break;
            case "down":
                this.key = 40;
                break;
            case "left":
                this.key = 37;
                break;
            case "right":
                this.key = 39;
                break;
            case "space":
                this.key = 32;
                break;
            case "enter":
                this.key = 13;
                break;
            case "delete":
                this.key = 8;
                break;
            case "numpad0":
                this.key = 96;
                break;
            case "numpad1":
                this.key = 97;
                break;
            case "numpad2":
                this.key = 98;
                break;
            case "numpad3":
                this.key = 99;
                break;
            case "numpad4":
                this.key = 100;
                break;
            case "numpad5":
                this.key = 101;
                break;
            case "numpad6":
                this.key = 102;
                break;
            case "numpad7":
                this.key = 103;
                break;
            case "numpad8":
                this.key = 104;
                break;
            case "numpad9":
                this.key = 105;
                break;
            default:
                this.key = this.keyString.toUpperCase().charCodeAt(0);
                break; // We convert to upper case to please our great jQuery master
        }
        this.callbackCollection = callbackCollection;
    }
    // Public getters
    Hotkey.prototype.getCallbackCollection = function () {
        return this.callbackCollection;
    };
    Hotkey.prototype.getKey = function () {
        return this.key;
    };
    Hotkey.prototype.getKeyString = function () {
        return this.keyString;
    };
    Hotkey.prototype.getPressed = function () {
        return this.pressed;
    };
    // Public setters
    Hotkey.prototype.setPressed = function (pressed) {
        this.pressed = pressed;
    };
    return Hotkey;
})();
///<reference path="Place.ts"/>
var InsideFortress = (function (_super) {
    __extends(InsideFortress, _super);
    // Constructor
    function InsideFortress(game) {
        _super.call(this, game);
        // The render area
        this.renderArea = new RenderArea();
        this.renderArea.resizeFromArray(Database.getAscii("places/fortress/inside"), 0, 4);
        this.update();
    }
    // getRenderArea()
    InsideFortress.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // Private methods
    InsideFortress.prototype.addFirstDoorButton = function (x, y) {
        // Add the button
        this.renderArea.addMultipleAsciiButtons("fortressInsideFirstDoorButton", x + 11, x + 14, y, x + 7, x + 14, y + 1, x + 3, x + 14, y + 2, x, x + 14, y + 3, x, x + 14, y + 4, x, x + 14, y + 5, x, x + 14, y + 6, x, x + 14, y + 7, x, x + 14, y + 8, x, x + 14, y + 9, x, x + 14, y + 10, x, x + 14, y + 11, x, x + 14, y + 12, x, x + 14, y + 13, x, x + 14, y + 14, x, x + 14, y + 15, x, x + 14, y + 16, x, x + 14, y + 17, x, x + 10, y + 18, x, x + 6, y + 19, x, x + 2, y + 20, x, x + 1, y + 21);
        // Add the link
        this.renderArea.addLinkCall(".fortressInsideFirstDoorButton", new CallbackCollection(this.goToFirstRoom.bind(this)));
    };
    InsideFortress.prototype.addSecondDoorButton = function (x, y) {
        // Add the button
        this.renderArea.addMultipleAsciiButtons("fortressInsideSecondDoorButton", x, x + 15, y, x, x + 15, y + 1, x, x + 15, y + 2, x, x + 15, y + 3, x, x + 15, y + 4, x, x + 15, y + 5, x, x + 15, y + 6, x, x + 15, y + 7, x, x + 15, y + 8, x, x + 15, y + 9, x, x + 15, y + 10, x, x + 15, y + 11, x, x + 15, y + 12, x, x + 15, y + 13, x, x + 15, y + 14, x, x + 15, y + 15, x, x + 15, y + 16, x, x + 15, y + 17);
        // Add the link
        this.renderArea.addLinkCall(".fortressInsideSecondDoorButton", new CallbackCollection(this.goToSecondRoom.bind(this)));
    };
    InsideFortress.prototype.addThirdDoorButton = function (x, y) {
        // Add the button
        this.renderArea.addMultipleAsciiButtons("fortressInsideThirdDoorButton", x, x + 3, y, x, x + 7, y + 1, x, x + 11, y + 2, x, x + 14, y + 3, x, x + 14, y + 4, x, x + 14, y + 5, x, x + 14, y + 6, x, x + 14, y + 7, x, x + 14, y + 8, x, x + 14, y + 9, x, x + 14, y + 10, x, x + 14, y + 11, x, x + 14, y + 12, x, x + 14, y + 13, x, x + 14, y + 14, x, x + 14, y + 15, x, x + 14, y + 16, x, x + 14, y + 17, x + 4, x + 14, y + 18, x + 8, x + 14, y + 19, x + 12, x + 14, y + 20, x + 13, x + 14, y + 21);
        // Add the link
        this.renderArea.addLinkCall(".fortressInsideThirdDoorButton", new CallbackCollection(this.goToThirdRoom.bind(this)));
    };
    InsideFortress.prototype.goToFirstRoom = function () {
        if (this.getGame().canStartQuest())
            this.getGame().setPlace(new FortressRoom1(this.getGame()));
    };
    InsideFortress.prototype.goToSecondRoom = function () {
        if (this.getGame().canStartQuest())
            this.getGame().setPlace(new FortressRoom2(this.getGame()));
    };
    InsideFortress.prototype.goToThirdRoom = function () {
        if (this.getGame().canStartQuest())
            this.getGame().setPlace(new FortressRoom3(this.getGame()));
    };
    InsideFortress.prototype.update = function () {
        // Erase everything
        this.renderArea.resetAllButSize();
        // Back to the map button
        this.addBackToMainMapButton(this.renderArea, "insideFortressBackToTheMapButton");
        // Draw the ascii
        this.renderArea.drawArray(Database.getAscii("places/fortress/inside"), 0, 3);
        // Add the text
        this.renderArea.drawString(Database.getText("fortressInsideText0"), 22, 29);
        this.renderArea.drawString(Database.getText("fortressInsideText1"), 22, 30);
        this.renderArea.drawString(Database.getText("fortressInsideText2"), 22, 31);
        // Add the translated text
        this.renderArea.drawString(Database.getTranslatedText("fortressInsideText0"), 22, 33, true);
        this.renderArea.drawString(Database.getTranslatedText("fortressInsideText1"), 22, 34, true);
        this.renderArea.drawString(Database.getTranslatedText("fortressInsideText2"), 22, 35, true);
        // Add the doors buttons
        this.addFirstDoorButton(8, 10);
        this.addSecondDoorButton(42, 8);
        this.addThirdDoorButton(78, 10);
    };
    return InsideFortress;
})(Place);
///<reference path="Place.ts"/>
var InsideYourBox = (function (_super) {
    __extends(InsideYourBox, _super);
    // Constructor
    function InsideYourBox(game) {
        _super.call(this, game);
        // The render area
        this.renderArea = new RenderArea();
        // The sweets
        this.sweets = [];
        // Launch the interval
        this.intervalID = setInterval(this.actionInterval.bind(this), 100);
        // Resize and update
        this.renderArea.resize(100, 40);
        this.update();
    }
    // getRenderArea()
    InsideYourBox.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // willStopBeingDisplayed()
    InsideYourBox.prototype.willStopBeingDisplayed = function () {
        clearInterval(this.intervalID);
    };
    // Private methods
    InsideYourBox.prototype.actionInterval = function () {
        // Update
        this.update();
        this.getGame().updatePlace();
    };
    InsideYourBox.prototype.update = function () {
        // Erase everything
        this.renderArea.resetAllButSize();
        // Add a sweet
        this.sweets.push(new InsideYourBoxSweet());
        // Update the sweets and delete the one which need to be deleted
        for (var i = 0; i < this.sweets.length; i++) {
            if (this.sweets[i].update()) {
                this.sweets.splice(i, 1);
                i--;
            }
        }
        // Draw the sweets
        for (var i = 0; i < this.sweets.length; i++) {
            this.sweets[i].draw(this.renderArea);
        }
        // Draw the text
        this.renderArea.drawArray(Database.getAscii("general/insideYourBox/text"), 0, 5, new RenderTransparency(" ", "%"));
    };
    return InsideYourBox;
})(Place);
var InsideYourBoxSweet = (function () {
    // Constructor
    function InsideYourBoxSweet() {
        // Set the ascii art name
        this.asciiArt = "general/insideYourBox/" + Random.between(0, 10);
        // Set the position
        this.pos = new Pos(-Database.getAsciiWidth(this.asciiArt) + Random.between(0, 99 + Database.getAsciiWidth(this.asciiArt)), -Database.getAsciiHeight(this.asciiArt));
        // Set the speed
        this.speed = Random.between(1, 3);
    }
    // Public methods
    InsideYourBoxSweet.prototype.draw = function (renderArea) {
        // Draw the ascii art at the right position
        renderArea.drawArray(Database.getAscii(this.asciiArt), this.pos.x, this.pos.y);
    };
    InsideYourBoxSweet.prototype.update = function () {
        // If we're out of the screen, we return true
        if (this.pos.y >= 40)
            return true;
        // Increase the speed
        this.speed += 0.3;
        // Increase the position
        this.pos.y += Math.floor(this.speed);
    };
    return InsideYourBoxSweet;
})();
///<reference path="Place.ts"/>
var Inventory = (function (_super) {
    __extends(Inventory, _super);
    // Constructor
    function Inventory(game) {
        _super.call(this, game);
        // Render area
        this.renderArea = new RenderArea();
        // Resize the area
        this.renderArea.resize(99, 136);
        // Update
        this.update();
    }
    // Public methods
    Inventory.prototype.update = function () {
        // yGap, can increase depending on the stats panel
        var yGap = 0;
        // Erase everything
        this.renderArea.resetAllButSize();
        // Draw the inventory top
        this.renderArea.drawArray(Database.getAscii("general/inventoryTop"));
        // Draw equipment
        this.drawEquipment();
        // Draw statistics
        yGap += this.drawStats(0, 52);
        // Draw the inventory bottom
        this.renderArea.drawArray(Database.getAscii("general/inventoryBottom"), 0, 55 + yGap);
        // Draw items
        this.drawGridItems(4, 57 + yGap);
    };
    // getRenderArea()
    Inventory.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // Private methods
    Inventory.prototype.createArrayFromEqItemsArrayForRenderAreaList = function (eqItemsArray, nothingId) {
        // Create the array
        var arr = [];
        // Add the "Nothing" item
        arr.push(nothingId);
        arr.push(Database.getText("inventorySpecialNothingEqItem") + (Database.getTranslatedText("inventorySpecialNothingEqItem") == "" ? "" : " (" + Database.getTranslatedText("inventorySpecialNothingEqItem") + ")"));
        // Fill the array with eqItems
        for (var savingName in eqItemsArray) {
            if (eqItemsArray[savingName].isPossessed()) {
                arr.push(savingName);
                arr.push(Database.getText(eqItemsArray[savingName].getDatabaseName()) + (Database.getTranslatedText(eqItemsArray[savingName].getDatabaseName()) == "" ? "" : " (" + Database.getTranslatedText(eqItemsArray[savingName].getDatabaseName()) + ")"));
            }
        }
        // Return the array
        return arr;
    };
    Inventory.prototype.disableAllLists = function () {
        $("#inventoryWeaponsList").prop("disabled", true);
        $("#inventoryHatsList").prop("disabled", true);
        $("#inventoryBodyArmoursList").prop("disabled", true);
        $("#inventoryGlovesList").prop("disabled", true);
        $("#inventoryBootsList").prop("disabled", true);
    };
    Inventory.prototype.drawEqItem = function (eqItem, pos, size) {
        // If the eqItem isn't null
        if (eqItem != null) {
            this.renderArea.drawArray(Database.getAscii(eqItem.getAscii()), Math.floor(pos.x + size.x / 2 - Database.getAsciiWidth(eqItem.getAscii()) / 2), Math.floor(pos.y + size.y / 2 - Database.getAsciiHeight(eqItem.getAscii()) / 2), null, eqItem.getSavingName() + "OnHover");
            // Add the tooltip
            this.renderArea.addTooltip(eqItem.getSavingName() + "Tooltip", Database.getText(eqItem.getDatabaseDescriptionName()) + (Database.getTranslatedText(eqItem.getDatabaseDescriptionName()) != "" ? "<br/><br/><i>" + Database.getTranslatedText(eqItem.getDatabaseDescriptionName()) + "</i>" : ""));
            // Add the link
            this.renderArea.addLinkOnHoverShowTooltip("." + eqItem.getSavingName() + "OnHover", "." + eqItem.getSavingName() + "Tooltip");
        }
    };
    Inventory.prototype.drawEquipment = function () {
        // Add backgrounds and lists
        var arr;
        // Weapon
        arr = this.createArrayFromEqItemsArrayForRenderAreaList(this.getGame().getWeapons(), "inventorySpecialNothingWeapon");
        if (arr.length > 2)
            this.renderArea.addList(8, 38, 15, "inventoryWeaponsList", new CallbackCollection(this.selectedEqItem.bind(this)), arr);
        // Hat
        arr = this.createArrayFromEqItemsArrayForRenderAreaList(this.getGame().getHats(), "inventorySpecialNothingHat");
        if (arr.length > 2) {
            this.renderArea.drawArray(Database.getAscii("general/inventoryHat"), 59, 12);
            this.renderArea.addList(61, 93, 14, "inventoryHatsList", new CallbackCollection(this.selectedEqItem.bind(this)), arr);
        }
        // Body armour
        arr = this.createArrayFromEqItemsArrayForRenderAreaList(this.getGame().getBodyArmours(), "inventorySpecialNothingBodyArmour");
        if (arr.length > 2) {
            this.renderArea.drawArray(Database.getAscii("general/inventoryBodyArmour"), 59, 25);
            this.renderArea.addList(61, 78, 27, "inventoryBodyArmoursList", new CallbackCollection(this.selectedEqItem.bind(this)), arr);
        }
        // Gloves
        arr = this.createArrayFromEqItemsArrayForRenderAreaList(this.getGame().getGloves(), "inventorySpecialNothingGloves");
        if (arr.length > 2) {
            this.renderArea.drawArray(Database.getAscii("general/inventoryGloves"), 82, 25);
            this.renderArea.addList(84, 93, 27, "inventoryGlovesList", new CallbackCollection(this.selectedEqItem.bind(this)), arr);
        }
        // Boots
        arr = this.createArrayFromEqItemsArrayForRenderAreaList(this.getGame().getBoots(), "inventorySpecialNothingBoots");
        if (arr.length > 2) {
            this.renderArea.drawArray(Database.getAscii("general/inventoryBoots"), 59, 38);
            this.renderArea.addList(61, 93, 40, "inventoryBootsList", new CallbackCollection(this.selectedEqItem.bind(this)), arr);
        }
        // Add links which will call callbacks after the html dom is created
        this.renderArea.addLinkCallbackCollection(new CallbackCollection(this.selectRightEqItems.bind(this))); // Select the right items
        if (this.getGame().getWeAreQuesting() == true)
            this.renderArea.addLinkCallbackCollection(new CallbackCollection(this.disableAllLists.bind(this))); // Disable all the lists
        // Draw the eqItems
        this.drawEqItem(this.getGame().getSelectedEqItems()["weapon"], new Pos(7, 16), new Pos(32, 33));
        this.drawEqItem(this.getGame().getSelectedEqItems()["hat"], new Pos(60, 16), new Pos(34, 8));
        this.drawEqItem(this.getGame().getSelectedEqItems()["bodyArmour"], new Pos(60, 28), new Pos(19, 8));
        this.drawEqItem(this.getGame().getSelectedEqItems()["gloves"], new Pos(83, 28), new Pos(11, 8));
        this.drawEqItem(this.getGame().getSelectedEqItems()["boots"], new Pos(60, 41), new Pos(34, 8));
    };
    Inventory.prototype.drawGridItem = function (gridItem, x, y) {
        // Draw the ascii art
        this.renderArea.drawArray(Database.getAscii(gridItem.getAscii()), x + gridItem.getPosition().x * 23 + Math.floor(23 / 2 - Database.getAsciiWidth(gridItem.getAscii()) / 2), y + gridItem.getPosition().y * 12 + Math.floor(11 / 2 - Database.getAsciiHeight(gridItem.getAscii()) / 2), null, gridItem.getSavingName() + "OnHover");
        // Add the tooltip
        this.renderArea.addTooltip(gridItem.getSavingName() + "Tooltip", "<b>" + Database.getText(gridItem.getDatabaseName()) + "</b><br/>" + Database.getText(gridItem.getDatabaseDescriptionName()) + (Database.getTranslatedText(gridItem.getDatabaseDescriptionName()) != "" ? "<br/><br/><i><b>" + Database.getTranslatedText(gridItem.getDatabaseName()) + "</b><br/>" + Database.getTranslatedText(gridItem.getDatabaseDescriptionName()) + "</i>" : ""));
        // Add the link
        this.renderArea.addLinkOnHoverShowTooltip("." + gridItem.getSavingName() + "OnHover", "." + gridItem.getSavingName() + "Tooltip");
    };
    Inventory.prototype.drawGridItems = function (x, y) {
        for (var savingName in this.getGame().getGridItems()) {
            // If we possess this item, we draw it
            if (this.getGame().getGridItems()[savingName].isPossessed())
                this.drawGridItem(this.getGame().getGridItems()[savingName], x, y);
        }
    };
    Inventory.prototype.drawStats = function (x, y) {
        // Set the additional damage text
        var additionalDamageText;
        if (Saving.loadBool("gridItemPossessedXinopherydonClaw") && (this.getGame().getSelectedEqItems()["bodyArmour"] != null && this.getGame().getSelectedEqItems()["bodyArmour"].getSavingName() == "eqItemBodyArmoursEnchantedKnightBodyArmour"))
            additionalDamageText = "";
        else if (Saving.loadBool("gridItemPossessedXinopherydonClaw"))
            additionalDamageText = " x 2";
        else if ((this.getGame().getSelectedEqItems()["bodyArmour"] != null && this.getGame().getSelectedEqItems()["bodyArmour"].getSavingName() == "eqItemBodyArmoursEnchantedKnightBodyArmour"))
            additionalDamageText = " / 2";
        else
            additionalDamageText = "";
        // This array will contain the special abilities
        var specialAbilities = [];
        // First line
        this.renderArea.drawString(this.getGame().getPlayer().getMaxHp().toString(), x + 16, y); // player's maximum HP
        this.renderArea.drawString(this.getGame().getPlayer().getQuestEntityWeapon().getRealDamageText() + additionalDamageText, x + 43, y); // weapon damage
        this.renderArea.drawString(this.getGame().getPlayer().getQuestEntityWeapon().getSpeedText(), x + 71, y); // weapon speed
        // Fill the special abilities array with grid items abilities
        for (var savingName in this.getGame().getGridItems()) {
            // If we possess this item
            if (this.getGame().getGridItems()[savingName].isPossessed()) {
                // If it has a special ability, we add it
                if (this.getGame().getGridItems()[savingName].getSpecialAbility() != null)
                    specialAbilities.push(this.getGame().getGridItems()[savingName].getSpecialAbility());
            }
        }
        // Fill the special abilities array with eq items abilities
        if (this.getGame().getSelectedEqItems()["weapon"] != null && this.getGame().getSelectedEqItems()["weapon"].getSpecialAbility() != null)
            specialAbilities.push(this.getGame().getSelectedEqItems()["weapon"].getSpecialAbility());
        if (this.getGame().getSelectedEqItems()["hat"] != null && this.getGame().getSelectedEqItems()["hat"].getSpecialAbility() != null)
            specialAbilities.push(this.getGame().getSelectedEqItems()["hat"].getSpecialAbility());
        if (this.getGame().getSelectedEqItems()["bodyArmour"] != null && this.getGame().getSelectedEqItems()["bodyArmour"].getSpecialAbility() != null)
            specialAbilities.push(this.getGame().getSelectedEqItems()["bodyArmour"].getSpecialAbility());
        if (this.getGame().getSelectedEqItems()["gloves"] != null && this.getGame().getSelectedEqItems()["gloves"].getSpecialAbility() != null)
            specialAbilities.push(this.getGame().getSelectedEqItems()["gloves"].getSpecialAbility());
        if (this.getGame().getSelectedEqItems()["boots"] != null && this.getGame().getSelectedEqItems()["boots"].getSpecialAbility() != null)
            specialAbilities.push(this.getGame().getSelectedEqItems()["boots"].getSpecialAbility());
        // Fill the special abilities with gifts
        if (Saving.loadNumber("gameGiftPower") > 0) {
            specialAbilities.push("GIFT : your attacks are " + (Saving.loadNumber("gameGiftPower") * 20).toString() + "% more powerful.");
        }
        if (Saving.loadNumber("gameGiftHealth") > 0) {
            specialAbilities.push("GIFT : you have " + (Saving.loadNumber("gameGiftHealth") * 20).toString() + "% more health points.");
        }
        if (Saving.loadNumber("gameGiftMagic") > 0) {
            specialAbilities.push("GIFT : the spell and potion countdowns are reduced by " + (Saving.loadNumber("gameGiftMagic") * 15) + "%.");
        }
        // If the special abilities array is empty, add the "no special ability" text
        if (specialAbilities.length == 0)
            specialAbilities.push("You have no special ability.");
        // Draw the special abilities
        for (var i = 0; i < specialAbilities.length; i++) {
            // If it's not the first one, we draw the background
            if (i != 0) {
                this.renderArea.drawArray(Database.getAscii("general/specialAbilityBackground"), x, y + 2 + i);
            }
            // We draw the special ability
            this.renderArea.drawString(specialAbilities[i], x + 7, y + 2 + i);
        }
        // We return the height added by the drawing of the special abilities
        return specialAbilities.length - 1;
    };
    Inventory.prototype.selectedEqItem = function () {
        // Set the eqItems
        if ($("#inventoryWeaponsList").length)
            Saving.saveString("gameWeaponSelected", $("#inventoryWeaponsList").find(":selected").attr("id"));
        else
            Saving.saveString("gameWeaponSelected", "inventorySpecialNothingWeapon");
        if ($("#inventoryHatsList").length)
            Saving.saveString("gameHatSelected", $("#inventoryHatsList").find(":selected").attr("id"));
        else
            Saving.saveString("gameHatSelected", "inventorySpecialNothingHat");
        if ($("#inventoryBodyArmoursList").length)
            Saving.saveString("gameBodyArmourSelected", $("#inventoryBodyArmoursList").find(":selected").attr("id"));
        else
            Saving.saveString("gameBodyArmourSelected", "inventorySpecialNothingBodyArmour");
        if ($("#inventoryGlovesList").length)
            Saving.saveString("gameGlovesSelected", $("#inventoryGlovesList").find(":selected").attr("id"));
        else
            Saving.saveString("gameGlovesSelected", "inventorySpecialNothingGloves");
        if ($("#inventoryBootsList").length)
            Saving.saveString("gameBootsSelected", $("#inventoryBootsList").find(":selected").attr("id"));
        else
            Saving.saveString("gameBootsSelected", "inventorySpecialNothingBoots");
        // Fill the selected eqItems array
        this.getGame().emptyAndFillSelectedEqItemsArray();
        // Re calculate the player max hp, because it may have changed
        this.getGame().getPlayer().reCalcMaxHp();
        // Update inventory
        this.update();
        this.getGame().updatePlace();
    };
    Inventory.prototype.selectRightEqItems = function () {
        // We select the right eqItems
        $("#" + Saving.loadString("gameWeaponSelected")).prop('selected', true);
        $("#" + Saving.loadString("gameHatSelected")).prop('selected', true);
        $("#" + Saving.loadString("gameBodyArmourSelected")).prop('selected', true);
        $("#" + Saving.loadString("gameGlovesSelected")).prop('selected', true);
        $("#" + Saving.loadString("gameBootsSelected")).prop('selected', true);
    };
    return Inventory;
})(Place);
///<reference path="EqItem.ts"/>
var IronAxe = (function (_super) {
    __extends(IronAxe, _super);
    // Constructor
    function IronAxe() {
        _super.call(this, "eqItemWeaponIronAxe", "eqItemWeaponIronAxeName", "eqItemWeaponIronAxeDescription", "eqItems/weapons/ironAxe");
    }
    // Public getters
    IronAxe.prototype.getQuestEntityWeapon = function (quest, player) {
        var qew = new QuestEntityWeapon(quest, player, new Naming("An iron axe", "an iron axe"), player.getClassicCollisionBoxCollection(), 3);
        qew.getCloseCombatDelay().setFixedDelay(3, 0);
        return qew;
    };
    return IronAxe;
})(EqItem);
///<reference path="QuestEntity.ts"/>
var JellyFish = (function (_super) {
    __extends(JellyFish, _super);
    // Constructor
    function JellyFish(quest, pos) {
        _super.call(this, quest, pos, new Naming("A jellyfish", "a jellyfish"), new RenderArea(6, 5), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 1), new Pos(6, 1)), new CollisionBox(this, new Pos(1, 2), new Pos(4, 1)), new CollisionBox(this, new Pos(0, 3), new Pos(4, 1)), new CollisionBox(this, new Pos(1, 4), new Pos(4, 1))), new QuestEntityMovement(new Pos(-1, 0)));
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(42);
        this.setHp(42);
        // Set the ascii art
        this.getRenderArea().drawArray(Database.getAscii("places/quests/theSea/jellyFish"));
        // Set the transparency
        this.setTransparency(new RenderTransparency(" ", "%"));
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("Poisoned tentacles", "poisoned tentacles"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(8, 7))), 2));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setFixedDelay(0);
    }
    // Public methods
    JellyFish.prototype.update = function () {
        // We follow the player
        this.goTowards(this.getRenderAreaCenter(), this.getQuest().getGame().getPlayer().getRenderAreaCenter(), 3);
        // We call the mother update method
        _super.prototype.update.call(this);
    };
    // willDie()
    JellyFish.prototype.willDie = function () {
        this.getQuest().getGame().getQuestLog().addMessage(new QuestLogMessage(this.getDeathMessage() + " (and found " + Algo.pluralFormat(this.getQuest().foundCandies(120), " candy", " candies") + ")", this.getQuest().getCandiesFoundMessage()));
    };
    return JellyFish;
})(QuestEntity);
var Keyboard;
(function (Keyboard) {
    // The game
    var game;
    function setGame(gameGiven) {
        game = gameGiven;
    }
    Keyboard.setGame = setGame;
    function execute() {
        // Handle keydown events
        $(document).keydown(function (event) {
            // Can we use hotkeys ?
            var canUseHotkeys = getCanUseHotkeys();
            // Handle hotkeys
            for (var keyString in game.getHotkeys()) {
                if (event.which == game.getHotkeys()[keyString].getKey()) {
                    game.getHotkeys()[keyString].setPressed(true);
                    if (canUseHotkeys) {
                        if (game.getHotkeys()[keyString].getCallbackCollection() != null)
                            game.getHotkeys()[keyString].getCallbackCollection().fire();
                        event.preventDefault();
                        return false;
                    }
                }
            }
            // Handle special hotkeys
            if (canUseHotkeys) {
                for (var i = 0; i < game.getSpecialHotkeys().length; i++) {
                    if (event.which == game.getSpecialHotkeys()[i].getKey()) {
                        if (game.getSpecialHotkeys()[i].getCallbackCollection() != null)
                            game.getSpecialHotkeys()[i].getCallbackCollection().fire();
                        event.preventDefault();
                        return false;
                    }
                }
            }
        });
        // Handle keyup events
        $(document).keyup(function (event) {
            // Handle hotkeys
            for (var keyString in game.getHotkeys()) {
                if (event.which == game.getHotkeys()[keyString].getKey()) {
                    game.getHotkeys()[keyString].setPressed(false);
                }
            }
        });
    }
    Keyboard.execute = execute;
    function getCanUseHotkeys() {
        if ($(':focus').hasClass("noHotkeys"))
            return false;
        return true;
    }
    function isKeyPressed(keyString) {
        return game.getHotkeys()[keyString].getPressed();
    }
    Keyboard.isKeyPressed = isKeyPressed;
})(Keyboard || (Keyboard = {}));
///<reference path="QuestEntity.ts"/>
var Knight = (function (_super) {
    __extends(Knight, _super);
    // Constructor
    function Knight(quest, pos) {
        _super.call(this, quest, pos, new Naming("A knight", "a knight"), new RenderArea(15, 6), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(3, 1), new Pos(1, 1)), new CollisionBox(this, new Pos(6, 1), new Pos(3, 1)), new CollisionBox(this, new Pos(0, 2), new Pos(9, 1)), new CollisionBox(this, new Pos(2, 3), new Pos(13, 1)), new CollisionBox(this, new Pos(3, 4), new Pos(9, 1)), new CollisionBox(this, new Pos(4, 5), new Pos(2, 1)), new CollisionBox(this, new Pos(9, 5), new Pos(2, 1))), new QuestEntityMovement(new Pos(0, 0)));
        // Default movement related variables values
        this.moving = false;
        this.currentAsciiNumber = 1;
        // Set gravity
        this.getQuestEntityMovement().setGravity(true);
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(150);
        this.setHp(150);
        // Set the ascii art and the transparent character
        this.reDrawAscii();
        this.setTransparency(new RenderTransparency(" ", "%"));
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("A sword", "a sword"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, 0), new Pos(17, 7))), 70));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setFixedDelay(8);
    }
    // update()
    Knight.prototype.update = function () {
        // If we're not moving
        if (this.moving == false) {
            // If we're able to move now
            if (this.testNewGlobalPosition(this.getGlobalPosition().plus(new Pos(-3, 0)))) {
                this.moving = true; // We move
                this.getQuestEntityMovement().setOffset(new Pos(-3, 0)); // The movement
            }
        }
        else {
            // If we're not able to move anymore
            if (this.testNewGlobalPosition(this.getGlobalPosition().plus(new Pos(-3, 0))) == false) {
                this.moving = false; // We stop moving
                this.getQuestEntityMovement().setOffset(new Pos(0, 0)); // The movement
                this.currentAsciiNumber = 1; // currentAsciiNumber
                this.reDrawAscii();
            }
            else {
                // Change the currentAsciiNumber
                this.currentAsciiNumber += 1;
                if (this.currentAsciiNumber > 5)
                    this.currentAsciiNumber = 1;
                this.reDrawAscii();
            }
        }
        // Call the mother class update
        _super.prototype.update.call(this);
    };
    // willDie()
    Knight.prototype.willDie = function () {
        this.getQuest().getGame().getQuestLog().addMessage(new QuestLogMessage(this.getDeathMessage() + " (and found " + Algo.pluralFormat(this.getQuest().foundCandies(800 + Random.upTo(15) * 100), " candy", " candies") + ")", this.getQuest().getCandiesFoundMessage()));
        if (Random.oneChanceOutOf(5))
            this.getQuest().foundGridOrEqItem(new QuestItemFound(this.getQuest(), "eqItemBodyArmoursKnightBodyArmour", "You found a body armour on a knight", "You gain a knight body armour"));
    };
    // Private methods
    Knight.prototype.reDrawAscii = function () {
        this.getRenderArea().drawArray(Database.getAscii("places/quests/castleEntrance/knight" + this.currentAsciiNumber.toString()));
    };
    return Knight;
})(QuestEntity);
///<reference path="EqItem.ts"/>
var KnightBodyArmour = (function (_super) {
    __extends(KnightBodyArmour, _super);
    // Constructor
    function KnightBodyArmour() {
        _super.call(this, "eqItemBodyArmoursKnightBodyArmour", "eqItemBodyArmoursKnightBodyArmourName", "eqItemBodyArmoursKnightBodyArmourDescription", "eqItems/bodyArmours/knightBodyArmour");
    }
    // Special ability
    KnightBodyArmour.prototype.getSpecialAbility = function () {
        return "Damage taken reduced by 30% (knight body armour)";
    };
    // inflictDamage()
    KnightBodyArmour.prototype.inflictDamage = function (player, quest, damage, reason) {
        return Math.ceil(damage - damage * 30 / 100);
    };
    return KnightBodyArmour;
})(EqItem);
///<reference path="QuestEntity.ts"/>
var Lava = (function (_super) {
    __extends(Lava, _super);
    // Constructor
    function Lava(quest, globalPosition, size) {
        // Call the mother constructor
        _super.call(this, quest, globalPosition, new Naming("Lava", "lava"));
        // Set the team (nature)
        this.setTeam(QuestEntityTeam.NATURE);
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("Fire", "fire"), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 0), size)), 1000));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setFixedDelay(0);
    }
    return Lava;
})(QuestEntity);
///<reference path="EqItem.ts"/>
var LeatherBoots = (function (_super) {
    __extends(LeatherBoots, _super);
    // Constructor
    function LeatherBoots() {
        _super.call(this, "eqItemBootsLeatherBoots", "eqItemBootsLeatherBootsName", "eqItemBootsLeatherBootsDescription", "eqItems/boots/leatherBoots");
    }
    return LeatherBoots;
})(EqItem);
///<reference path="EqItem.ts"/>
var LeatherGloves = (function (_super) {
    __extends(LeatherGloves, _super);
    // Constructor
    function LeatherGloves() {
        _super.call(this, "eqItemGlovesLeatherGloves", "eqItemGlovesLeatherGlovesName", "eqItemGlovesLeatherGlovesDescription", "eqItems/gloves/leatherGloves");
    }
    return LeatherGloves;
})(EqItem);
///<reference path="Place.ts"/>
Saving.registerBool("lighthousePuzzleDone", false);
var Lighthouse = (function (_super) {
    __extends(Lighthouse, _super);
    // Constructor
    function Lighthouse(game) {
        _super.call(this, game);
        // The render area
        this.renderArea = new RenderArea();
        // Selected question id
        this.selectedQuestionId = "lighthouseQuestionWho";
        // Speech id
        this.speechId = null;
        // Show the puzzle?
        this.showPuzzle = false;
        // The puzzle
        this.puzzle = null;
        // We create the questions array
        this.createQuestionsArray();
        // We resize and update
        this.renderArea.resizeFromArray(Database.getAscii("places/lighthouse/lighthouse"), 0, 4); // 4 in order to add a space below the lighthouse, so that it looks nicer
        this.update();
    }
    // getRenderArea()
    Lighthouse.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // Public methods
    Lighthouse.prototype.update = function () {
        // Erase everything
        this.renderArea.resetAllButSize();
        // Back to the map button
        this.addBackToMainMapButton(this.renderArea, "lighthouseBackToTheMapButton");
        // Draw the lighthouse
        this.renderArea.drawArray(Database.getAscii("places/lighthouse/lighthouse"), 0, 3);
        // Add the questions list
        this.renderArea.addList(1, 55, 7, "lighthouseQuestionsList", new CallbackCollection(this.questionSelected.bind(this)), this.questionsArray);
        // Add the ask button and the link
        this.renderArea.addAsciiRealButton(Database.getText("lighthouseAskButton"), 5, 10, "lighthouseAskButton", Database.getTranslatedText("lighthouseAskButton"));
        this.renderArea.addLinkCall(".lighthouseAskButton", new CallbackCollection(this.ask.bind(this)));
        // Draw the speech if there's a speech id
        if (this.speechId != null) {
            this.renderArea.drawSpeech(Database.getText(this.speechId), 17, 75, 99, "lighthouseSpeech", Database.getTranslatedText(this.speechId));
        }
        // If we should show the puzzle
        if (this.showPuzzle) {
            // Create the puzzle if it's not done yet
            if (this.puzzle == null)
                this.puzzle = new LighthousePuzzle(this);
            // Draw it
            this.puzzle.draw(this.renderArea, new Pos(2, 12));
            // Add the reset button
            this.renderArea.addAsciiRealButton(Database.getText("lighthousePuzzleResetButton"), 2, 34, "lighthousePuzzleResetButton", Database.getTranslatedText("lighthousePuzzleResetButton"));
            this.renderArea.addLinkCall(".lighthousePuzzleResetButton", new CallbackCollection(this.resetPuzzle.bind(this)));
        }
        // Add the link which will call the selectRightQuestion method after the html dom is created
        this.renderArea.addLinkCallbackCollection(new CallbackCollection(this.selectRightQuestion.bind(this)));
    };
    // Public getters
    Lighthouse.prototype.getPuzzle = function () {
        return this.puzzle;
    };
    // Public setters
    Lighthouse.prototype.setSpeechId = function (speechId) {
        this.speechId = speechId;
    };
    // Private methods
    Lighthouse.prototype.addQuestion = function (id, text, translatedText) {
        if (translatedText === void 0) { translatedText = null; }
        this.questionsArray.push(id);
        if (translatedText == null)
            this.questionsArray.push(text);
        else
            this.questionsArray.push(text + (translatedText != "" ? " (" + translatedText + ")" : ""));
    };
    Lighthouse.prototype.ask = function () {
        this.speechId = this.selectedQuestionId + "Speech";
        if (this.selectedQuestionId == "lighthouseQuestionDragon")
            this.showPuzzle = true;
        else
            this.showPuzzle = false;
        this.update();
        this.getGame().updatePlace();
    };
    Lighthouse.prototype.createQuestionsArray = function () {
        // We empty the array
        this.questionsArray = [];
        // Add the first basic questions
        this.addQuestion("lighthouseQuestionWho", Database.getText("lighthouseQuestionWho"), Database.getTranslatedText("lighthouseQuestionWho"));
        this.addQuestion("lighthouseQuestionWhat", Database.getText("lighthouseQuestionWhat"), Database.getTranslatedText("lighthouseQuestionWhat"));
        this.addQuestion("lighthouseQuestionWhyEatCandies", Database.getText("lighthouseQuestionWhyEatCandies"), Database.getTranslatedText("lighthouseQuestionWhyEatCandies"));
        this.addQuestion("lighthouseQuestionCandyBox", Database.getText("lighthouseQuestionCandyBox"), Database.getTranslatedText("lighthouseQuestionCandyBox"));
        // Add the question about the dragon is we unlocked it
        if (Saving.loadBool("dragonUnlockedCyclops")) {
            this.addQuestion("lighthouseQuestionDragon", Database.getText("lighthouseQuestionDragon"), Database.getTranslatedText("lighthouseQuestionDragon"));
        }
    };
    Lighthouse.prototype.questionSelected = function () {
        // Get the selected language id
        this.selectedQuestionId = $("#lighthouseQuestionsList").find(":selected").attr("id");
        // Update the ligthouse
        this.update();
        this.getGame().updatePlace();
    };
    Lighthouse.prototype.resetPuzzle = function () {
        // Re create the puzzle
        this.puzzle = new LighthousePuzzle(this);
        // Update
        this.update();
        this.getGame().updatePlace();
    };
    Lighthouse.prototype.selectRightQuestion = function () {
        // We select the right question
        $("#" + this.selectedQuestionId).prop('selected', true);
    };
    return Lighthouse;
})(Place);
var LighthousePuzzle = (function () {
    // Constructor
    function LighthousePuzzle(lighthouse) {
        // Create the parts
        this.createParts(lighthouse);
    }
    // Public methods
    LighthousePuzzle.prototype.draw = function (renderArea, pos) {
        for (var i = 0; i < 7; i++) {
            for (var j = 4; j >= 0; j--) {
                if (this.parts[i][j] != null)
                    this.parts[i][j].draw(renderArea, pos.plus(new Pos(i * 7, j * 4)));
            }
        }
    };
    // Public getters
    LighthousePuzzle.prototype.getParts = function () {
        return this.parts;
    };
    // Private methods
    LighthousePuzzle.prototype.createParts = function (lighthouse) {
        this.parts = [];
        // Add the arrays inside the arrays, and set each part to null
        for (var i = 0; i < 7; i++) {
            this.parts[i] = [];
            for (var j = 0; j < 5; j++) {
                this.parts[i][j] = null;
            }
        }
        // Add the central part, the first shown at first
        // It will allow use to show up to three other parts around
        this.parts[3][2] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.SHOW_AROUND, 3, new Pos(3, 2), true);
        // Add the show right, show below move below to the right and show above parts
        this.parts[3][1] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.SHOW_RIGHT, 1, new Pos(3, 1), false); // above the central part
        this.parts[4][1] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.SHOW_BELOW, 1, new Pos(4, 1), false); // top right corner of the central part
        this.parts[4][2] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.MOVE_BELOW_LINE_TO_THE_RIGHT, 5, new Pos(4, 2), false); // on the right of the central part
        this.parts[3][3] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.SHOW_ABOVE, 1, new Pos(3, 3), false); // below the central part
        // Add the lives part
        this.parts[5][2] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.LIVES, 1, new Pos(5, 2), false);
        // Add the show below
        this.parts[4][3] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.SHOW_BELOW, 1, new Pos(4, 3), false);
        // Add the cool path
        this.parts[3][4] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.SHOW_LEFT_RIGHT, 2, new Pos(3, 4), false);
        this.parts[4][4] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.SHOW_RIGHT, 1, new Pos(4, 4), false);
        this.parts[5][4] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.SHOW_RIGHT, 1, new Pos(5, 4), false);
        this.parts[6][4] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.SHOW_ABOVE, 1, new Pos(6, 4), false);
        this.parts[0][3] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.SHOW_ABOVE, 1, new Pos(0, 3), false);
        this.parts[6][2] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.SHOW_ABOVE, 1, new Pos(6, 2), false);
        this.parts[6][1] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.SHOW_LEFT, 1, new Pos(6, 1), false);
        // Add the lives part at the end of the cool path
        this.parts[5][1] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.LIVES, 1, new Pos(5, 1), false);
        // Add the path to the second move below line to the right
        this.parts[2][4] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.SHOW_LEFT, 1, new Pos(2, 4), false);
        this.parts[1][4] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.SHOW_LEFT, 1, new Pos(1, 4), false);
        this.parts[0][4] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.MOVE_BELOW_LINE_TO_THE_RIGHT, 0, new Pos(0, 4), false);
        // And the end (9 parts allowing us to give life to the ? ?)
        this.parts[0][0] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.SHOW_RIGHT, 1, new Pos(0, 0), false);
        this.parts[0][1] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.SHOW_ABOVE, 1, new Pos(0, 1), false);
        this.parts[0][2] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.SHOW_ABOVE, 1, new Pos(0, 2), false);
        this.parts[1][0] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.LIVES, 0, new Pos(1, 0), false);
        this.parts[1][1] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.MOVE_LEFT_LINE_ABOVE, 0, new Pos(1, 1), false);
        this.parts[1][2] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.SHOW_ABOVE, 1, new Pos(1, 2), false);
        this.parts[2][0] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.LIVES, 1, new Pos(2, 0), false);
        this.parts[2][1] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.SHOW_ABOVE, 1, new Pos(2, 1), false);
        this.parts[2][2] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.SHOW_ABOVE, 1, new Pos(2, 2), false);
        // Add three useless parts to fill the blanks
        this.parts[3][0] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.SHOW_LEFT, 1, new Pos(3, 0), false);
        this.parts[4][0] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.BLANK, 0, new Pos(4, 0), false);
        this.parts[5][0] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.SHOW_BELOW, 1, new Pos(5, 0), false);
        this.parts[6][0] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.WHAT, 0, new Pos(6, 0), true);
        // Add some more useless parts to fill the blanks
        this.parts[1][3] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.BLANK, 0, new Pos(1, 3), false);
        this.parts[2][3] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.NOTHING_HERE, 0, new Pos(2, 3), false);
        this.parts[5][3] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.SHOW_LEFT, 1, new Pos(5, 3), false);
        this.parts[6][3] = new LighthousePuzzlePart(lighthouse, LighthousePuzzlePartType.BLANK, 0, new Pos(6, 3), false);
    };
    return LighthousePuzzle;
})();
var LighthousePuzzlePart = (function () {
    // Constructor
    function LighthousePuzzlePart(lighthouse, type, lives, arrayPos, shown) {
        if (shown === void 0) { shown = false; }
        // Set from parameters
        this.lighthouse = lighthouse;
        this.type = type;
        this.lives = lives;
        this.arrayPos = arrayPos;
        this.shown = shown;
    }
    // Public methods
    LighthousePuzzlePart.prototype.addLives = function (howMany) {
        this.lives += howMany;
        if (this.lives > 5)
            this.lives = 5;
    };
    LighthousePuzzlePart.prototype.draw = function (renderArea, pos) {
        // If the part is shown already
        if (this.shown) {
            // Draw something different depending on the type
            switch (this.type) {
                case LighthousePuzzlePartType.BLANK:
                    renderArea.drawArray(Database.getAscii("places/lighthouse/puzzle/blankPart"), pos.x, pos.y);
                    break;
                case LighthousePuzzlePartType.SHOW_AROUND:
                    renderArea.drawArray(Database.getAscii("places/lighthouse/puzzle/showAroundPart"), pos.x, pos.y);
                    break;
                case LighthousePuzzlePartType.SHOW_LEFT:
                    renderArea.drawArray(Database.getAscii("places/lighthouse/puzzle/showLeft"), pos.x, pos.y);
                    break;
                case LighthousePuzzlePartType.SHOW_BELOW:
                    renderArea.drawArray(Database.getAscii("places/lighthouse/puzzle/showBelow"), pos.x, pos.y);
                    break;
                case LighthousePuzzlePartType.SHOW_ABOVE:
                    renderArea.drawArray(Database.getAscii("places/lighthouse/puzzle/showAbove"), pos.x, pos.y);
                    break;
                case LighthousePuzzlePartType.SHOW_RIGHT:
                    renderArea.drawArray(Database.getAscii("places/lighthouse/puzzle/showRight"), pos.x, pos.y);
                    break;
                case LighthousePuzzlePartType.SHOW_LEFT_RIGHT:
                    renderArea.drawArray(Database.getAscii("places/lighthouse/puzzle/showLeftRight"), pos.x, pos.y);
                    break;
                case LighthousePuzzlePartType.MOVE_BELOW_LINE_TO_THE_RIGHT:
                    renderArea.drawArray(Database.getAscii("places/lighthouse/puzzle/moveBelowLineToTheRight"), pos.x, pos.y);
                    break;
                case LighthousePuzzlePartType.MOVE_LEFT_LINE_ABOVE:
                    renderArea.drawArray(Database.getAscii("places/lighthouse/puzzle/moveLeftLineAbove"), pos.x, pos.y);
                    break;
                case LighthousePuzzlePartType.LIVES:
                    renderArea.drawArray(Database.getAscii("places/lighthouse/puzzle/livesPart"), pos.x, pos.y);
                    break;
                case LighthousePuzzlePartType.WHAT:
                    renderArea.drawArray(Database.getAscii("places/lighthouse/puzzle/whatPart"), pos.x, pos.y);
                    break;
                case LighthousePuzzlePartType.NOTHING_HERE:
                    renderArea.drawArray(Database.getAscii("places/lighthouse/puzzle/nothingHerePart"), pos.x, pos.y);
                    break;
                case LighthousePuzzlePartType.STONE:
                    renderArea.drawArray(Database.getAscii("places/lighthouse/puzzle/stonePart"), pos.x, pos.y);
                    break;
            }
            // Draw the lives, depending on the type
            switch (this.type) {
                // By default, we draw the lives
                default:
                    renderArea.drawHorizontalLine("#", pos.x + 1, pos.x + 1 + this.lives, pos.y + 1);
                    break;
            }
            // Add a button if we have enough lives
            if (this.lives > 0) {
                // Buttons
                for (var i = 0; i < 4; i++) {
                    renderArea.addAsciiButton(pos.x + 1, pos.x + 6, pos.y + 1 + i, "lighthousePuzzlePart" + pos.x.toString() + "_" + pos.y.toString());
                }
                // The link
                renderArea.addLinkCall(".lighthousePuzzlePart" + pos.x.toString() + "_" + pos.y.toString(), new CallbackCollection(this.clicked.bind(this)));
            }
        }
    };
    // Public getters
    LighthousePuzzlePart.prototype.getLives = function () {
        return this.lives;
    };
    LighthousePuzzlePart.prototype.getShown = function () {
        return this.shown;
    };
    // Public setters
    LighthousePuzzlePart.prototype.setArrayPos = function (arrayPos) {
        this.arrayPos = arrayPos;
    };
    LighthousePuzzlePart.prototype.setShown = function (shown) {
        this.shown = shown;
    };
    // Private methods
    LighthousePuzzlePart.prototype.clicked = function () {
        // Create a temporary part, used later
        var tempPart;
        // Do something different depending on the type
        switch (this.type) {
            case LighthousePuzzlePartType.SHOW_AROUND:
                // If we can show the part above, we show it
                if (this.arrayPos.y > 0 && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x][this.arrayPos.y - 1] != null && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x][this.arrayPos.y - 1].getShown() == false)
                    this.lighthouse.getPuzzle().getParts()[this.arrayPos.x][this.arrayPos.y - 1].setShown(true);
                else if (this.arrayPos.x < 6 && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x + 1][this.arrayPos.y] != null && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x + 1][this.arrayPos.y].getShown() == false)
                    this.lighthouse.getPuzzle().getParts()[this.arrayPos.x + 1][this.arrayPos.y].setShown(true);
                else if (this.arrayPos.y < 4 && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x][this.arrayPos.y + 1] != null && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x][this.arrayPos.y + 1].getShown() == false)
                    this.lighthouse.getPuzzle().getParts()[this.arrayPos.x][this.arrayPos.y + 1].setShown(true);
                else if (this.arrayPos.x > 0 && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x - 1][this.arrayPos.y] != null && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x - 1][this.arrayPos.y].getShown() == false)
                    this.lighthouse.getPuzzle().getParts()[this.arrayPos.x - 1][this.arrayPos.y].setShown(true);
                break;
            case LighthousePuzzlePartType.SHOW_LEFT:
                // If we can show the part on the left, we show it
                if (this.arrayPos.x > 0 && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x - 1][this.arrayPos.y] != null && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x - 1][this.arrayPos.y].getShown() == false)
                    this.lighthouse.getPuzzle().getParts()[this.arrayPos.x - 1][this.arrayPos.y].setShown(true);
                break;
            case LighthousePuzzlePartType.SHOW_BELOW:
                // If we can show the part below, we show it
                if (this.arrayPos.y < 4 && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x][this.arrayPos.y + 1] != null && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x][this.arrayPos.y + 1].getShown() == false)
                    this.lighthouse.getPuzzle().getParts()[this.arrayPos.x][this.arrayPos.y + 1].setShown(true);
                break;
            case LighthousePuzzlePartType.SHOW_ABOVE:
                // If we can show the part above, we show it
                if (this.arrayPos.y > 0 && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x][this.arrayPos.y - 1] != null && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x][this.arrayPos.y - 1].getShown() == false)
                    this.lighthouse.getPuzzle().getParts()[this.arrayPos.x][this.arrayPos.y - 1].setShown(true);
                break;
            case LighthousePuzzlePartType.SHOW_RIGHT:
                // If we can show the part on the right, we show it
                if (this.arrayPos.x < 6 && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x + 1][this.arrayPos.y] != null && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x + 1][this.arrayPos.y].getShown() == false)
                    this.lighthouse.getPuzzle().getParts()[this.arrayPos.x + 1][this.arrayPos.y].setShown(true);
                break;
            case LighthousePuzzlePartType.MOVE_BELOW_LINE_TO_THE_RIGHT:
                if (this.arrayPos.y < 4) {
                    tempPart = this.lighthouse.getPuzzle().getParts()[6][this.arrayPos.y + 1];
                    for (var i = 6; i > 0; i--) {
                        this.lighthouse.getPuzzle().getParts()[i][this.arrayPos.y + 1] = this.lighthouse.getPuzzle().getParts()[i - 1][this.arrayPos.y + 1];
                        if (this.lighthouse.getPuzzle().getParts()[i][this.arrayPos.y + 1] != null)
                            this.lighthouse.getPuzzle().getParts()[i][this.arrayPos.y + 1].setArrayPos(new Pos(i, this.arrayPos.y + 1));
                    }
                    this.lighthouse.getPuzzle().getParts()[0][this.arrayPos.y + 1] = tempPart;
                    if (this.lighthouse.getPuzzle().getParts()[0][this.arrayPos.y + 1] != null)
                        this.lighthouse.getPuzzle().getParts()[0][this.arrayPos.y + 1].setArrayPos(new Pos(0, this.arrayPos.y + 1));
                }
                break;
            case LighthousePuzzlePartType.MOVE_LEFT_LINE_ABOVE:
                if (this.arrayPos.x > 0) {
                    tempPart = this.lighthouse.getPuzzle().getParts()[this.arrayPos.x - 1][0];
                    for (var i = 0; i <= 3; i++) {
                        this.lighthouse.getPuzzle().getParts()[this.arrayPos.x - 1][i] = this.lighthouse.getPuzzle().getParts()[this.arrayPos.x - 1][i + 1];
                        if (this.lighthouse.getPuzzle().getParts()[this.arrayPos.x - 1][i] != null)
                            this.lighthouse.getPuzzle().getParts()[this.arrayPos.x - 1][i].setArrayPos(new Pos(this.arrayPos.x - 1, i));
                    }
                    this.lighthouse.getPuzzle().getParts()[this.arrayPos.x - 1][4] = tempPart;
                    if (this.lighthouse.getPuzzle().getParts()[this.arrayPos.x - 1][4] != null)
                        this.lighthouse.getPuzzle().getParts()[this.arrayPos.x - 1][4].setArrayPos(new Pos(this.arrayPos.x - 1, 4));
                }
                break;
            case LighthousePuzzlePartType.LIVES:
                // If we can increase the lives of the part above, we show it
                if (this.arrayPos.y > 0 && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x][this.arrayPos.y - 1] != null && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x][this.arrayPos.y - 1].getShown() == true)
                    this.lighthouse.getPuzzle().getParts()[this.arrayPos.x][this.arrayPos.y - 1].addLives(1);
                // If we can increase the lives of the part on the right, we show it
                if (this.arrayPos.x < 6 && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x + 1][this.arrayPos.y] != null && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x + 1][this.arrayPos.y].getShown() == true)
                    this.lighthouse.getPuzzle().getParts()[this.arrayPos.x + 1][this.arrayPos.y].addLives(1);
                // If we can increase the lives of the part below, we show it
                if (this.arrayPos.y < 4 && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x][this.arrayPos.y + 1] != null && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x][this.arrayPos.y + 1].getShown() == true)
                    this.lighthouse.getPuzzle().getParts()[this.arrayPos.x][this.arrayPos.y + 1].addLives(1);
                // If we can increase the lives of the part on the left, we show it
                if (this.arrayPos.x > 0 && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x - 1][this.arrayPos.y] != null && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x - 1][this.arrayPos.y].getShown() == true)
                    this.lighthouse.getPuzzle().getParts()[this.arrayPos.x - 1][this.arrayPos.y].addLives(1);
                break;
            case LighthousePuzzlePartType.SHOW_LEFT_RIGHT:
                // If we can show the part on the right, we show it
                if (this.arrayPos.x < 6 && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x + 1][this.arrayPos.y] != null && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x + 1][this.arrayPos.y].getShown() == false)
                    this.lighthouse.getPuzzle().getParts()[this.arrayPos.x + 1][this.arrayPos.y].setShown(true);
                else if (this.arrayPos.x > 0 && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x - 1][this.arrayPos.y] != null && this.lighthouse.getPuzzle().getParts()[this.arrayPos.x - 1][this.arrayPos.y].getShown() == false)
                    this.lighthouse.getPuzzle().getParts()[this.arrayPos.x - 1][this.arrayPos.y].setShown(true);
                break;
            case LighthousePuzzlePartType.WHAT:
                // Change the type
                this.type = LighthousePuzzlePartType.STONE;
                // If we didn't have the stone before
                if (Saving.loadBool("gridItemPossessedP") == false) {
                    // Get the stone
                    this.lighthouse.getGame().gainItem("gridItemPossessedP");
                    // Change the speech
                    this.lighthouse.setSpeechId("lighthouseFoundStone");
                }
                else {
                    // Change the speech
                    this.lighthouse.setSpeechId("lighthouseFoundStoneAgain");
                }
                break;
        }
        // Decrease our lives
        this.lives -= 1;
        // Update the lighthouse
        this.lighthouse.update();
        this.lighthouse.getGame().updatePlace();
    };
    return LighthousePuzzlePart;
})();
var LighthousePuzzlePartType;
(function (LighthousePuzzlePartType) {
    LighthousePuzzlePartType[LighthousePuzzlePartType["BLANK"] = 0] = "BLANK";
    LighthousePuzzlePartType[LighthousePuzzlePartType["SHOW_AROUND"] = 1] = "SHOW_AROUND";
    LighthousePuzzlePartType[LighthousePuzzlePartType["SHOW_LEFT"] = 2] = "SHOW_LEFT";
    LighthousePuzzlePartType[LighthousePuzzlePartType["SHOW_BELOW"] = 3] = "SHOW_BELOW";
    LighthousePuzzlePartType[LighthousePuzzlePartType["SHOW_ABOVE"] = 4] = "SHOW_ABOVE";
    LighthousePuzzlePartType[LighthousePuzzlePartType["SHOW_RIGHT"] = 5] = "SHOW_RIGHT";
    LighthousePuzzlePartType[LighthousePuzzlePartType["MOVE_BELOW_LINE_TO_THE_RIGHT"] = 6] = "MOVE_BELOW_LINE_TO_THE_RIGHT";
    LighthousePuzzlePartType[LighthousePuzzlePartType["MOVE_LEFT_LINE_ABOVE"] = 7] = "MOVE_LEFT_LINE_ABOVE";
    LighthousePuzzlePartType[LighthousePuzzlePartType["LIVES"] = 8] = "LIVES";
    LighthousePuzzlePartType[LighthousePuzzlePartType["NOTHING_HERE"] = 9] = "NOTHING_HERE";
    LighthousePuzzlePartType[LighthousePuzzlePartType["WHAT"] = 10] = "WHAT";
    LighthousePuzzlePartType[LighthousePuzzlePartType["SHOW_LEFT_RIGHT"] = 11] = "SHOW_LEFT_RIGHT";
    LighthousePuzzlePartType[LighthousePuzzlePartType["STONE"] = 12] = "STONE";
})(LighthousePuzzlePartType || (LighthousePuzzlePartType = {}));
///<reference path="EqItem.ts"/>
var LightweightBodyArmour = (function (_super) {
    __extends(LightweightBodyArmour, _super);
    // Constructor
    function LightweightBodyArmour() {
        _super.call(this, "eqItemBodyArmoursLightweightBodyArmour", "eqItemBodyArmoursLightweightBodyArmourName", "eqItemBodyArmoursLightweightBodyArmourDescription", "eqItems/bodyArmours/lightweightBodyArmour");
    }
    // Special ability
    LightweightBodyArmour.prototype.getSpecialAbility = function () {
        return "Damage taken reduced by 15% (lightweight body armour)";
    };
    // inflictDamage()
    LightweightBodyArmour.prototype.inflictDamage = function (player, quest, damage, reason) {
        return Math.ceil(damage - damage * 15 / 100);
    };
    return LightweightBodyArmour;
})(EqItem);
var LocalSaving;
(function (LocalSaving) {
    // Public functions
    function getSlotSummaryAsString(slotId) {
        // If there's no save on this slot
        if (loadString(slotId) == null) {
            return "empty";
        }
        else {
            return loadString(slotId) + ", candies : " + loadString(slotId + ".gameCandiesCurrent");
        }
    }
    LocalSaving.getSlotSummaryAsString = getSlotSummaryAsString;
    function load(slotId) {
        // If this sot doesn't seem to exist, we return false
        if (loadString(slotId) == null)
            return false;
        // Load bools
        for (var str in Saving.getAllBools()) {
            Saving.saveBool(str, this.loadBool(slotId + "." + str));
        }
        // Load numbers
        for (var str in Saving.getAllNumbers()) {
            Saving.saveNumber(str, this.loadNumber(slotId + "." + str));
        }
        // Load strings
        for (var str in Saving.getAllStrings()) {
            Saving.saveString(str, this.loadString(slotId + "." + str));
        }
        // No error, return true
        return true;
    }
    LocalSaving.load = load;
    function save(slotId) {
        try {
            // Set the date on the slotId localStorage item
            localStorage.setItem(slotId, getDateAsString());
            // Save bools
            for (var str in Saving.getAllBools()) {
                localStorage.setItem(slotId + "." + str, Saving.boolToString(Saving.getAllBools()[str]));
            }
            // Save numbers
            for (var str in Saving.getAllNumbers()) {
                localStorage.setItem(slotId + "." + str, Saving.numberToString(Saving.getAllNumbers()[str]));
            }
            // Save strings
            for (var str in Saving.getAllStrings()) {
                localStorage.setItem(slotId + "." + str, Saving.getAllStrings()[str]);
            }
        }
        catch (e) {
            if (e == DOMException.QUOTA_EXCEEDED_ERR) {
                console.log("Quota exceeded error : we're trying to save some data through HTML5's web storage, but we don't have enough space to save what we want.");
            }
            // We return false, since there was an error
            return false;
        }
        // No error, return true
        return true;
    }
    LocalSaving.save = save;
    function supportsLocalSaving() {
        if ('localStorage' in window && window['localStorage'] !== null)
            return true;
        return false;
    }
    LocalSaving.supportsLocalSaving = supportsLocalSaving;
    // Private functions
    function getDateAsString() {
        var currentdate = new Date();
        return (currentdate.getDate() < 10 ? "0" : "") // 0 before day
            + currentdate.getDate() // Day
            + "/"
            + (currentdate.getMonth() + 1 < 10 ? "0" : "") // 0 before month
            + (currentdate.getMonth() + 1) // month
            + "/"
            + currentdate.getFullYear() // year
            + " @ "
            + (currentdate.getHours() < 10 ? "0" : "") // 0 before hours
            + currentdate.getHours() // hour
            + ":"
            + (currentdate.getMinutes() < 10 ? "0" : "") // 0 before minutes
            + currentdate.getMinutes() // minutes
            + ":"
            + (currentdate.getSeconds() < 10 ? "0" : "") // 0 before seconds
            + currentdate.getSeconds(); // seconds
    }
    function loadBool(key) {
        return Saving.stringToBool(localStorage.getItem(key));
    }
    LocalSaving.loadBool = loadBool;
    function loadNumber(key) {
        return Saving.stringToNumber(localStorage.getItem(key));
    }
    LocalSaving.loadNumber = loadNumber;
    function loadString(key) {
        return localStorage.getItem(key);
    }
    LocalSaving.loadString = loadString;
})(LocalSaving || (LocalSaving = {}));
///<reference path="Place.ts"/>
// Buttons unlocked
Saving.registerBool("lollipopFarmPlant1LollipopButtonUnlocked", false);
Saving.registerBool("lollipopFarmPlant10LollipopsButtonUnlocked", false);
Saving.registerBool("lollipopFarmPlant100LollipopsButtonUnlocked", false);
Saving.registerBool("lollipopFarmPlant1000LollipopsButtonUnlocked", false);
// How many lollipops planted ?
Saving.registerNumber("lollipopFarmLollipopsPlanted", 0);
// The production
Saving.registerNumber("lollipopFarmTimeSinceLastProduction", 0);
Saving.registerBool("lollipopFarmIsProductionEachSecond", false);
Saving.registerNumber("lollipopFarmProduction", 0);
// The mill
Saving.registerBool("lollipopFarmConstructMillButtonUnlocked", false);
Saving.registerBool("lollipopFarmMillConstructed", false);
// The pond
Saving.registerBool("lollipopFarmDigPondButtonUnlocked", false);
Saving.registerBool("lollipopFarmPondDug", false);
Saving.registerNumber("lollipopFarmPondHowManyLolligators", 0);
Saving.registerBool("lollipopFarmPondFeedingLolligators", false);
Saving.registerNumber("lollipopFarmPondConversionRate", 0);
// The candies production
Saving.registerNumber("lollipopFarmPreviousCandiesProduction", 1);
Saving.registerNumber("lollipopFarmCurrentCandiesProduction", 1);
var LollipopFarm = (function (_super) {
    __extends(LollipopFarm, _super);
    // Constructor
    function LollipopFarm(game) {
        _super.call(this, game);
        // Render area
        this.renderArea = new RenderArea();
        // Pond lines
        this.pondLines = [];
        // Pond lolligators
        this.pondLolligators = [];
        // Resize the area
        this.renderArea.resizeFromArray(Database.getAscii("places/lollipopFarm/lollipopFarm"), 0, 12);
        // Update
        this.update();
        // Add pond lines to the pond lines array
        this.addPondLine(new PondLine(8, 37)); // first line, index 0 but at y position 3 on the pond
        this.addPondLine(new PondLine(9, 38)); // second line, index 1, y position 4
        this.addPondLine(new PondLine(9, 40)); // etc
        this.addPondLine(new PondLine(8, 43));
        this.addPondLine(new PondLine(8, 46));
        this.addPondLine(new PondLine(3, 47));
        this.addPondLine(new PondLine(4, 48));
        this.addPondLine(new PondLine(9, 45));
        this.addPondLine(new PondLine(12, 44));
    }
    // Public methods
    LollipopFarm.prototype.willBeDisplayed = function () {
        // We check lollipops
        this.checkLollipops();
        // We add the lollipops callback
        this.getGame().getLollipops().getCallbackCollection().addCallback(this.checkLollipops.bind(this));
        // We add the one second callback for the pond
        this.getGame().getOneSecondCallbackCollection().addCallback(this.handlePond.bind(this));
    };
    // getRenderArea()
    LollipopFarm.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // Private methods
    LollipopFarm.prototype.addPondLine = function (pondLine) {
        this.pondLines.push(pondLine);
    };
    LollipopFarm.prototype.addPondLolligator = function (pondLolligator) {
        this.pondLolligators.push(pondLolligator);
    };
    LollipopFarm.prototype.beginFeedingLolligators = function () {
        // We set the bool
        Saving.saveBool("lollipopFarmPondFeedingLolligators", true);
        // We update
        this.update();
        this.getGame().updatePlace();
    };
    LollipopFarm.prototype.buyLolligator = function () {
        if (this.getGame().getCandies().getCurrent() >= 1200) {
            this.getGame().getCandies().add(-1200);
            // Update the number of lolligators
            Saving.saveNumber("lollipopFarmPondHowManyLolligators", Saving.loadNumber("lollipopFarmPondHowManyLolligators") + 1);
            // Update the conversion rate
            this.updatePondConversionRate();
            // Update the place
            this.update();
            this.getGame().updatePlace();
        }
    };
    LollipopFarm.prototype.checkLollipops = function () {
        // We possibly unlock some buttons used for planting lollipops
        if (Saving.loadBool("lollipopFarmPlant1LollipopButtonUnlocked") == false && this.getGame().getLollipops().getMax() >= 1) {
            Saving.saveBool("lollipopFarmPlant1LollipopButtonUnlocked", true);
            this.update();
            this.getGame().updatePlace();
        }
        if (Saving.loadBool("lollipopFarmPlant10LollipopsButtonUnlocked") == false && this.getGame().getLollipops().getMax() >= 10) {
            Saving.saveBool("lollipopFarmPlant10LollipopsButtonUnlocked", true);
            this.update();
            this.getGame().updatePlace();
        }
        if (Saving.loadBool("lollipopFarmPlant100LollipopsButtonUnlocked") == false && this.getGame().getLollipops().getMax() >= 100) {
            Saving.saveBool("lollipopFarmPlant100LollipopsButtonUnlocked", true);
            this.update();
            this.getGame().updatePlace();
        }
        if (Saving.loadBool("lollipopFarmPlant1000LollipopsButtonUnlocked") == false && this.getGame().getLollipops().getMax() >= 1000) {
            Saving.saveBool("lollipopFarmPlant1000LollipopsButtonUnlocked", true);
            this.update();
            this.getGame().updatePlace();
        }
        // We possibly unlock the button used to construct the mill
        if (Saving.loadBool("lollipopFarmConstructMillButtonUnlocked") == false && this.getGame().getLollipops().getMax() >= 10000) {
            Saving.saveBool("lollipopFarmConstructMillButtonUnlocked", true);
            this.update();
            this.getGame().updatePlace();
        }
        // We possibly unlock the button used to dig the pond
        if (Saving.loadBool("lollipopFarmDigPondButtonUnlocked") == false && this.getGame().getLollipops().getMax() >= 100000) {
            Saving.saveBool("lollipopFarmDigPondButtonUnlocked", true);
            this.update();
            this.getGame().updatePlace();
        }
    };
    LollipopFarm.prototype.constructMill = function () {
        if (this.getGame().getLollipops().getCurrent() >= 10000) {
            this.getGame().getLollipops().add(-10000);
            Saving.saveBool("lollipopFarmMillConstructed", true);
            this.update();
            this.getGame().updatePlace();
        }
    };
    LollipopFarm.prototype.digPond = function () {
        if (this.getGame().getLollipops().getCurrent() >= 100000) {
            this.getGame().getLollipops().add(-100000);
            Saving.saveBool("lollipopFarmPondDug", true);
            this.update();
            this.getGame().updatePlace();
        }
    };
    LollipopFarm.prototype.drawFieldStuff = function (x, y) {
        // A variable useful later
        var plantingButtonsXPos;
        // How many lollipops planted
        this.renderArea.drawString("Lollipops planted : " + Algo.numberToStringButNicely(Saving.loadNumber("lollipopFarmLollipopsPlanted")), x, y);
        // Button(s) to plant lollipops
        // If the first button is unlocked but not the second
        if (Saving.loadBool("lollipopFarmPlant1LollipopButtonUnlocked") == true && Saving.loadBool("lollipopFarmPlant10LollipopsButtonUnlocked") == false) {
            this.renderArea.addAsciiRealButton("Plant 1 lollipop", x, y + 2, "lollipopFarmPlant1LollipopButton");
            this.renderArea.addLinkCall(".lollipopFarmPlant1LollipopButton", new CallbackCollection(this.plantLollipops.bind(this, 1)));
        }
        else if (Saving.loadBool("lollipopFarmPlant10LollipopsButtonUnlocked") == true) {
            // We set the x position to 0
            plantingButtonsXPos = 0;
            // We draw the first text
            this.renderArea.drawString("Plant", x, y + 2);
            plantingButtonsXPos += 6;
            // We add the button to plant 1
            this.renderArea.addAsciiRealButton("1", x + plantingButtonsXPos, y + 2, "lollipopFarmPlant1LollipopButton");
            this.renderArea.addLinkCall(".lollipopFarmPlant1LollipopButton", new CallbackCollection(this.plantLollipops.bind(this, 1)));
            plantingButtonsXPos += 2;
            // We add the button to plant 10
            this.renderArea.addAsciiRealButton("10", x + plantingButtonsXPos, y + 2, "lollipopFarmPlant10LollipopsButton");
            this.renderArea.addLinkCall(".lollipopFarmPlant10LollipopsButton", new CallbackCollection(this.plantLollipops.bind(this, 10)));
            plantingButtonsXPos += 3;
            // We possibly add the button to plant 100
            if (Saving.loadBool("lollipopFarmPlant100LollipopsButtonUnlocked") == true) {
                this.renderArea.addAsciiRealButton("100", x + plantingButtonsXPos, y + 2, "lollipopFarmPlant100LollipopsButton");
                this.renderArea.addLinkCall(".lollipopFarmPlant100LollipopsButton", new CallbackCollection(this.plantLollipops.bind(this, 100)));
                plantingButtonsXPos += 4;
            }
            // We possibly add the button to plant 100
            if (Saving.loadBool("lollipopFarmPlant1000LollipopsButtonUnlocked") == true) {
                this.renderArea.addAsciiRealButton("1000", x + plantingButtonsXPos, y + 2, "lollipopFarmPlant1000LollipopsButton");
                this.renderArea.addLinkCall(".lollipopFarmPlant1000LollipopsButton", new CallbackCollection(this.plantLollipops.bind(this, 1000)));
                plantingButtonsXPos += 5;
            }
            // We add the final text
            this.renderArea.drawString("lollipops", x + plantingButtonsXPos, y + 2);
        }
        // The production
        if (Saving.loadNumber("lollipopFarmLollipopsPlanted") > 0) {
            this.renderArea.drawString("Production : " + this.getProductionAsString(), x, y + 4);
        }
    };
    LollipopFarm.prototype.drawMillStuff = function (x, y) {
        // Button to construct the mill (show if the button is unlocked and the mill isn't constructed yet)
        if (Saving.loadBool("lollipopFarmConstructMillButtonUnlocked") == true && Saving.loadBool("lollipopFarmMillConstructed") == false) {
            this.renderArea.addAsciiRealButton(Database.getText("lollipopFarmConstructMill"), x + 30, y + 2, "lollipopFarmConstructMillButton", Database.getTranslatedText("lollipopFarmConstructMill"), true, -1, null, false);
            this.renderArea.addLinkCall(".lollipopFarmConstructMillButton", new CallbackCollection(this.constructMill.bind(this)));
        }
        // If the mill is constructed
        if (Saving.loadBool("lollipopFarmMillConstructed") == true) {
            // Draw the mill ascii art
            this.renderArea.drawArray(Database.getAscii("places/lollipopFarm/mill"), x, y);
            // Draw the button to feed the mill
            this.renderArea.addAsciiRealButton(Database.getText("lollipopFarmFeedMill") + " (" + Algo.numberToStringButNicely(this.getNumberOfLollipopsToFeedTheMill()) + " lollipops)", x + 30, y, "lollipopFarmFeedMillButton", Database.getTranslatedText("lollipopFarmFeedMill"), true, -1, null, false);
            this.renderArea.addLinkCall(".lollipopFarmFeedMillButton", new CallbackCollection(this.feedMill.bind(this)));
            // Draw the current candies production if it's different from one
            if (Saving.loadNumber("lollipopFarmCurrentCandiesProduction") != 1) {
                this.renderArea.drawString(Database.getText("lollipopFarmCurrentCandiesProduction") + " : " + Saving.loadNumber("lollipopFarmCurrentCandiesProduction").toString() + " each second", x + 30, y + 3);
                this.renderArea.drawString(Database.getTranslatedText("lollipopFarmCurrentCandiesProduction"), x + 30, y + 4, true);
            }
        }
    };
    LollipopFarm.prototype.drawPondStuff = function (x, y) {
        // Y position used because some things need to be moved when the player uses a non-english language
        var yPos;
        // Button to dig the pond (show if the button is unlocked and the pond isn't constructed yet)
        if (Saving.loadBool("lollipopFarmDigPondButtonUnlocked") == true && Saving.loadBool("lollipopFarmPondDug") == false) {
            this.renderArea.addAsciiRealButton(Database.getText("lollipopFarmDigPond"), x + 10, y + 2, "lollipopFarmDigPondButton", Database.getTranslatedText("lollipopFarmDigPond"), true, -1, null, false);
            this.renderArea.addLinkCall(".lollipopFarmDigPondButton", new CallbackCollection(this.digPond.bind(this)));
        }
        // If the pond is constructed
        if (Saving.loadBool("lollipopFarmPondDug") == true) {
            // Init the y position
            yPos = y;
            // Draw the pond ascii art
            this.renderArea.drawArray(Database.getAscii("places/lollipopFarm/pond"), x, yPos, new RenderTransparency(" "));
            // Draw the lolligators
            yPos += 3;
            for (var i = 0; i < this.pondLolligators.length; i++) {
                this.pondLolligators[i].draw(this.renderArea, x, yPos);
            }
            // Add the button to buy a lolligator
            yPos += 13;
            this.renderArea.addAsciiRealButton(Database.getText("lollipopFarmBuyLolligator"), x, yPos, "lollipopFarmBuyLolligatorButton", Database.getTranslatedText("lollipopFarmBuyLolligator"), true, -1, null, false);
            this.renderArea.addLinkCall(".lollipopFarmBuyLolligatorButton", new CallbackCollection(this.buyLolligator.bind(this)));
            // Add 1 to yPos if translated
            if (Database.isTranslated())
                yPos += 1;
            // If we have at least one lolligator
            if (Saving.loadNumber("lollipopFarmPondHowManyLolligators") > 0) {
                // Draw how many lolligators we have (if we have at least one)
                yPos += 2;
                this.renderArea.drawString("There " + (Saving.loadNumber("lollipopFarmPondHowManyLolligators") > 1 ? "are" : "is") + " " + Algo.pluralFormat(Saving.loadNumber("lollipopFarmPondHowManyLolligators"), " lolligator", " lolligators") + " in the pond.", x, yPos);
                // Draw the checkbox to feed the lolligators
                yPos += 2;
                this.renderArea.addCheckbox(x, yPos, new CallbackCollection(this.beginFeedingLolligators.bind(this)), new CallbackCollection(this.stopFeedingLolligators.bind(this)), "lollipopFarmPondCheckbox", Saving.loadBool("lollipopFarmPondFeedingLolligators"));
                if (Saving.loadNumber("lollipopFarmPondHowManyLolligators") == 1)
                    this.renderArea.drawString("Feed it with candies", x + 3, yPos);
                else
                    this.renderArea.drawString("Feed them with candies", x + 4, yPos);
                // If we're feeding lolligators
                if (Saving.loadBool("lollipopFarmPondFeedingLolligators")) {
                    // Draw the conversion text
                    yPos += 2;
                    this.renderArea.drawString(Database.getText("lollipopFarmLolligatorsConversionText"), x, yPos);
                    if (Database.isTranslated()) {
                        yPos += 1;
                        this.renderArea.drawString(Database.getTranslatedText("lollipopFarmLolligatorsConversionText"), x, yPos, true);
                    }
                    // Draw the conversion rate
                    yPos += 1;
                    this.renderArea.drawString("Conversion rate : " + Saving.loadNumber("lollipopFarmPondConversionRate") + "/sec", x, yPos);
                }
            }
        }
    };
    LollipopFarm.prototype.feedMill = function () {
        if (this.getGame().getLollipops().getCurrent() >= this.getNumberOfLollipopsToFeedTheMill()) {
            // Pay the lollipops
            this.getGame().getLollipops().add(-this.getNumberOfLollipopsToFeedTheMill());
            // Increase the candies production step
            var oldCurrent = Saving.loadNumber("lollipopFarmCurrentCandiesProduction");
            Saving.saveNumber("lollipopFarmCurrentCandiesProduction", Saving.loadNumber("lollipopFarmCurrentCandiesProduction") + Saving.loadNumber("lollipopFarmPreviousCandiesProduction"));
            Saving.saveNumber("lollipopFarmPreviousCandiesProduction", oldCurrent);
            // Update
            this.update();
            this.getGame().updatePlace();
        }
    };
    LollipopFarm.prototype.getNumberOfLollipopsToFeedTheMill = function () {
        return Math.pow(Saving.loadNumber("lollipopFarmCurrentCandiesProduction") * 120, 2);
    };
    LollipopFarm.prototype.getProductionAsString = function () {
        // We create the string
        var str;
        // If we produce x lollipops each second
        if (Saving.loadBool("lollipopFarmIsProductionEachSecond")) {
            str = Algo.pluralFormat(Saving.loadNumber("lollipopFarmProduction"), " lollipop", " lollipops") + " each second";
        }
        else {
            str = "1 lollipop every ";
            // If the production is every hour
            if (Saving.loadNumber("lollipopFarmProduction") >= 3600) {
                if (Math.floor(Saving.loadNumber("lollipopFarmProduction") / 3600) == 1)
                    str += "hour";
                else
                    str += Math.floor(Saving.loadNumber("lollipopFarmProduction") / 3600).toString() + " hours";
            }
            else if (Saving.loadNumber("lollipopFarmProduction") >= 60) {
                if (Math.floor(Saving.loadNumber("lollipopFarmProduction") / 60) == 1)
                    str += "minute";
                else
                    str += Math.floor(Saving.loadNumber("lollipopFarmProduction") / 60).toString() + " minutes";
            }
            else {
                if (Saving.loadNumber("lollipopFarmProduction") == 1)
                    str += "second";
                else
                    str += Saving.loadNumber("lollipopFarmProduction").toString() + " seconds";
            }
        }
        // We return the string
        return str;
    };
    LollipopFarm.prototype.handlePond = function () {
        // Used later
        var lineIndex;
        // If the pond is dug
        if (Saving.loadBool("lollipopFarmPondDug") == true) {
            // Move all the lolligators
            for (var i = 0; i < this.pondLolligators.length; i++) {
                this.pondLolligators[i].move();
            }
            // Delete lolligators which need to be deleted
            for (var i = 0; i < this.pondLolligators.length; i++) {
                // If this lolligator should be deleted, then we delete it
                if (this.pondLolligators[i].shouldBeDeleted()) {
                    // Warn that it will be deleted
                    this.pondLolligators[i].willBeDeleted();
                    // Delete it
                    this.pondLolligators.splice(i, 1);
                    // Reduce i
                    i--;
                }
            }
            // Possibly add a lolligator if there wouldn't be more lolligators than we actually have (the more lollipops we have the more chance there is that one will be added)
            if (Random.oneChanceOutOf(Math.ceil(20 * (1 / Saving.loadNumber("lollipopFarmPondHowManyLolligators")))) && this.pondLolligators.length < Saving.loadNumber("lollipopFarmPondHowManyLolligators")) {
                // Choose a line
                lineIndex = Random.between(0, this.pondLines.length - 1);
                // If the line isn't used and the line above (if there is one) isn't used either
                if (this.pondLines[lineIndex].getIsUsed() == false && (lineIndex == 0 || this.pondLines[lineIndex - 1].getIsUsed() == false)) {
                    // Add a lolligator here
                    this.addPondLolligator(new PondLolligator(this.pondLines, lineIndex));
                }
            }
            // We update
            this.update();
            this.getGame().updatePlace();
        }
    };
    LollipopFarm.prototype.plantLollipops = function (howMany) {
        // If we have enough lollipops
        if (this.getGame().getLollipops().getCurrent() >= howMany) {
            this.getGame().getLollipops().add(-howMany);
            Saving.saveNumber("lollipopFarmLollipopsPlanted", Saving.loadNumber("lollipopFarmLollipopsPlanted") + howMany);
            this.getGame().calcLollipopFarmProduction();
            this.update();
            this.getGame().updatePlace();
        }
    };
    LollipopFarm.prototype.stopFeedingLolligators = function () {
        // We set the bool
        Saving.saveBool("lollipopFarmPondFeedingLolligators", false);
        // We update
        this.update();
        this.getGame().updatePlace();
    };
    LollipopFarm.prototype.update = function () {
        // Reset
        this.renderArea.resetAllButSize();
        // Draw the farm
        this.renderArea.drawArray(Database.getAscii("places/lollipopFarm/lollipopFarm"), 0, 5);
        // Draw the field stuff
        this.drawFieldStuff(1, 34);
        // Draw the mill stuff
        this.drawMillStuff(7, 0);
        // Draw the pond stuff
        this.drawPondStuff(50, 14);
    };
    LollipopFarm.prototype.updatePondConversionRate = function () {
        Saving.saveNumber("lollipopFarmPondConversionRate", Math.ceil(Saving.loadNumber("lollipopFarmPondHowManyLolligators") * 3 + Math.pow(1.3, Saving.loadNumber("lollipopFarmPondHowManyLolligators"))));
    };
    return LollipopFarm;
})(Place);
///<reference path="StatusBarResource.ts"/>
var Lollipops = (function (_super) {
    __extends(Lollipops, _super);
    // Constructor
    function Lollipops(game, savingPrefix) {
        _super.call(this, game, savingPrefix);
    }
    // Public methods
    Lollipops.prototype.getCurrentAsString = function (totalSize) {
        if (totalSize === void 0) { totalSize = 10; }
        var n = this.getCurrent();
        var size = totalSize;
        var base = "";
        var prefix = "";
        var suffix = "";
        // We set the base or return right now in some special cases
        if (n < 0)
            return "What, negative lollipops?!";
        else if (n == 1)
            return "You have 1 lollipop";
        else
            base = Algo.numberToStringButNicely(n);
        // How much space do we still have ?
        size = totalSize - base.length;
        // We set the suffix
        if (size >= 10) {
            suffix = " lollipops";
            // We add a suffix
            // How much space do we still have ?
            size = totalSize - base.length - suffix.length;
            // We set the prefix
            if (size >= 9)
                prefix = "You have ";
            else if (size >= 3)
                prefix = "-> ";
        }
        else if (size >= 3)
            suffix = " lp";
        // How much space do we still have ?
        size = totalSize - base.length - prefix.length - suffix.length;
        return prefix + base + suffix;
    };
    return Lollipops;
})(StatusBarResource);
///<reference path="Place.ts"/>
Saving.registerBool("lonelyHouseOpenBoxDone", false);
Saving.registerBool("lonelyHouseShakeBoxDone", false);
Saving.registerBool("lonelyHouseBreakLockDone", false);
Saving.registerBool("lonelyHouseKickBoxDone", false);
Saving.registerBool("lonelyHouseAskTheBoxToOpenItselfDone", false);
Saving.registerBool("lonelyHouseLureTheBoxWithACandyDone", false);
Saving.registerBool("lonelyHouseTakeTheBoxDone", false);
var LonelyHouse = (function (_super) {
    __extends(LonelyHouse, _super);
    // Constructor
    function LonelyHouse(game) {
        _super.call(this, game);
        this.renderArea = new RenderArea();
        this.renderArea.resizeFromArray(Database.getAscii("places/village/fifthHouse"), 0, 3);
        this.update();
    }
    // getRenderArea()
    LonelyHouse.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // Private methods
    LonelyHouse.prototype.askTheBoxToOpenItself = function () {
        Saving.saveBool("lonelyHouseAskTheBoxToOpenItselfDone", true);
        this.update();
        this.getGame().updatePlace();
    };
    LonelyHouse.prototype.breakLock = function () {
        Saving.saveBool("lonelyHouseBreakLockDone", true);
        this.update();
        this.getGame().updatePlace();
    };
    LonelyHouse.prototype.kickBox = function () {
        Saving.saveBool("lonelyHouseKickBoxDone", true);
        this.update();
        this.getGame().updatePlace();
    };
    LonelyHouse.prototype.lureTheBoxWithACandy = function () {
        Saving.saveBool("lonelyHouseLureTheBoxWithACandyDone", true);
        this.update();
        this.getGame().updatePlace();
    };
    LonelyHouse.prototype.openBox = function () {
        Saving.saveBool("lonelyHouseOpenBoxDone", true);
        this.update();
        this.getGame().updatePlace();
    };
    LonelyHouse.prototype.shakeBox = function () {
        Saving.saveBool("lonelyHouseShakeBoxDone", true);
        this.update();
        this.getGame().updatePlace();
    };
    LonelyHouse.prototype.takeTheBox = function () {
        // Change the bool
        Saving.saveBool("lonelyHouseTakeTheBoxDone", true);
        // We update
        this.update();
        // Select the candy box tab
        this.getGame().getStatusBar().selectTabByType(StatusBarTabType.CANDY_BOX);
        // Go to the candy box
        this.getGame().goToCandyBox();
    };
    LonelyHouse.prototype.update = function () {
        // Erase everything
        this.renderArea.resetAllButSize();
        // Back to the map button
        this.addBackToMainMapButton(this.renderArea, "lonelyHouseBackToTheMapButton");
        // Draw the house
        this.renderArea.drawArray(Database.getAscii("places/lonelyHouse"), 0, 3);
        // Draw the box
        if (Saving.loadBool("lonelyHouseTakeTheBoxDone") == false) {
            this.renderArea.drawArray(Database.getAscii("general/box"), 54, 9);
        }
        // Add the buttons or texts
        if (Saving.loadBool("lonelyHouseOpenBoxDone") == false) {
            this.getRenderArea().addAsciiRealButton(Database.getText("lonelyHouseOpenBox"), 4, 4, "lonelyHouseOpenBoxButton", Database.getTranslatedText("lonelyHouseOpenBox"), true, -1, null, false);
            this.getRenderArea().addLinkCall(".lonelyHouseOpenBoxButton", new CallbackCollection(this.openBox.bind(this)));
        }
        else {
            this.getRenderArea().drawString(Database.getText("lonelyHouseOpenBoxResult"), 4, 4);
            this.getRenderArea().drawString(Database.getTranslatedText("lonelyHouseOpenBoxResult"), 4, 5, true);
        }
        if (Saving.loadBool("lonelyHouseShakeBoxDone") == false) {
            this.getRenderArea().addAsciiRealButton(Database.getText("lonelyHouseShakeBox"), 4, 8, "lonelyHouseShakeBoxButton", Database.getTranslatedText("lonelyHouseShakeBox"), true, -1, null, false);
            this.getRenderArea().addLinkCall(".lonelyHouseShakeBoxButton", new CallbackCollection(this.shakeBox.bind(this)));
        }
        else {
            this.getRenderArea().drawString(Database.getText("lonelyHouseShakeBoxResult"), 4, 8);
            this.getRenderArea().drawString(Database.getTranslatedText("lonelyHouseShakeBoxResult"), 4, 9, true);
        }
        if (Saving.loadBool("lonelyHouseBreakLockDone") == false) {
            this.getRenderArea().addAsciiRealButton(Database.getText("lonelyHouseBreakLock"), 4, 12, "lonelyHouseBreakLockButton", Database.getTranslatedText("lonelyHouseBreakLock"), true, -1, null, false);
            this.getRenderArea().addLinkCall(".lonelyHouseBreakLockButton", new CallbackCollection(this.breakLock.bind(this)));
        }
        else {
            this.getRenderArea().drawString(Database.getText("lonelyHouseBreakLockResult"), 4, 12);
            this.getRenderArea().drawString(Database.getTranslatedText("lonelyHouseBreakLockResult"), 4, 13, true);
        }
        if (Saving.loadBool("lonelyHouseKickBoxDone") == false) {
            this.getRenderArea().addAsciiRealButton(Database.getText("lonelyHouseKickBox"), 4, 16, "lonelyHouseKickBoxButton", Database.getTranslatedText("lonelyHouseKickBox"), true, -1, null, false);
            this.getRenderArea().addLinkCall(".lonelyHouseKickBoxButton", new CallbackCollection(this.kickBox.bind(this)));
        }
        else {
            this.getRenderArea().drawString(Database.getText("lonelyHouseKickBoxResult"), 4, 16);
            this.getRenderArea().drawString(Database.getTranslatedText("lonelyHouseKickBoxResult"), 4, 17, true);
        }
        if (Saving.loadBool("lonelyHouseAskTheBoxToOpenItselfDone") == false) {
            this.getRenderArea().addAsciiRealButton(Database.getText("lonelyHouseAskTheBoxToOpenItself"), 4, 20, "lonelyHouseAskTheBoxToOpenItselfButton", Database.getTranslatedText("lonelyHouseAskTheBoxToOpenItself"), true, -1, null, false);
            this.getRenderArea().addLinkCall(".lonelyHouseAskTheBoxToOpenItselfButton", new CallbackCollection(this.askTheBoxToOpenItself.bind(this)));
        }
        else {
            this.getRenderArea().drawString(Database.getText("lonelyHouseAskTheBoxToOpenItselfResult"), 4, 20);
            this.getRenderArea().drawString(Database.getTranslatedText("lonelyHouseAskTheBoxToOpenItselfResult"), 4, 21, true);
        }
        if (Saving.loadBool("lonelyHouseLureTheBoxWithACandyDone") == false) {
            this.getRenderArea().addAsciiRealButton(Database.getText("lonelyHouseLureTheBoxWithACandy"), 4, 24, "lonelyHouseLureTheBoxWithACandyButton", Database.getTranslatedText("lonelyHouseLureTheBoxWithACandy"), true, -1, null, false);
            this.getRenderArea().addLinkCall(".lonelyHouseLureTheBoxWithACandyButton", new CallbackCollection(this.lureTheBoxWithACandy.bind(this)));
        }
        else {
            this.getRenderArea().drawString(Database.getText("lonelyHouseLureTheBoxWithACandyResult"), 4, 24);
            this.getRenderArea().drawString(Database.getTranslatedText("lonelyHouseLureTheBoxWithACandyResult"), 4, 25, true);
        }
        // Final button
        if (Saving.loadBool("lonelyHouseOpenBoxDone") &&
            Saving.loadBool("lonelyHouseShakeBoxDone") &&
            Saving.loadBool("lonelyHouseBreakLockDone") &&
            Saving.loadBool("lonelyHouseKickBoxDone") &&
            Saving.loadBool("lonelyHouseAskTheBoxToOpenItselfDone") &&
            Saving.loadBool("lonelyHouseLureTheBoxWithACandyDone")) {
            if (Saving.loadBool("lonelyHouseTakeTheBoxDone") == false) {
                this.getRenderArea().addAsciiRealButton(Database.getText("lonelyHouseTakeTheBox"), 6, 35, "lonelyHouseTakeTheBoxButton", Database.getTranslatedText("lonelyHouseTakeTheBox"), true, -1, null, false);
                this.getRenderArea().addLinkCall(".lonelyHouseTakeTheBoxButton", new CallbackCollection(this.takeTheBox.bind(this)));
            }
            else {
                this.getRenderArea().drawString(Database.getText("lonelyHouseTakeTheBoxResult"), 6, 35);
                this.getRenderArea().drawString(Database.getTranslatedText("lonelyHouseTakeTheBoxResult"), 6, 36, true);
            }
        }
    };
    return LonelyHouse;
})(Place);
///<reference path="QuestEntity.ts"/>
var LostTribeWarrior = (function (_super) {
    __extends(LostTribeWarrior, _super);
    // Constructor
    function LostTribeWarrior(quest, pos, watchedAreaPosition, watchedAreaPosition2) {
        _super.call(this, quest, pos, new Naming("A lost tribe warrior", "a lost tribe warrior"), new RenderArea(4, 4), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 0), new Pos(1, 1)), new CollisionBox(this, new Pos(0, 1), new Pos(4, 3))), new QuestEntityMovement());
        // Create the watched area
        this.watchedAreaPosition = watchedAreaPosition;
        this.watchedAreaPosition2 = watchedAreaPosition2;
        // Set gravity
        this.getQuestEntityMovement().setGravity(true);
        this.getQuestEntityMovement().setWormsLike(true);
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(200);
        this.setHp(200);
        // Set the ascii art and the transparent character
        this.getRenderArea().drawArray(Database.getAscii("places/quests/theHole/lostTribeWarrior"));
        this.setTransparency(new RenderTransparency(" "));
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("A tribal spear", "a tribal spear"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(6, 6))), 80));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setBetweenDelay(1, 2);
    }
    // update()
    LostTribeWarrior.prototype.update = function () {
        _super.prototype.update.call(this);
        // If the player is inside the watched area
        if (this.playerInsideWatchedArea()) {
            // We go towards the player
            this.goTowards(this.getRenderAreaCenter(), this.getQuest().getGame().getPlayer().getRenderAreaCenter());
        }
        else {
            // We heal ourselves
            this.heal(1);
        }
    };
    // willDie()
    LostTribeWarrior.prototype.willDie = function () {
        // Candies
        this.getQuest().getGame().getQuestLog().addMessage(new QuestLogMessage(this.getDeathMessage() + " (and found " + Algo.pluralFormat(this.getQuest().foundCandies(3000), " candy", " candies") + ")", this.getQuest().getCandiesFoundMessage()));
        // The tribal spear
        this.getQuest().foundGridOrEqItem(new QuestItemFound(this.getQuest(), "eqItemWeaponTribalSpear", "You found a tribal spear.", "You gain a tribal spear."));
    };
    // Private methods
    LostTribeWarrior.prototype.playerInsideWatchedArea = function () {
        if (this.getQuest().getGame().getPlayer().getGlobalPosition().x < this.watchedAreaPosition.x)
            return false;
        if (this.getQuest().getGame().getPlayer().getGlobalPosition().x > this.watchedAreaPosition2.x)
            return false;
        if (this.getQuest().getGame().getPlayer().getGlobalPosition().y < this.watchedAreaPosition.y)
            return false;
        if (this.getQuest().getGame().getPlayer().getGlobalPosition().y > this.watchedAreaPosition2.y)
            return false;
        // Else, the player is inside : return true
        return true;
    };
    return LostTribeWarrior;
})(QuestEntity);
var MainLoadingType;
(function (MainLoadingType) {
    MainLoadingType[MainLoadingType["NONE"] = 0] = "NONE";
    MainLoadingType[MainLoadingType["LOCAL"] = 1] = "LOCAL";
    MainLoadingType[MainLoadingType["FILE"] = 2] = "FILE";
})(MainLoadingType || (MainLoadingType = {}));
///<reference path="Place.ts"/>
// The default scroll
Saving.registerNumber("mainMapDefaultScroll", 400);
// Various steps
Saving.registerBool("mainMapDoneDesert", false);
Saving.registerBool("mainMapDoneBridge", false);
Saving.registerBool("mainMapDoneCaveEntrance", false);
Saving.registerBool("mainMapDonePier", false);
Saving.registerBool("mainMapDoneForest", false);
Saving.registerBool("mainMapDoneCastleEntrance", false);
var MainMap = (function (_super) {
    __extends(MainMap, _super);
    // Constructor
    function MainMap(game) {
        _super.call(this, game);
        this.renderArea = new RenderArea();
        this.load();
    }
    // willStopBeingDisplayed()
    MainMap.prototype.willStopBeingDisplayed = function () {
        Saving.saveNumber("mainMapDefaultScroll", this.getGame().getMainContentLocation().getScroll());
    };
    // Public getters
    MainMap.prototype.getDefaultScroll = function () {
        return Saving.loadNumber("mainMapDefaultScroll");
    };
    MainMap.prototype.getScrolling = function () {
        return true; // Scrolling is enabled
    };
    MainMap.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // Private methods
    MainMap.prototype.load = function () {
        // We erase the map
        this.renderArea.resetAllButSize();
        // We load the map itself
        this.renderArea.resizeFromArray(Database.getAscii("maps/map"));
        this.renderArea.drawArray(Database.getAscii("maps/map"));
        // We add various locations
        this.loadATree(143, 26);
        if (Saving.loadBool("gridItemPossessedFortressKey"))
            this.loadFortress(117, 39);
        this.loadTheDesert(114, 42);
        this.loadVillage(150, 36);
        this.loadLonelyHouse(159, 23);
        if (Saving.loadBool("TheCavePattern_TreasureMapSawMap") == true && Saving.loadBool("TheCavePattern_TreasureMapFoundTreasure") == false)
            this.loadTreasure(163, 29);
        if (Saving.loadBool("mainMapDoneDesert")) {
            this.loadFarm(115, 57);
            this.loadBridge(99, 61);
            this.loadCaveEntrance(52, 57);
            this.loadWishingWell(55, 66);
            if (Saving.loadBool("gridItemPossessedPogoStick") == false)
                this.loadMoutains(71, 52);
        }
        if (Saving.loadBool("mainMapDoneBridge"))
            this.loadSorceressHut(95, 68);
        if (Saving.loadBool("mainMapDoneCaveEntrance")) {
            this.loadPier(44, 33);
            this.loadForest(58, 30);
        }
        if (Saving.loadBool("mainMapDonePier")) {
            this.loadLighthouse(38, 16);
        }
        if (Saving.loadBool("mainMapDoneForest")) {
            this.loadCastleEntrance(88, 25);
            this.loadTheHole(126, 25);
        }
        if (Saving.loadBool("mainMapDoneCastleEntrance")) {
            this.loadCastle(87, 17);
        }
        if (Saving.loadBool("dragonDone")) {
            this.loadDragon(92, 11);
        }
    };
    // Private "go to" methods
    MainMap.prototype.goToATree = function () {
        this.getGame().setPlace(new ATree(this.getGame()));
    };
    MainMap.prototype.goToBridge = function () {
        if (this.getGame().canStartQuest())
            this.getGame().setPlace(new Bridge(this.getGame()));
    };
    MainMap.prototype.goToCastle = function () {
        this.getGame().goToCastle();
    };
    MainMap.prototype.goToDragon = function () {
        this.getGame().setPlace(new Dragon(this.getGame()));
    };
    MainMap.prototype.goToFarm = function () {
        Saving.saveBool("statusBarUnlockedLollipopFarm", true); // We unlock the farm tab
        this.getGame().updateStatusBar(true); // We update the status bar
        this.getGame().getStatusBar().selectTabByType(StatusBarTabType.FARM); // We select the farm tab
        this.getGame().goToLollipopFarm(); // We show the farm
    };
    MainMap.prototype.goToForest = function () {
        this.getGame().setPlace(new Forest(this.getGame()));
    };
    MainMap.prototype.goToFortress = function () {
        this.getGame().goToInsideFortress();
    };
    MainMap.prototype.goToLighthouse = function () {
        this.getGame().goToLighthouse();
    };
    MainMap.prototype.goToLonelyHouse = function () {
        this.getGame().setPlace(new LonelyHouse(this.getGame()));
    };
    MainMap.prototype.goToMoutains = function () {
        this.getGame().setPlace(new Moutains(this.getGame()));
    };
    MainMap.prototype.goToPier = function () {
        this.getGame().setPlace(new Pier(this.getGame()));
    };
    MainMap.prototype.goToSorceressHut = function () {
        this.getGame().goToSorceressHut();
    };
    MainMap.prototype.goToTheCave = function () {
        this.getGame().goToTheCave();
    };
    MainMap.prototype.goToTheDesert = function () {
        if (this.getGame().canStartQuest())
            this.getGame().setPlace(new Desert(this.getGame()));
    };
    MainMap.prototype.goToTheHole = function () {
        if (this.getGame().canStartQuest())
            this.getGame().setPlace(new OutsideTheHole(this.getGame()));
    };
    MainMap.prototype.goToTreasure = function () {
        this.getGame().setPlace(new Treasure(this.getGame()));
    };
    MainMap.prototype.goToWishingWell = function () {
        this.getGame().setPlace(new WishingWell(this.getGame()));
    };
    // Private "load" methods
    MainMap.prototype.loadATree = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("mapATreeButton", x + 2, x + 5, y, x + 1, x + 6, y + 1, x, x + 7, y + 2, x + 2, x + 5, y + 3, x + 2, x + 5, y + 4);
        // Comments
        this.renderArea.addFullComment(x - 2, y + 3, Database.getText("mapATreeComment"), Database.getTranslatedText("mapATreeComment"), "mapATreeComment");
        // Interactions
        this.renderArea.addLinkOver(".mapATreeButton, .mapATreeComment", ".mapATreeComment");
        this.renderArea.addLinkCall(".mapATreeButton, .mapATreeComment", new CallbackCollection(this.goToATree.bind(this)));
    };
    MainMap.prototype.loadBridge = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("mapBridgeButton", x, x + 3, y, x, x + 3, y + 1, x, x + 3, y + 2, x, x + 3, y + 3, x, x + 3, y + 4, x, x + 3, y + 5);
        // Comments
        this.renderArea.addFullComment(x + 2, y + 2, Database.getText("mapBridgeComment"), Database.getTranslatedText("mapBridgeComment"), "mapBridgeComment");
        // Interactions
        this.renderArea.addLinkOver(".mapBridgeButton, .mapBridgeComment", ".mapBridgeComment");
        this.renderArea.addLinkCall(".mapBridgeButton, .mapBridgeComment", new CallbackCollection(this.goToBridge.bind(this)));
    };
    MainMap.prototype.loadCastle = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("mapCastleButton", x + 2, x + 4, y, x + 17, x + 19, y, x + 1, x + 3, y + 1, x + 16, x + 18, y + 1, x, x + 4, y + 2, x + 15, x + 19, y + 2, x, x + 4, y + 3, x + 15, x + 19, y + 3, x, x + 19, y + 4, x, x + 19, y + 5, x, x + 19, y + 6);
        // Comments
        this.renderArea.addFullComment(x + 25, y + 4, Database.getText("mapCastleComment"), Database.getTranslatedText("mapCastleComment"), "mapCastleComment");
        // Interactions
        this.renderArea.addLinkOver(".mapCastleButton, .mapCastleComment", ".mapCastleComment");
        this.renderArea.addLinkCall(".mapCastleButton, .mapCastleComment", new CallbackCollection(this.goToCastle.bind(this)));
    };
    MainMap.prototype.loadCastleEntrance = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("mapCastleEntranceButton", x + 6, x + 11, y, x + 6, x + 11, y + 1, x, x + 17, y + 2, x, x + 17, y + 3);
        // Comments
        this.renderArea.addFullComment(x + 9, y + 4, Database.getText("mapCastleEntranceComment"), Database.getTranslatedText("mapCastleEntranceComment"), "mapCastleEntranceComment");
        // Interactions
        this.renderArea.addLinkOver(".mapCastleEntranceButton, .mapCastleEntranceComment", ".mapCastleEntranceComment");
        this.renderArea.addLinkCall(".mapCastleEntranceButton, .mapCastleEntranceComment", new CallbackCollection(this.getGame().goToCastleEntrance.bind(this.getGame())));
    };
    MainMap.prototype.loadCaveEntrance = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("mapCaveEntranceButton", x, x + 5, y);
        // Comments
        this.renderArea.addFullComment(x + 3, y + 1, Database.getText("mapCaveEntranceComment"), Database.getTranslatedText("mapCaveEntranceComment"), "mapCaveEntranceComment");
        // Interactions
        this.renderArea.addLinkOver(".mapCaveEntranceButton, .mapCaveEntranceComment", ".mapCaveEntranceComment");
        this.renderArea.addLinkCall(".mapCaveEntranceButton, .mapCaveEntranceComment", new CallbackCollection(this.goToTheCave.bind(this)));
    };
    MainMap.prototype.loadDragon = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("mapDragonButton", x + 5, x + 10, y, x + 4, x + 10, y + 1, x + 3, x + 7, y + 2, x + 2, x + 7, y + 3, x + 2, x + 7, y + 4, x + 1, x + 8, y + 5, x + 1, x + 8, y + 6, x + 1, x + 8, y + 7, x, x + 9, y + 8, x, x + 9, y + 9);
        // Comments
        this.renderArea.addFullComment(x + 5, y - 2, Database.getText("mapDragonComment"), Database.getTranslatedText("mapDragonComment"), "mapDragonComment");
        // Interactions
        this.renderArea.addLinkOver(".mapDragonButton, .mapDragonComment", ".mapDragonComment");
        this.renderArea.addLinkCall(".mapDragonButton, .mapDragonComment", new CallbackCollection(this.goToDragon.bind(this)));
    };
    MainMap.prototype.loadFarm = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("mapFarmButton", x + 5, x + 15, y, x + 5, x + 15, y + 1, x + 6, x + 16, y + 2, x + 6, x + 16, y + 3, x, x + 16, y + 3, x, x + 16, y + 4, x, x + 16, y + 5, x, x + 16, y + 6, x, x + 16, y + 7, x, x + 16, y + 8, x, x + 16, y + 9, x + 6, x + 16, y + 10);
        // Comments
        this.renderArea.addFullComment(x + 16, y + 5, Database.getText("mapFarmComment"), Database.getTranslatedText("mapFarmComment"), "mapFarmComment");
        // Interactions
        this.renderArea.addLinkOver(".mapFarmButton, .mapFarmComment", ".mapFarmComment");
        this.renderArea.addLinkCall(".mapFarmButton, .mapFarmComment", new CallbackCollection(this.goToFarm.bind(this)));
    };
    MainMap.prototype.loadForest = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("mapForestButton", x + 9, x + 11, y, x + 3, x + 12, y + 1, x + 2, x + 25, y + 2, x + 3, x + 43, y + 3, x + 1, x + 44, y + 4, x + 54, x + 56, y + 4, x, x + 47, y + 5, x + 53, x + 57, y + 5, x + 1, x + 56, y + 6, x + 2, x + 53, y + 7, x + 3, x + 52, y + 8, x + 7, x + 49, y + 9, x + 8, x + 48, y + 10, x + 17, x + 46, y + 11, x + 16, x + 45, y + 12, x + 17, x + 34, y + 13, x + 21, x + 35, y + 14, x + 23, x + 34, y + 15, x + 24, x + 25, y + 16);
        // Comments
        this.renderArea.addFullComment(x + 25, y + 7, Database.getText("mapForestComment"), Database.getTranslatedText("mapForestComment"), "mapForestComment");
        // Interactions
        this.renderArea.addLinkOver(".mapForestButton, .mapForestComment", ".mapForestComment");
        this.renderArea.addLinkCall(".mapForestButton, .mapForestComment", new CallbackCollection(this.goToForest.bind(this)));
    };
    MainMap.prototype.loadFortress = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("mapFortressButton", x + 1, x + 3, y, x + 10, x + 12, y, x, x + 4, y + 1, x + 9, x + 13, y + 1, x, x + 13, y + 2, x, x + 13, y + 3, x, x + 13, y + 4);
        // Comments
        this.renderArea.addFullComment(x + 7, y + 2, Database.getText("mapFortressComment"), Database.getTranslatedText("mapFortressComment"), "mapFortressComment");
        // Interactions
        this.renderArea.addLinkOver(".mapFortressButton, .mapFortressComment", ".mapFortressComment");
        this.renderArea.addLinkCall(".mapFortressButton, .mapFortressComment", new CallbackCollection(this.goToFortress.bind(this)));
    };
    MainMap.prototype.loadLighthouse = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("mapLighthouseButton", x + 1, x + 4, y, x, x + 5, y + 1, x, x + 5, y + 2, x, x + 5, y + 3, x, x + 5, y + 4, x, x + 5, y + 5, x, x + 5, y + 6, x, x + 5, y + 7, x, x + 5, y + 8, x, x + 5, y + 9);
        // Comments
        this.renderArea.addFullComment(x + 2, y + 3, Database.getText("mapLighthouseComment"), Database.getTranslatedText("mapLighthouseComment"), "mapLighthouseComment");
        // Interactions
        this.renderArea.addLinkOver(".mapLighthouseButton, .mapLighthouseComment", ".mapLighthouseComment");
        this.renderArea.addLinkCall(".mapLighthouseButton, .mapLighthouseComment", new CallbackCollection(this.goToLighthouse.bind(this)));
    };
    MainMap.prototype.loadLonelyHouse = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("mapLonelyHouseButton", x, x + 3, y, x, x + 3, y + 1);
        // Comments
        this.renderArea.addFullComment(x + 1, y - 3, Database.getText("mapLonelyHouseComment"), Database.getTranslatedText("mapLonelyHouseComment"), "mapLonelyHouseComment");
        // Interactions
        this.renderArea.addLinkOver(".mapLonelyHouseButton, .mapLonelyHouseComment", ".mapLonelyHouseComment");
        this.renderArea.addLinkCall(".mapLonelyHouseButton, .mapLonelyHouseComment", new CallbackCollection(this.goToLonelyHouse.bind(this)));
    };
    MainMap.prototype.loadMoutains = function (x, y) {
        // The "*" show that there's a pogo stick here
        this.renderArea.drawString("*", 71, 52);
        // Button
        this.renderArea.addMultipleAsciiButtons("mapMoutainsButton", x, x + 1, y);
        // Interactions
        this.renderArea.addLinkOver(".mapMoutainsButton, .mapMoutainsComment", ".mapMoutainsComment");
        this.renderArea.addLinkCall(".mapMoutainsButton, .mapMoutainsComment", new CallbackCollection(this.goToMoutains.bind(this)));
    };
    MainMap.prototype.loadPier = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("mapPierButton", x + 1, x + 3, y, x + 2, x + 3, y + 1, x, x + 7, y + 2, x + 4, x + 7, y + 3);
        // Comments
        this.renderArea.addFullComment(x + 4, y + 4, Database.getText("mapPierComment"), Database.getTranslatedText("mapPierComment"), "mapPierComment");
        // Interactions
        this.renderArea.addLinkOver(".mapPierButton, .mapPierComment", ".mapPierComment");
        this.renderArea.addLinkCall(".mapPierButton, .mapPierComment", new CallbackCollection(this.goToPier.bind(this)));
    };
    MainMap.prototype.loadSorceressHut = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("mapSorceressHutButton", x, x + 3, y, x, x + 3, y + 1);
        // Comments
        this.renderArea.addFullComment(x + 2, y + 3, Database.getText("mapSorceressHutComment"), Database.getTranslatedText("mapSorceressHutComment"), "mapSorceressHutComment");
        // Interactions
        this.renderArea.addLinkOver(".mapSorceressHutButton, .mapSorceressHutComment", ".mapSorceressHutComment");
        this.renderArea.addLinkCall(".mapSorceressHutButton, .mapSorceressHutComment", new CallbackCollection(this.goToSorceressHut.bind(this)));
    };
    MainMap.prototype.loadTheDesert = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("mapTheDesertButton", x, x + 29, y + 2, x, x + 29, y + 3, x, x + 29, y + 4, x, x + 29, y + 5, x, x + 29, y + 6, x, x + 29, y + 7, x, x + 28, y + 8, x, x + 27, y + 9, x + 1, x + 26, y + 10, x + 2, x + 25, y + 11);
        // Comments
        this.renderArea.addFullComment(x + 14, y + 6, Database.getText("mapTheDesertComment"), Database.getTranslatedText("mapTheDesertComment"), "mapTheDesertComment");
        // Interactions
        this.renderArea.addLinkOver(".mapTheDesertButton, .mapTheDesertComment", ".mapTheDesertComment");
        this.renderArea.addLinkCall(".mapTheDesertButton, .mapTheDesertComment", new CallbackCollection(this.goToTheDesert.bind(this)));
    };
    MainMap.prototype.loadTheHole = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("mapTheHoleButton", x + 1, x + 4, y, x + 1, x + 3, y + 1);
        // Comments
        this.renderArea.addFullComment(x + 2, y + 3, Database.getText("mapTheHoleComment"), Database.getTranslatedText("mapTheHoleComment"), "mapTheHoleComment");
        // Interactions
        this.renderArea.addLinkOver(".mapTheHoleButton, .mapTheHoleComment", ".mapTheHoleComment");
        this.renderArea.addLinkCall(".mapTheHoleButton, .mapTheHoleComment", new CallbackCollection(this.goToTheHole.bind(this)));
    };
    MainMap.prototype.loadTreasure = function (x, y) {
        // The button
        this.renderArea.addAsciiNinjaButton(x, x + 3, y, "mapTreasureButton");
        // Interactions
        this.renderArea.addLinkCall(".mapTreasureButton", new CallbackCollection(this.goToTreasure.bind(this)));
    };
    MainMap.prototype.loadVillage = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("mapVillageButton", x + 11, x + 19, y, x + 7, x + 19, y + 1, x + 4, x + 21, y + 2, x, x + 21, y + 3, x, x + 18, y + 4, x + 4, x + 18, y + 5, x + 8, x + 11, y + 6);
        // Comments
        this.renderArea.addFullComment(x + 11, y + 3, Database.getText("mapVillageComment"), Database.getTranslatedText("mapVillageComment"), "mapVillageComment");
        // Interactions
        this.renderArea.addLinkOver(".mapVillageButton, .mapVillageComment", ".mapVillageComment");
        this.renderArea.addLinkCall(".mapVillageButton, .mapVillageComment", new CallbackCollection(this.getGame().goToVillage.bind(this.getGame())));
    };
    MainMap.prototype.loadWishingWell = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("mapWishingWellButton", x, x + 3, y);
        // Comments
        this.renderArea.addFullComment(x + 1, y + 1, Database.getText("mapWishingWellComment"), Database.getTranslatedText("mapWishingWellComment"), "mapWishingWellComment");
        // Interactions
        this.renderArea.addLinkOver(".mapWishingWellButton, .mapWishingWellComment", ".mapWishingWellComment");
        this.renderArea.addLinkCall(".mapWishingWellButton, .mapWishingWellComment", new CallbackCollection(this.goToWishingWell.bind(this)));
    };
    return MainMap;
})(Place);
///<reference path="QuestEntity.ts"/>
var MediumFish = (function (_super) {
    __extends(MediumFish, _super);
    // Constructor
    function MediumFish(quest, pos) {
        _super.call(this, quest, pos, new Naming("A fish", "a fish"), new RenderArea(8, 4), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(1, 1), new Pos(7, 1)), new CollisionBox(this, new Pos(0, 2), new Pos(8, 1)), new CollisionBox(this, new Pos(1, 3), new Pos(7, 1))), new QuestEntityMovement(new Pos(-1, 0)));
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(30);
        this.setHp(30);
        // Set the ascii art
        this.getRenderArea().drawArray(Database.getAscii("places/quests/theSea/mediumFish"));
        // Set the transparency
        this.setTransparency(new RenderTransparency(" ", "%"));
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("Its fins", "its fins"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(10, 6))), 3));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setFixedDelay(4);
    }
    // willDie()
    MediumFish.prototype.willDie = function () {
        this.getQuest().getGame().getQuestLog().addMessage(new QuestLogMessage(this.getDeathMessage() + " (and found " + Algo.pluralFormat(this.getQuest().foundCandies(15), " candy", " candies") + ")", this.getQuest().getCandiesFoundMessage()));
    };
    return MediumFish;
})(QuestEntity);
///<reference path="EqItem.ts"/>
var MerchantHat = (function (_super) {
    __extends(MerchantHat, _super);
    // Constructor
    function MerchantHat() {
        _super.call(this, "eqItemHatMerchantHat", "eqItemHatMerchantHatName", "eqItemHatMerchantHatDescription", "eqItems/hats/merchantHat");
    }
    // Special ability
    MerchantHat.prototype.getSpecialAbility = function () {
        return "Multiplies the number of candies found in quests by 7 (merchant hat).";
    };
    // Candies found * 7
    MerchantHat.prototype.foundCandies = function (player, quest, howMany) {
        return howMany * 7;
    };
    return MerchantHat;
})(EqItem);
///<reference path="QuestEntity.ts"/>
var MiniShark = (function (_super) {
    __extends(MiniShark, _super);
    // Constructor
    function MiniShark(quest, pos) {
        _super.call(this, quest, pos, new Naming("A dangerous fish", "a dangerous fish"), new RenderArea(19, 5), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(8, 1), new Pos(2, 1)), new CollisionBox(this, new Pos(17, 1), new Pos(2, 1)), new CollisionBox(this, new Pos(5, 2), new Pos(14, 1)), new CollisionBox(this, new Pos(2, 3), new Pos(17, 1)), new CollisionBox(this, new Pos(0, 4), new Pos(12, 1)), new CollisionBox(this, new Pos(18, 4), new Pos(1, 1))), new QuestEntityMovement(new Pos(-1, 0)));
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(70);
        this.setHp(70);
        // Set the ascii art
        this.getRenderArea().drawArray(Database.getAscii("places/quests/theSea/miniShark"));
        // Set the transparency
        this.setTransparency(new RenderTransparency(" ", "%"));
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("Its teeth", "its teeth"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(21, 7))), 8));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setFixedDelay(2);
    }
    // willDie()
    MiniShark.prototype.willDie = function () {
        this.getQuest().getGame().getQuestLog().addMessage(new QuestLogMessage(this.getDeathMessage() + " (and found " + Algo.pluralFormat(this.getQuest().foundCandies(50 + 10 * Random.upTo(5)), " candy", " candies") + ")", this.getQuest().getCandiesFoundMessage()));
    };
    return MiniShark;
})(QuestEntity);
///<reference path="QuestEntity.ts"/>
var MonkeyWizard = (function (_super) {
    __extends(MonkeyWizard, _super);
    // Constructor
    function MonkeyWizard(quest, pos) {
        _super.call(this, quest, pos, new Naming("A monkey wizard", "a monkey wizard"), new RenderArea(4, 4), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(3, 0), new Pos(1, 1)), new CollisionBox(this, new Pos(1, 1), new Pos(3, 1)), new CollisionBox(this, new Pos(0, 2), new Pos(4, 1)), new CollisionBox(this, new Pos(0, 3), new Pos(4, 1))), new QuestEntityMovement());
        // Set the timers
        this.timer = 0;
        this.bigTimer = 0;
        // At first we're going left
        this.goingLeft = true;
        // Set gravity
        this.getQuestEntityMovement().setGravity(true);
        this.getQuestEntityMovement().setWormsLike(false);
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(300);
        this.setHp(300);
        // Set the ascii art and the transparent character
        this.getRenderArea().drawArray(Database.getAscii("places/quests/monkeyWizard/monkeyWizard"));
        this.setTransparency(new RenderTransparency(" "));
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("Its staff", "its staff"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(6, 6))), 3));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setFixedDelay(1);
    }
    // update()
    MonkeyWizard.prototype.update = function () {
        _super.prototype.update.call(this);
        // Is the monkey angry?
        var angry = (this.getHp() < 70 ? true : false);
        // Store the player position
        var playerPos = this.getQuest().getGame().getPlayer().getGlobalPosition();
        // Handle the timer
        if (this.timer < 80)
            this.timer += 1;
        else
            this.timer = 0;
        // Handle the big timer
        if (this.bigTimer < 350)
            this.bigTimer += 1;
        else
            this.bigTimer = 0;
        // Cast spells depending on the timer
        if (this.timer == 80 ||
            this.timer == 12 ||
            this.timer == 24 ||
            this.timer == 36 ||
            this.timer == 48 ||
            (angry && this.timer == 6) ||
            (angry && this.timer == 18) ||
            (angry && this.timer == 30) ||
            (angry && this.timer == 42) ||
            (angry && this.timer == 54)) {
            this.castSpell(false); // Not stored
        }
        else if (this.timer == 60 || this.timer == 64 || this.timer == 68 || this.timer == 72 || this.timer == 76 && this.bigTimer < 300) {
            this.castSpell(true); // Stored
        }
        // If the player is near us (< 9) horizontally
        if (Math.abs(playerPos.x - this.getGlobalPosition().x) < 9) {
            // We jump (hoping to jump above the player)
            this.jump3();
        }
        // If the player is even more near us (< 15) horizontally
        if (Math.abs(playerPos.x - this.getGlobalPosition().x) < 15) {
            // If we're going left
            if (this.goingLeft) {
                // If we're on the right of the quest
                if (this.getGlobalPosition().x > 25)
                    this.goLeft();
                else {
                    this.goRight();
                    this.goingLeft = false;
                }
            }
            else {
                // If the player is on the left
                if (playerPos.x < this.getGlobalPosition().x) {
                    // If we're on the left side of the quest
                    if (this.getGlobalPosition().x < 75)
                        this.goRight();
                    else {
                        this.goLeft();
                        this.goingLeft = true;
                    }
                }
                else if (this.getGlobalPosition().x > 25) {
                    // We go left
                    this.goLeft();
                }
                else
                    this.dontMove();
            }
        }
        else
            this.dontMove();
    };
    // willDie()
    MonkeyWizard.prototype.willDie = function () {
        // Candies
        this.getQuest().getGame().getQuestLog().addMessage(new QuestLogMessage(this.getDeathMessage() + " (and found " + Algo.pluralFormat(this.getQuest().foundCandies(1000), " candy", " candies") + ")", this.getQuest().getCandiesFoundMessage()));
        // The monkey wizard staff
        this.getQuest().foundGridOrEqItem(new QuestItemFound(this.getQuest(), "eqItemWeaponMonkeyWizardStaff", "You found a staff.", "You gain the monkey wizard staff."));
    };
    // Private methods
    MonkeyWizard.prototype.castSpell = function (stored) {
        var ball = new MonkeyWizardMagicalPurpleBall(this.getQuest(), this.getGlobalPosition().plus(new Pos(3, 0)), new Naming("An magical purple ball", "a magical purple ball"), (stored ? new Color(ColorType.MONKEY_WIZARD_BALL_STORED) : new Color(ColorType.MONKEY_WIZARD_BALL)), new Pos(2, 1), 15, this.getAndPossiblyCreateSpellCastingDamageReason(new Naming("An magical purple ball", "a magical purple ball")), (stored ? 350 - this.bigTimer : null));
        // If we're not going to be stored
        if (stored == false) {
            // Target the player
            ball.setTargetTypeTargetEntity(this.getQuest().getGame().getPlayer());
        }
        else {
            // Target the roof
            ball.setTargetTypeTargetPosition(new Pos(Random.between(1, 99), Random.between(4, 9)));
        }
        // Add it to the quest
        this.getQuest().addEntity(ball);
    };
    MonkeyWizard.prototype.dontMove = function () {
        this.getQuestEntityMovement().setOffset(new Pos(0, 0));
    };
    MonkeyWizard.prototype.goLeft = function () {
        this.getQuestEntityMovement().setOffset(new Pos(-1, 0));
    };
    MonkeyWizard.prototype.goRight = function () {
        this.getQuestEntityMovement().setOffset(new Pos(1, 0));
    };
    MonkeyWizard.prototype.jump3 = function () {
        this.jump(3);
    };
    return MonkeyWizard;
})(QuestEntity);
///<reference path="Fireball.ts"/>
var MonkeyWizardMagicalPurpleBall = (function (_super) {
    __extends(MonkeyWizardMagicalPurpleBall, _super);
    // Constructor
    function MonkeyWizardMagicalPurpleBall(quest, pos, naming, color, size, damage, questEntityDamageReason, timer) {
        // Call the mother class constructor
        _super.call(this, quest, pos, naming, color, size, damage, questEntityDamageReason);
        // Set the timer
        this.timer = timer;
    }
    // Public methods
    MonkeyWizardMagicalPurpleBall.prototype.update = function () {
        // If the timer isn't null (which means we should be stored and then go down)
        if (this.timer != null) {
            // If the timer is > 0, decrease it
            if (this.timer > 0)
                this.timer -= 1;
            else {
                this.timer = null; // No more timer
                this.setTargetTypeTargetEntity(this.getQuest().getGame().getPlayer());
            }
        }
        // Call the fireball update method
        _super.prototype.update.call(this);
    };
    return MonkeyWizardMagicalPurpleBall;
})(Fireball);
///<reference path="Quest.ts"/>
var MonkeyWizardQuest = (function (_super) {
    __extends(MonkeyWizardQuest, _super);
    // Constructor
    function MonkeyWizardQuest(game) {
        _super.call(this, game);
        // Resize the quest
        this.resizeQuest(100, 20);
        // Add collision boxes around
        this.addPlayerCollisionBoxes(true, true, true, true);
        // Add the player
        this.getGame().getPlayer().loadCandyBoxCharacter(this);
        this.getGame().getPlayer().setGlobalPosition(new Pos(0, 17));
        this.configPlayerOrClone(this.getGame().getPlayer());
        this.addEntity(this.getGame().getPlayer());
        // Add the roof and the floor
        this.addRoofAndFloor();
        // Add the monkey wizard
        this.addMonkeyWizard(new Pos(88, 16));
        // Add the message
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You challenged the monkey wizard. Let the fight begin!"));
    }
    // Public methods
    MonkeyWizardQuest.prototype.configPlayerOrClone = function (entity) {
        entity.setQuestEntityMovement(new QuestEntityMovement(new Pos(1, 0)));
        entity.getQuestEntityMovement().setGravity(true);
        entity.getQuestEntityMovement().setWormsLike(true);
    };
    MonkeyWizardQuest.prototype.endQuest = function (win) {
        // We add some messages
        if (win) {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You continue to explore the cave."));
        }
        // We call the endQuest method of our mother class
        _super.prototype.endQuest.call(this, win);
    };
    MonkeyWizardQuest.prototype.update = function () {
        if (this.getQuestEnded() == false) {
            // Test if the player is dead, if so end the quest (he won) and return
            if (this.getGame().getPlayer().shouldDie()) {
                this.endQuest(true); // true because we always win
                return;
            }
            // Update entities
            this.updateEntities();
        }
        // Draw
        this.preDraw();
        this.getRenderArea().drawArray(Database.getAscii("places/quests/monkeyWizard/roof"), this.getRealQuestPosition().x, this.getRealQuestPosition().y);
        this.drawEntities();
        this.drawAroundQuest();
        this.addExitQuestButton(new CallbackCollection(this.endQuest.bind(this, true), this.getGame().goToTheCave.bind(this.getGame())), "buttonExitQuestKeeping");
        this.postDraw();
    };
    // Private methods
    MonkeyWizardQuest.prototype.addMonkeyWizard = function (pos) {
        var monkey = new MonkeyWizard(this, pos);
        monkey.setHealthBar(new QuestEntityHealthBar(monkey, new Pos(100, 1), new Pos(0, 5), QuestEntityHealthBarPositionType.FIXED, false, true, BarType.HEALTH));
        this.addEntity(monkey);
    };
    MonkeyWizardQuest.prototype.addRoofAndFloor = function () {
        // Create the wall entity
        var wall = new Wall(this, new Pos(0, 0));
        // Add the roof
        wall.addBox(new Pos(0, 0), new Pos(100, 2));
        wall.addBox(new Pos(0, 2), new Pos(7, 1));
        wall.addBox(new Pos(18, 2), new Pos(50, 1));
        wall.addBox(new Pos(71, 2), new Pos(29, 1));
        wall.addBox(new Pos(0, 3), new Pos(2, 1));
        wall.addBox(new Pos(24, 3), new Pos(21, 1));
        wall.addBox(new Pos(83, 3), new Pos(17, 1));
        wall.addBox(new Pos(0, 4), new Pos(1, 1));
        wall.addBox(new Pos(99, 4), new Pos(1, 1));
        // Add the floor
        wall.addBox(new Pos(-20, 20), new Pos(120, 1));
        // Add the wall entity
        this.addEntity(wall);
    };
    return MonkeyWizardQuest;
})(Quest);
///<reference path="MonkeyWizardStaffMotherClass.ts"/>
var MonkeyWizardStaff = (function (_super) {
    __extends(MonkeyWizardStaff, _super);
    // Constructor
    function MonkeyWizardStaff() {
        _super.call(this, "eqItemWeaponMonkeyWizardStaff", "eqItemWeaponMonkeyWizardStaffName", "eqItemWeaponMonkeyWizardStaffDescription", "eqItems/weapons/monkeyWizardStaff");
        // Set the timer
        this.timer = 0;
    }
    // Public getters
    MonkeyWizardStaff.prototype.getQuestEntityWeapon = function (quest, player) {
        var qew = new QuestEntityWeapon(quest, player, new Naming("The monkey wizard staff", "the monkey wizard staff"), player.getClassicCollisionBoxCollection(), 2);
        qew.getCloseCombatDelay().setFixedDelay(1);
        return qew;
    };
    // update()
    MonkeyWizardStaff.prototype.update = function (player, quest) {
        // Handle the timer
        if (this.timer < 10)
            this.timer += 1;
        else {
            this.timer = 0;
            var ent = this.getRandomEnemy(player, quest);
            if (ent != null)
                this.castPurpleBall(player, quest, ent);
        }
    };
    return MonkeyWizardStaff;
})(MonkeyWizardStaffMotherClass);
///<reference path="QuestEntity.ts"/>
var Monster = (function (_super) {
    __extends(Monster, _super);
    // Constructor
    function Monster(quest, globalPosition) {
        // Call the mother constructor
        _super.call(this, quest, globalPosition, new Naming("The monster", "the monster"), new RenderArea(13, 4), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 0), new Pos(13, 1)), new CollisionBox(this, new Pos(1, 0), new Pos(11, 1)), new CollisionBox(this, new Pos(2, 0), new Pos(9, 1)), new CollisionBox(this, new Pos(3, 0), new Pos(7, 1))), new QuestEntityMovement());
        // At first, no egg was destroyed
        this.anEggWasDestroyed = false;
        // Set the ascii art
        this.getRenderArea().drawArray(Database.getAscii("places/quests/castle/room3/monster"));
        this.setTransparency(new RenderTransparency(" ", "%"));
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("??", "??"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(15, 6))), 10000));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setFixedDelay(0);
    }
    // update()
    Monster.prototype.update = function () {
        // If no egg was destroyed, we go towards the player but we stay on the roof
        if (this.anEggWasDestroyed == false) {
            this.goTowards(this.getGlobalPosition().plus(new Pos(6, 4)), this.getQuest().getGame().getPlayer().getGlobalPosition().plus(new Pos(1, 0)), 0, new Pos(2, 0), true);
        }
        else {
            this.goTowards(this.getGlobalPosition().plus(new Pos(6, 4)), this.getQuest().getGame().getPlayer().getGlobalPosition().plus(new Pos(1, 0)), 0, new Pos(4, 4));
        }
        // Call the mother classe update
        _super.prototype.update.call(this);
    };
    // Public methods
    Monster.prototype.eggDestroyed = function () {
        this.anEggWasDestroyed = true;
    };
    return Monster;
})(QuestEntity);
///<reference path="QuestEntity.ts"/>
var Mosquito = (function (_super) {
    __extends(Mosquito, _super);
    // Constructor
    function Mosquito(quest, pos, groundYPosition) {
        _super.call(this, quest, pos, new Naming("A forest mosquito", "a forest mosquito"), new RenderArea(1, 1), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 0), new Pos(1, 1))), new QuestEntityMovement());
        // Set the ground y position from the value given in parameter
        this.groundYPosition = groundYPosition;
        // Set the perfect position above the ground
        this.perfectYPositionAboveGround = Random.between(8, 13);
        // Set gravity
        this.getQuestEntityMovement().setGravity(false);
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(1);
        this.setHp(1);
        // Set the ascii art (well, it's actually just a ".")
        this.getRenderArea().drawString(".");
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("A proboscis", "a proboscis"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(3, 3))), 12));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setOnceThenWaitDelay(20);
    }
    // update()
    Mosquito.prototype.update = function () {
        // Calculate the distance from the player
        var distanceFromPlayer = this.getGlobalPosition().getDistance(this.getQuest().getGame().getPlayer().getGlobalPosition().plus(new Pos(1, 0)));
        // Go towards the player
        this.goTowards(this.getGlobalPosition(), this.getQuest().getGame().getPlayer().getGlobalPosition().plus(new Pos(1, 0)));
        // Call the mother class update method
        _super.prototype.update.call(this);
    };
    return Mosquito;
})(QuestEntity);
///<reference path="Place.ts"/>
var Moutains = (function (_super) {
    __extends(Moutains, _super);
    // Constructor
    function Moutains(game) {
        _super.call(this, game);
        // The render area
        this.renderArea = new RenderArea();
        this.renderArea.resizeFromArray(Database.getAscii("places/mountains"), 0, 10);
        this.update();
    }
    // getRenderArea()
    Moutains.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // Private methods
    Moutains.prototype.getPogoStick = function () {
        // Get the pogo stick
        this.getGame().gainItem("gridItemPossessedPogoStick");
        // Update
        this.update();
        this.getGame().updatePlace();
    };
    Moutains.prototype.update = function () {
        // Erase everything
        this.renderArea.resetAllButSize();
        // Back to the map button
        this.addBackToMainMapButton(this.renderArea, "mountainsBackToTheMapButton");
        // Draw the moutains
        this.renderArea.drawArray(Database.getAscii("places/mountains"), 0, 3);
        // If we didn't get the pogo stick yet
        if (Saving.loadBool("gridItemPossessedPogoStick") == false) {
            // Add the "*" showing that there's a pogo stick here
            this.renderArea.drawString("*", 52, 11);
            // Draw the text
            this.renderArea.drawString(Database.getText("mountainsText0"), 19, 22);
            this.renderArea.drawString(Database.getText("mountainsText1"), 19, 23);
            // Add the button
            this.renderArea.addAsciiRealButton(Database.getText("mountainsTextButton"), 19, 25, "mountainsClimbButton", Database.getTranslatedText("mountainsTextButton"));
            this.renderArea.addLinkCall(".mountainsClimbButton", new CallbackCollection(this.getPogoStick.bind(this)));
            // Draw the translated text
            this.renderArea.drawString(Database.getTranslatedText("mountainsText0"), 19, 27, true);
            this.renderArea.drawString(Database.getTranslatedText("mountainsText1"), 19, 28, true);
        }
        else {
            this.renderArea.drawString(Database.getText("mountainsTextAfter"), 19, 22);
            this.renderArea.drawString(Database.getTranslatedText("mountainsTextAfter"), 19, 24, true);
        }
    };
    return Moutains;
})(Place);
var Naming = (function () {
    // Constructor
    function Naming(beginning, anywhere) {
        if (anywhere === void 0) { anywhere = null; }
        this.beginning = beginning;
        if (anywhere != null)
            this.anywhere = anywhere;
        else
            this.anywhere = this.beginning;
    }
    // Public getters
    Naming.prototype.getAnywhere = function () {
        return this.anywhere;
    };
    Naming.prototype.getBeginning = function () {
        return this.beginning;
    };
    return Naming;
})();
///<reference path="QuestEntitySpell.ts"/>
var ObsidianBrick = (function (_super) {
    __extends(ObsidianBrick, _super);
    // Constructor
    function ObsidianBrick(quest, pos, hp) {
        _super.call(this, quest, pos, new Naming("An obsidian brick", "an obsidian brick"), null, new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 0), new Pos(2, 1))), new QuestEntityMovement());
        // Set gravity
        this.getQuestEntityMovement().setGravity(true);
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(hp);
        this.setHp(hp);
        // Add the color
        this.addColor(new QuestEntitySpellColor(this.getQuest(), new Pos(0, 0), new Pos(2, 1), new Color(ColorType.PLAYER_OBSIDIAN_BRICK)));
    }
    return ObsidianBrick;
})(QuestEntitySpell);
///<reference path="QuestEntity.ts"/>
var OctopusKing = (function (_super) {
    __extends(OctopusKing, _super);
    // Constructor
    function OctopusKing(quest, pos) {
        _super.call(this, quest, pos, new Naming("The Octopus King", "the Octopus King"), new RenderArea(6, 4), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(2, 0), new Pos(2, 1)), new CollisionBox(this, new Pos(1, 1), new Pos(4, 1)), new CollisionBox(this, new Pos(1, 2), new Pos(4, 1)), new CollisionBox(this, new Pos(0, 3), new Pos(6, 1))), new QuestEntityMovement());
        // Set gravity
        this.getQuestEntityMovement().setGravity(true);
        this.getQuestEntityMovement().setWormsLike(false);
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(380);
        this.setHp(380);
        // Set the ascii art and the transparent character
        this.getRenderArea().drawArray(Database.getAscii("places/quests/octopusKing/octopusKing"));
        this.setTransparency(new RenderTransparency(" "));
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("Its tentacles", "its tentacles"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(8, 6))), 16));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setFixedDelay(3);
    }
    // update()
    OctopusKing.prototype.update = function () {
        // Go towards the player
        this.goTowards(this.getGlobalPosition(), this.getQuest().getGame().getPlayer().getGlobalPosition(), 0, new Pos(1, 0));
        // Call the mother class update method
        _super.prototype.update.call(this);
    };
    // willDie()
    OctopusKing.prototype.willDie = function () {
        // Candies
        this.getQuest().getGame().getQuestLog().addMessage(new QuestLogMessage(this.getDeathMessage() + " (and found " + Algo.pluralFormat(this.getQuest().foundCandies(4000), " candy", " candies") + ")", this.getQuest().getCandiesFoundMessage()));
        // The monkey wizard staff
        this.getQuest().foundGridOrEqItem(new QuestItemFound(this.getQuest(), "eqItemHatOctopusKingCrown", "You found the Octopus King crown.", "You gain the Octopus King crown."));
    };
    return OctopusKing;
})(QuestEntity);
///<reference path="EqItem.ts"/>
var OctopusKingCrown = (function (_super) {
    __extends(OctopusKingCrown, _super);
    // Constructor
    function OctopusKingCrown() {
        _super.call(this, "eqItemHatOctopusKingCrown", "eqItemHatOctopusKingCrownName", "eqItemHatOctopusKingCrownDescription", "eqItems/hats/octopusKingCrown");
    }
    // Special ability
    OctopusKingCrown.prototype.getSpecialAbility = function () {
        return "You are a lot more confident.";
    };
    return OctopusKingCrown;
})(EqItem);
///<reference path="EqItem.ts"/>
var OctopusKingCrownWithJaspers = (function (_super) {
    __extends(OctopusKingCrownWithJaspers, _super);
    // Constructor
    function OctopusKingCrownWithJaspers() {
        _super.call(this, "eqItemHatOctopusKingCrownWithJaspers", "eqItemHatOctopusKingCrownWithJaspersName", "eqItemHatOctopusKingCrownWithJaspersDescription", "eqItems/hats/octopusKingCrownWithJaspers");
        // The timer (to avoid casting fireballs too often..)
        this.currentTimer = 0;
        this.maxTimer = 3;
    }
    // Special ability
    OctopusKingCrownWithJaspers.prototype.getSpecialAbility = function () {
        return "Randomly cast powerful fireballs around you (Octopus King crown with jaspers).";
    };
    // update
    OctopusKingCrownWithJaspers.prototype.update = function (player, quest) {
        this.currentTimer += 1;
        // If the timer is ready
        if (this.currentTimer >= this.maxTimer) {
            // Cast the fireball
            this.castFireball(player, quest);
            // Reset the timer
            this.currentTimer = 0;
        }
    };
    // Private methods
    OctopusKingCrownWithJaspers.prototype.castFireball = function (player, quest) {
        // Create the fireball
        var fireball = new Fireball(quest, player.getSpellCastingPosition(), new Naming("A small fireball", "a small fireball"), new Color(ColorType.RED_ENCHANTED_GLOVES_FIREBALL), new Pos(4, 2), 18, player.getAndPossiblyCreateSpellCastingDamageReason(new Naming("A fireball", "a fireball")));
        // Set the direction
        fireball.setTargetTypeNoTarget(Algo.getRandomNotImmobileDirectionUpToThisSpeed(1).multiply(new Pos(2, 2)));
        // Add the entity
        quest.addEntity(fireball);
    };
    return OctopusKingCrownWithJaspers;
})(EqItem);
///<reference path="EqItem.ts"/>
var OctopusKingCrownWithObsidian = (function (_super) {
    __extends(OctopusKingCrownWithObsidian, _super);
    // Constructor
    function OctopusKingCrownWithObsidian() {
        _super.call(this, "eqItemHatOctopusKingCrownWithObsidian", "eqItemHatOctopusKingCrownWithObsidianName", "eqItemHatOctopusKingCrownWithObsidianDescription", "eqItems/hats/octopusKingCrownWithObsidian");
        // Reset the timer for the first time
        this.resetTimer();
    }
    // Special ability
    OctopusKingCrownWithObsidian.prototype.getSpecialAbility = function () {
        return "Summon the Octopus King once in a while to help you.";
    };
    // update
    OctopusKingCrownWithObsidian.prototype.update = function (player, quest) {
        this.currentTimer -= 1;
        // If the timer is ready
        if (this.currentTimer <= 0) {
            // Summon the king
            if (this.summonOctopusKing(player, quest)) {
                // If it worked, reset the timer
                this.resetTimer();
            }
        }
    };
    // Private methods
    OctopusKingCrownWithObsidian.prototype.summonOctopusKing = function (player, quest) {
        // Create the king
        var king = new PlayerSummonedOctopusKing(quest, Random.fromPosition(new Pos(quest.getRealQuestSize().x - 1, quest.getRealQuestSize().y - 1)));
        // If we manage to add it, we return true
        if (quest.addEntity(king))
            return true;
        // No king added, we return false
        return false;
    };
    OctopusKingCrownWithObsidian.prototype.resetTimer = function () {
        this.currentTimer = Random.between(60, 120);
    };
    return OctopusKingCrownWithObsidian;
})(EqItem);
///<reference path="Quest.ts"/>
var OctopusKingQuest = (function (_super) {
    __extends(OctopusKingQuest, _super);
    // Constructor
    function OctopusKingQuest(game) {
        _super.call(this, game);
        // Resize the quest
        this.resizeQuest(100, 20);
        // Add collision boxes around
        this.addPlayerCollisionBoxes(true, true, true, true);
        // Add the player
        this.getGame().getPlayer().loadCandyBoxCharacter(this);
        this.getGame().getPlayer().setGlobalPosition(new Pos(0, 17));
        this.configPlayerOrClone(this.getGame().getPlayer());
        this.addEntity(this.getGame().getPlayer());
        // Add the roof and the floor
        this.addRoofAndFloor();
        // Add the monkey wizard
        this.addOctopusKing(new Pos(88, 16));
        // Add the message
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You challenged the Octopus King. Let the fight begin!"));
    }
    // Public methods
    OctopusKingQuest.prototype.configPlayerOrClone = function (entity) {
        entity.setQuestEntityMovement(new QuestEntityMovement(new Pos(1, 0)));
        entity.getQuestEntityMovement().setGravity(true);
        entity.getQuestEntityMovement().setWormsLike(true);
    };
    OctopusKingQuest.prototype.endQuest = function (win) {
        // We add some messages
        if (win) {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You continue to explore the cave."));
        }
        // We call the endQuest method of our mother class
        _super.prototype.endQuest.call(this, win);
    };
    OctopusKingQuest.prototype.update = function () {
        if (this.getQuestEnded() == false) {
            // Test if the player is dead, if so end the quest (he won) and return
            if (this.getGame().getPlayer().shouldDie()) {
                this.endQuest(true); // true because we always win
                return;
            }
            // Update entities
            this.updateEntities();
        }
        // Draw
        this.preDraw();
        this.getRenderArea().drawArray(Database.getAscii("places/quests/octopusKing/roof"), this.getRealQuestPosition().x, this.getRealQuestPosition().y);
        this.drawEntities();
        this.drawAroundQuest();
        this.addExitQuestButton(new CallbackCollection(this.endQuest.bind(this, true), this.getGame().goToTheCave.bind(this.getGame())), "buttonExitQuestKeeping");
        this.postDraw();
    };
    // Private methods
    OctopusKingQuest.prototype.addOctopusKing = function (pos) {
        var king = new OctopusKing(this, pos);
        king.setHealthBar(new QuestEntityHealthBar(king, new Pos(100, 1), new Pos(0, 5), QuestEntityHealthBarPositionType.FIXED, false, true, BarType.HEALTH));
        this.addEntity(king);
    };
    OctopusKingQuest.prototype.addRoofAndFloor = function () {
        // Create the wall entity
        var wall = new Wall(this, new Pos(0, 0));
        // Add the roof
        wall.addBox(new Pos(0, 0), new Pos(100, 2));
        wall.addBox(new Pos(0, 2), new Pos(7, 1));
        wall.addBox(new Pos(18, 2), new Pos(50, 1));
        wall.addBox(new Pos(71, 2), new Pos(29, 1));
        wall.addBox(new Pos(0, 3), new Pos(2, 1));
        wall.addBox(new Pos(24, 3), new Pos(21, 1));
        wall.addBox(new Pos(83, 3), new Pos(17, 1));
        wall.addBox(new Pos(0, 4), new Pos(1, 1));
        wall.addBox(new Pos(99, 4), new Pos(1, 1));
        // Add the floor
        wall.addBox(new Pos(-20, 20), new Pos(120, 1));
        // Add the wall entity
        this.addEntity(wall);
    };
    return OctopusKingQuest;
})(Quest);
///<reference path="Place.ts"/>
var OutsideTheHole = (function (_super) {
    __extends(OutsideTheHole, _super);
    // Constructor
    function OutsideTheHole(game) {
        _super.call(this, game);
        // The render area
        this.renderArea = new RenderArea();
        this.renderArea.resizeFromArray(Database.getAscii("places/outsideTheHole"), 0, 4);
        this.update();
    }
    // getRenderArea()
    OutsideTheHole.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // Private methods 
    OutsideTheHole.prototype.jump = function () {
        this.getGame().setPlace(new TheHole(this.getGame()));
    };
    OutsideTheHole.prototype.update = function () {
        // Erase everything
        this.renderArea.resetAllButSize();
        // Back to the map button
        this.addBackToMainMapButton(this.renderArea, "theHoleBackToTheMapButton");
        // Draw the ascii
        this.renderArea.drawArray(Database.getAscii("places/outsideTheHole"), 0, 3);
        // Add the button to jump in the hole
        this.renderArea.addAsciiRealButton(Database.getText("outsideTheHoleButton"), 34, 23, "outsideTheHoleButton", Database.getTranslatedText("outsideTheHoleButton"), true);
        this.renderArea.addLinkCall(".outsideTheHoleButton", new CallbackCollection(this.jump.bind(this)));
    };
    return OutsideTheHole;
})(Place);
///<reference path="StatusBarResource.ts"/>
var PainsAuChocolat = (function (_super) {
    __extends(PainsAuChocolat, _super);
    // Constructor
    function PainsAuChocolat(game, savingPrefix) {
        _super.call(this, game, savingPrefix);
    }
    // Public methods
    PainsAuChocolat.prototype.getCurrentAsString = function (totalSize) {
        if (totalSize === void 0) { totalSize = 10; }
        var n = this.getCurrent();
        var size = totalSize;
        var base = "";
        var prefix = "";
        var suffix = "";
        // We set the base or return right now in some special cases
        if (n < 0)
            return "What, negative pains au chocolat?!";
        else if (n == 1)
            return "-> 1 pain au chocolat";
        else
            base = Algo.numberToStringButNicely(n);
        // How much space do we still have ?
        size = totalSize - base.length;
        // We set the suffix
        if (size >= 18) {
            suffix = " pains au chocolat";
            // We add a suffix
            // How much space do we still have ?
            size = totalSize - base.length - suffix.length;
            // We set the prefix
            if (size >= 9)
                prefix = "You have ";
            else if (size >= 3)
                prefix = "-> ";
        }
        else if (size >= 3)
            suffix = " pc";
        // How much space do we still have ?
        size = totalSize - base.length - prefix.length - suffix.length;
        return prefix + base + suffix;
    };
    return PainsAuChocolat;
})(StatusBarResource);
///<reference path="Place.ts"/>
var Pier = (function (_super) {
    __extends(Pier, _super);
    // Constructor
    function Pier(game) {
        _super.call(this, game);
        // The render area
        this.renderArea = new RenderArea();
        this.renderArea.resizeFromArray(Database.getAscii("places/pier"), 0, 6);
        this.update();
    }
    // getRenderArea()
    Pier.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // Private methods
    Pier.prototype.addLighthouseButton = function (x, y) {
        this.renderArea.addAsciiRealButton(Database.getText("pierLighthouseButton"), x, y, "pierLighthouseButton", Database.getTranslatedText("pierLighthouseButton"), true);
        this.renderArea.addLinkCall(".pierLighthouseButton", new CallbackCollection(this.clickedOnLighthouseButton.bind(this), this.getGame().goToLighthouse.bind(this.getGame())));
    };
    Pier.prototype.addTheSeaButton = function (x, y) {
        this.renderArea.addAsciiRealButton(Database.getText("pierTheSeaButton"), x, y, "pierTheSeaButton", Database.getTranslatedText("pierTheSeaButton"), true);
        this.renderArea.addLinkCall(".pierTheSeaButton", new CallbackCollection(this.goToTheSea.bind(this)));
    };
    Pier.prototype.clickedOnLighthouseButton = function () {
        Saving.saveBool("mainMapDonePier", true);
    };
    Pier.prototype.goToTheSea = function () {
        if (this.getGame().canStartQuest())
            this.getGame().setPlace(new TheSea(this.getGame()));
    };
    Pier.prototype.update = function () {
        // Erase everything
        this.renderArea.resetAllButSize();
        // Back to the map button
        this.addBackToMainMapButton(this.renderArea, "thePierBackToTheMapButton");
        // Draw the pier
        this.renderArea.drawArray(Database.getAscii("places/pier"), 0, 3);
        // Add the button to go to the lighthouse
        this.addLighthouseButton(3, 27);
        // Add the button to jump into the sea
        this.addTheSeaButton(52, 9);
    };
    return Pier;
})(Place);
///<reference path="EqItem.ts"/>
var PinkEnchantedGloves = (function (_super) {
    __extends(PinkEnchantedGloves, _super);
    // Constructor
    function PinkEnchantedGloves() {
        _super.call(this, "eqItemGlovesPinkEnchantedGloves", "eqItemGlovesPinkEnchantedGlovesName", "eqItemGlovesPinkEnchantedGlovesDescription", "eqItems/gloves/pinkEnchantedGloves");
    }
    // Special ability
    PinkEnchantedGloves.prototype.getSpecialAbility = function () {
        return "Slowly regain your health points in quests (pink enchanted gloves).";
    };
    // update
    PinkEnchantedGloves.prototype.update = function (player, quest) {
        player.heal(1);
    };
    return PinkEnchantedGloves;
})(EqItem);
///<reference path="QuestEntity.ts"/>
var Plant = (function (_super) {
    __extends(Plant, _super);
    // Constructor
    function Plant(quest, leftDownCornerPosition, minPlantNumber, maxPlantNumber) {
        // Set the ascii art name
        var asciiArtName = "places/quests/theSea/plant" + Random.between(minPlantNumber, maxPlantNumber).toString();
        // Create the real global position
        var globalPosition = leftDownCornerPosition;
        globalPosition.add(new Pos(0, -Database.getAsciiHeight(asciiArtName) + 1));
        // Call the mother constructor
        _super.call(this, quest, globalPosition, new Naming("A plant", "a plant"), new RenderArea());
        // Draw the ascii art
        this.getRenderArea().resizeFromArray(Database.getAscii(asciiArtName));
        this.getRenderArea().drawArray(Database.getAscii(asciiArtName));
        // Set different transparency settings depending on the ascii art
        if (asciiArtName == "places/quests/theSea/plant0" || asciiArtName == "places/quests/theSea/plant8" || asciiArtName == "places/quests/theSea/plant9" || asciiArtName == "places/quests/theSea/plant10") {
            this.setTransparency(new RenderTransparency(" ", "%"));
        }
        else {
            this.setTransparency(new RenderTransparency(" "));
        }
    }
    return Plant;
})(QuestEntity);
///<reference path="QuestEntity.ts"/>
// Register our hp
Saving.registerNumber("playerHp", 100);
var Player = (function (_super) {
    __extends(Player, _super);
    // Constructor
    function Player(game) {
        _super.call(this, null, new Pos(0, 0), new Naming("You", "you"));
        // Set the game
        this.game = game;
        // Set destructible
        this.setDestructible(true);
    }
    // Public methods
    Player.prototype.beginBerserk = function (duration) {
        // Call the mother class method
        if (_super.prototype.beginBerserk.call(this, duration)) {
            // Update the render area
            this.drawOnRenderArea();
            // Return true
            return true;
        }
        // We didn't become a turtle : return false
        return false;
    };
    Player.prototype.beginTurtle = function (duration) {
        // Call the mother class method
        if (_super.prototype.beginTurtle.call(this, duration)) {
            // Update the render area
            this.drawOnRenderArea();
            // Return true
            return true;
        }
        // We didn't become a turtle : return false
        return false;
    };
    Player.prototype.canJumpInMidAir = function () {
        // If we have the rocket boots, we can!
        if (this.game.isEquipped("boots", "eqItemBootsRocketBoots"))
            return true;
        return false;
    };
    Player.prototype.checkCollision = function (pos) {
        if (pos === void 0) { pos = new Pos(0, 0); }
        // If our mother class detects a collision, we return true
        if (_super.prototype.checkCollision.call(this, pos) == true)
            return true;
        // We also try collisions with the special player collision boxes
        if (this.collidesWith(this.getQuest().getPlayerCollisionBoxes(), pos))
            return true;
        return false;
    };
    Player.prototype.getCharacterType = function () {
        return this.characterType;
    };
    Player.prototype.getClassicCollisionBoxCollection = function () {
        switch (this.characterType) {
            case PlayerCharacterType.CANDYBOX:
                return new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(5, 3)));
                break;
            case PlayerCharacterType.MEDIUM:
                return new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(13, 6)));
                break;
            case PlayerCharacterType.CANDYBOX_SQUEEZED:
                return new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(3, 3)));
                break;
            case PlayerCharacterType.MEDIUM_SQUEEZED:
                return new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(8, 5)));
                break;
        }
    };
    Player.prototype.getQuestEntityWeapon = function (quest) {
        if (quest === void 0) { quest = null; }
        var qew;
        // If a weapon is equipped, we use the quest entity weapon it provides us
        if (this.game.getSelectedEqItems()["weapon"] != null) {
            qew = this.game.getSelectedEqItems()["weapon"].getQuestEntityWeapon(quest, this);
        }
        else {
            qew = new QuestEntityWeapon(this.getQuest(), this, new Naming("Your fists", "your fists"), this.getClassicCollisionBoxCollection(), 1);
            qew.getCloseCombatDelay().setFixedDelay(6, 0);
        }
        return qew;
    };
    Player.prototype.getSpellCastingPosition = function (facingRight) {
        if (facingRight === void 0) { facingRight = true; }
        switch (this.characterType) {
            case PlayerCharacterType.CANDYBOX:
                if (facingRight)
                    return this.getGlobalPosition().plus(new Pos(3, -1));
                else
                    return this.getGlobalPosition().plus(new Pos(-1, -1));
                break;
            case PlayerCharacterType.MEDIUM:
                if (facingRight)
                    return this.getGlobalPosition().plus(new Pos(11, 0));
                else
                    return this.getGlobalPosition().plus(new Pos(-1, 0));
                break;
            case PlayerCharacterType.CANDYBOX_SQUEEZED:
                if (facingRight)
                    return this.getGlobalPosition().plus(new Pos(0, -1));
                else
                    return this.getGlobalPosition().plus(new Pos(0, -1));
                break;
            case PlayerCharacterType.MEDIUM_SQUEEZED:
                if (facingRight)
                    return this.getGlobalPosition().plus(new Pos(6, 0));
                else
                    return this.getGlobalPosition().plus(new Pos(-1, 0));
                break;
        }
    };
    Player.prototype.getThornsPositionsArray = function () {
        // Create the array
        var arr;
        // Fill the array with different positons depending on the character type
        switch (this.characterType) {
            case PlayerCharacterType.CANDYBOX:
            case PlayerCharacterType.CANDYBOX_SQUEEZED:
                arr = [new Pos(-6, 0),
                    new Pos(-4, -1),
                    new Pos(-2, -2),
                    new Pos(1, -2),
                    new Pos(3, -1),
                    new Pos(5, 0),
                    new Pos(3, 1),
                    new Pos(1, 2),
                    new Pos(-2, 2),
                    new Pos(-4, 1)
                ];
                break;
            case PlayerCharacterType.MEDIUM:
            case PlayerCharacterType.MEDIUM_SQUEEZED:
                arr = [new Pos(11, -2),
                    new Pos(12, -1),
                    new Pos(13, 0),
                    new Pos(13, 1),
                    new Pos(13, 2),
                    new Pos(12, 3),
                    new Pos(11, 4)
                ];
                break;
        }
        // Return the array
        return arr;
    };
    Player.prototype.hit = function (questEntity, damage, reason) {
        for (var savingName in this.game.getSelectedEqItems()) {
            damage = this.game.getSelectedEqItems()[savingName].hit(this, this.getQuest(), questEntity, damage, reason);
        }
        for (var savingName in this.game.getGridItems()) {
            if (Saving.loadBool(savingName))
                damage = this.game.getGridItems()[savingName].hit(this, this.getQuest(), questEntity, damage, reason);
        }
        // Gift of power
        if (Saving.loadNumber("gameGiftPower") > 0) {
            damage = Math.ceil(damage + damage * (Saving.loadNumber("gameGiftPower") / 5));
        }
        _super.prototype.hit.call(this, questEntity, damage, reason);
    };
    Player.prototype.inflictDamage = function (damage, reason) {
        for (var savingName in this.game.getSelectedEqItems()) {
            damage = this.game.getSelectedEqItems()[savingName].inflictDamage(this, this.getQuest(), damage, reason);
        }
        _super.prototype.inflictDamage.call(this, damage, reason);
    };
    Player.prototype.load = function () {
        this.setHp(Saving.loadNumber("playerHp"));
    };
    Player.prototype.loadCandyBoxCharacter = function (quest, firstTime) {
        if (firstTime === void 0) { firstTime = true; }
        // Set the type
        this.characterType = PlayerCharacterType.CANDYBOX;
        // Load stuff common to all characters if it's the first time we load the character in this quest
        if (firstTime)
            this.loadCharacter(quest);
        // Set the ascii representation (size + what it looks like)
        this.setRenderArea(new RenderArea(3, 1));
        this.drawOnRenderArea();
        // Set the collision boxes
        this.setCbc(new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 0), new Pos(3, 1))));
        // Transparency
        this.setTransparency(null);
    };
    Player.prototype.loadCandyBoxSqueezedCharacter = function (quest, firstTime) {
        if (firstTime === void 0) { firstTime = true; }
        // Set the type
        this.characterType = PlayerCharacterType.CANDYBOX_SQUEEZED;
        // Load stuff common to all characters if it's the first time we load the character in this quest
        if (firstTime)
            this.loadCharacter(quest);
        // Set the ascii representation (size + what it looks like)
        this.setRenderArea(new RenderArea(1, 1));
        this.drawOnRenderArea();
        // Set the collision boxes
        this.setCbc(new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 0), new Pos(1, 1))));
        // Transparency
        this.setTransparency(null);
    };
    Player.prototype.loadCharacter = function (quest) {
        // Set the quest
        this.setQuest(quest);
        // Add the quest entity weapon
        this.addQuestEntityWeapon(this.getQuestEntityWeapon(this.getQuest()));
        // Set the team
        this.setTeam(QuestEntityTeam.PLAYER);
    };
    Player.prototype.loadMediumCharacter = function (quest, firstTime) {
        if (firstTime === void 0) { firstTime = true; }
        // Set the type
        this.characterType = PlayerCharacterType.MEDIUM;
        // Load stuff common to all characters if it's the first time we load the character in this quest
        if (firstTime)
            this.loadCharacter(quest);
        // Set the ascii representation (size + what it looks like)
        this.setRenderArea(new RenderArea(11, 4));
        this.drawOnRenderArea();
        // Set the collision boxes
        this.setCbc(new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 0), new Pos(11, 1)), new CollisionBox(this, new Pos(1, 1), new Pos(9, 1)), new CollisionBox(this, new Pos(2, 2), new Pos(7, 1)), new CollisionBox(this, new Pos(4, 3), new Pos(3, 1))));
        // Transparent character
        this.setTransparency(new RenderTransparency(" ", "%"));
    };
    Player.prototype.loadMediumSqueezedCharacter = function (quest, firstTime) {
        if (firstTime === void 0) { firstTime = true; }
        // Set the type
        this.characterType = PlayerCharacterType.MEDIUM_SQUEEZED;
        // Load stuff common to all characters if it's the first time we load the character in this quest
        if (firstTime)
            this.loadCharacter(quest);
        // Set the ascii representation (size + what it looks like)
        this.setRenderArea(new RenderArea(6, 3));
        this.drawOnRenderArea();
        // Set the collision boxes
        this.setCbc(new CollisionBoxCollection(new CollisionBox(this, new Pos(2, 0), new Pos(2, 1)), new CollisionBox(this, new Pos(0, 1), new Pos(6, 1)), new CollisionBox(this, new Pos(2, 2), new Pos(2, 1))));
        // Transparent character
        this.setTransparency(new RenderTransparency(" ", "%"));
    };
    Player.prototype.magicHealthRegain = function () {
        // If we're not questing
        if (this.game.getWeAreQuesting() == false) {
            var hpBonus = Math.ceil((1 - Math.exp(-this.game.getCandiesEaten().getCurrent() / 400000000)) * 500);
            if (hpBonus < 1)
                hpBonus = 1; // We need to gain at least one hp each second
            this.setHp(this.getHp() + hpBonus);
        }
    };
    Player.prototype.move = function (pos, force) {
        if (force === void 0) { force = false; }
        // Position
        var posToUse = pos.copy();
        // If we are wearing the boots of introspection and we would collide by going below, we don't move horizontally and the movement isn't forced
        if (posToUse.x != 0 && this.game.isEquipped("boots", "eqItemBootsBootsOfIntrospection") && this.checkCollision(new Pos(0, 1)) == true && force == false)
            posToUse.x = 0;
        return _super.prototype.move.call(this, posToUse, force);
    };
    Player.prototype.moveWormsLike = function (pos) {
        // Position
        var posToUse = pos.copy();
        // If we are wearing the boots of introspection and we would collide by going below, we don't move horizontally
        if (posToUse.x != 0 && this.game.isEquipped("boots", "eqItemBootsBootsOfIntrospection") && this.checkCollision(new Pos(0, 1)) == true)
            posToUse.x = 0;
        return _super.prototype.moveWormsLike.call(this, posToUse);
    };
    Player.prototype.reCalcMaxHp = function () {
        // Base maximum hp : 100
        var maxHp = 100;
        // We add to the base, depending on how much candies eaten, if we're not playing in hard mode
        if (Saving.loadString("gameGameMode") != "hard") {
            maxHp += Math.ceil((1 - Math.exp(-this.game.getCandiesEaten().getCurrent() / 3000)) * 100) + Math.ceil((1 - Math.exp(-this.game.getCandiesEaten().getCurrent() / 400000)) * 800);
        }
        // We add 300 if we have the heart pendant
        if (Saving.loadBool("gridItemPossessedHeartPendant"))
            maxHp += 300;
        // We add 20% if we have the heart plug
        if (Saving.loadBool("gridItemPossessedHeartPlug"))
            maxHp = Math.ceil(maxHp * 1.2);
        // Health gift
        if (Saving.loadNumber("gameGiftHealth") > 0) {
            maxHp = maxHp + maxHp * (Saving.loadNumber("gameGiftHealth") / 5);
        }
        // We finally set the value we calculated
        this.setMaxHp(maxHp);
        // We update the status bar
        this.game.updateStatusBar();
    };
    Player.prototype.save = function () {
        Saving.saveNumber("playerHp", this.getHp());
    };
    Player.prototype.shouldDie = function () {
        // We use the method of our mother class PLUS we're also dead if out of area
        if (_super.prototype.shouldDie.call(this) || this.getOutOfArea())
            return true;
        return false;
    };
    Player.prototype.squeeze = function () {
        // Do different things depending on the current character type
        switch (this.characterType) {
            case PlayerCharacterType.CANDYBOX:
                // We squeeze
                this.loadCandyBoxSqueezedCharacter(this.getQuest(), false);
                this.move(new Pos(1, 0), true);
                // We add a message to the log
                this.game.getQuestLog().addMessage(new QuestLogMessage("You squeezed!"));
                break;
            case PlayerCharacterType.MEDIUM:
                // We squeeze
                this.loadMediumSqueezedCharacter(this.getQuest(), false);
                this.move(new Pos(2, 1), true);
                // We add a message to the log
                this.game.getQuestLog().addMessage(new QuestLogMessage("You squeezed!"));
                break;
            case PlayerCharacterType.CANDYBOX_SQUEEZED:
                // We unsqueeze
                this.loadCandyBoxCharacter(this.getQuest(), false);
                this.move(new Pos(-1, 0), true);
                // If there's a collision
                if (this.checkCollision()) {
                    // We squeeze again
                    this.loadCandyBoxSqueezedCharacter(this.getQuest(), false);
                    this.move(new Pos(1, 0), true);
                    // We add a message to the log
                    this.game.getQuestLog().addMessage(new QuestLogMessage("You can't unsqueeze because there isn't enough space."));
                }
                else {
                    // We add a message to the log
                    this.game.getQuestLog().addMessage(new QuestLogMessage("You unsqueezed!"));
                }
                break;
            case PlayerCharacterType.MEDIUM_SQUEEZED:
                // We unsqueeze
                this.loadMediumCharacter(this.getQuest(), false);
                this.move(new Pos(-2, -1), true);
                // If there's a collision
                if (this.checkCollision()) {
                    // We squeeze again
                    this.loadMediumSqueezedCharacter(this.getQuest(), false);
                    this.move(new Pos(2, 1), true);
                    // We add a message to the log
                    this.game.getQuestLog().addMessage(new QuestLogMessage("You can't unsqueeze because there isn't enough space."));
                }
                else {
                    // We add a message to the log
                    this.game.getQuestLog().addMessage(new QuestLogMessage("You unsqueezed!"));
                }
                break;
        }
    };
    Player.prototype.stopBerserk = function () {
        // Mother class method
        _super.prototype.stopBerserk.call(this);
        // Update the render area
        this.drawOnRenderArea();
    };
    Player.prototype.stopTurtle = function () {
        // Mother class method
        _super.prototype.stopTurtle.call(this);
        // Update the render area
        this.drawOnRenderArea();
    };
    Player.prototype.update = function () {
        for (var savingName in this.game.getSelectedEqItems()) {
            this.game.getSelectedEqItems()[savingName].update(this, this.getQuest());
        }
        for (var savingName in this.game.getGridItems()) {
            if (Saving.loadBool(savingName))
                this.game.getGridItems()[savingName].update(this, this.getQuest());
        }
        _super.prototype.update.call(this);
    };
    // Public setters : they must be public, because sometimes we have to set these things (at loading for example)
    Player.prototype.setHp = function (hp) {
        _super.prototype.setHp.call(this, hp);
        this.game.updateStatusBar();
    };
    Player.prototype.setMaxHp = function (hp) {
        _super.prototype.setMaxHp.call(this, hp);
        this.game.updateStatusBar();
    };
    // Private methods
    Player.prototype.drawOnRenderArea = function () {
        // Erase the render area
        this.getRenderArea().resetAllButSize();
        // Draw depending on the type
        switch (this.characterType) {
            case PlayerCharacterType.CANDYBOX:
                if (this.getTurtle() && this.getBerserk())
                    this.getRenderArea().drawString("TUR");
                else if (this.getTurtle())
                    this.getRenderArea().drawString("tur");
                else if (this.getBerserk())
                    this.getRenderArea().drawString("O_O");
                else
                    this.getRenderArea().drawString("\\o/");
                break;
            case PlayerCharacterType.CANDYBOX_SQUEEZED:
                if (this.getTurtle() && this.getBerserk())
                    this.getRenderArea().drawString("T");
                else if (this.getTurtle())
                    this.getRenderArea().drawString("t");
                else if (this.getBerserk())
                    this.getRenderArea().drawString("B");
                else
                    this.getRenderArea().drawString("o");
                break;
            case PlayerCharacterType.MEDIUM:
                if (this.getTurtle() && this.getBerserk())
                    this.getRenderArea().drawArray(Database.getAscii("players/mediumTurtleBerserk"));
                else if (this.getTurtle())
                    this.getRenderArea().drawArray(Database.getAscii("players/mediumTurtle"));
                else if (this.getBerserk())
                    this.getRenderArea().drawArray(Database.getAscii("players/mediumBerserk"));
                else
                    this.getRenderArea().drawArray(Database.getAscii("players/medium"));
                break;
            case PlayerCharacterType.MEDIUM_SQUEEZED:
                if (this.getTurtle() && this.getBerserk())
                    this.getRenderArea().drawArray(Database.getAscii("players/mediumSqueezedTurtleBerserk"));
                else if (this.getTurtle())
                    this.getRenderArea().drawArray(Database.getAscii("players/mediumSqueezedTurtle"));
                else if (this.getBerserk())
                    this.getRenderArea().drawArray(Database.getAscii("players/mediumSqueezedBerserk"));
                else
                    this.getRenderArea().drawArray(Database.getAscii("players/mediumSqueezed"));
                break;
        }
    };
    return Player;
})(QuestEntity);
///<reference path="QuestEntityWeapon.ts"/>
var PlayerBludgeon = (function (_super) {
    __extends(PlayerBludgeon, _super);
    function PlayerBludgeon() {
        _super.apply(this, arguments);
    }
    // Public methods
    PlayerBludgeon.prototype.getRealDamage = function () {
        return Random.between(12, 16);
    };
    PlayerBludgeon.prototype.getRealDamageText = function () {
        return "12-16";
    };
    return PlayerBludgeon;
})(QuestEntityWeapon);
var PlayerCharacterType;
(function (PlayerCharacterType) {
    PlayerCharacterType[PlayerCharacterType["CANDYBOX"] = 0] = "CANDYBOX";
    PlayerCharacterType[PlayerCharacterType["MEDIUM"] = 1] = "MEDIUM";
    PlayerCharacterType[PlayerCharacterType["CANDYBOX_SQUEEZED"] = 2] = "CANDYBOX_SQUEEZED";
    PlayerCharacterType[PlayerCharacterType["MEDIUM_SQUEEZED"] = 3] = "MEDIUM_SQUEEZED";
})(PlayerCharacterType || (PlayerCharacterType = {}));
///<reference path="QuestEntity.ts"/>
var PlayerCloneCandyBox = (function (_super) {
    __extends(PlayerCloneCandyBox, _super);
    // Constructor
    function PlayerCloneCandyBox(quest, pos) {
        _super.call(this, quest, pos, new Naming("A clone", "a clone"), new RenderArea(3, 1), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 0), new Pos(3, 1))), new QuestEntityMovement());
        // Set the team
        this.setTeam(QuestEntityTeam.PLAYER);
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(quest.getGame().getPlayer().getHp());
        this.setHp(quest.getGame().getPlayer().getHp());
        // Set the ascii art and the transparent character
        this.getRenderArea().drawString("\\o/");
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("Its fists", "its fists"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(5, 3))), 3));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setFixedDelay(3);
    }
    return PlayerCloneCandyBox;
})(QuestEntity);
///<reference path="QuestEntity.ts"/>
var PlayerCloneMedium = (function (_super) {
    __extends(PlayerCloneMedium, _super);
    // Constructor
    function PlayerCloneMedium(quest, pos) {
        _super.call(this, quest, pos, new Naming("A clone", "a clone"), new RenderArea(11, 4), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 0), new Pos(11, 1)), new CollisionBox(this, new Pos(1, 1), new Pos(9, 1)), new CollisionBox(this, new Pos(2, 2), new Pos(7, 1)), new CollisionBox(this, new Pos(4, 3), new Pos(3, 1))), new QuestEntityMovement());
        // Set the team
        this.setTeam(QuestEntityTeam.PLAYER);
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(quest.getGame().getPlayer().getHp());
        this.setHp(quest.getGame().getPlayer().getHp());
        // Set the ascii art and the transparent character
        this.getRenderArea().drawArray(Database.getAscii("players/medium"));
        this.setTransparency(new RenderTransparency(" ", "%"));
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("Its fists", "its fists"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(13, 6))), 3));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setFixedDelay(3);
    }
    return PlayerCloneMedium;
})(QuestEntity);
///<reference path="QuestEntitySpell.ts"/>
var PlayerSummonedDemon = (function (_super) {
    __extends(PlayerSummonedDemon, _super);
    // Constructor
    function PlayerSummonedDemon(quest, globalPosition, damage) {
        _super.call(this, quest, globalPosition, new Naming("A demon", "a demon"));
        // Set the damage
        this.damage = damage;
        // Create the damage reason
        this.damageReason = new QuestEntityDamageReason(QuestEntityDamageReasonWhoType.ENTITY, QuestEntityDamageReasonWhatType.SPELL);
        this.damageReason.setQuestEntity(this.getQuest().getGame().getPlayer(), QuestEntityTeam.NATURE);
        this.damageReason.setSpellNaming(this.getRandomNaming());
        // Create the collision box collection
        this.damageCollisionBoxCollection = new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 0), new Pos(8, 4)));
        // Add the demon colors randomly
        this.addRandomQuestEntitySpellColors();
        // Add the quest entity movement
        this.setQuestEntityMovement(new QuestEntityMovement(new Pos(3, 0)));
    }
    // Public methods
    PlayerSummonedDemon.prototype.update = function () {
        // Handle damage
        this.handleDamage();
        // Update
        _super.prototype.update.call(this);
    };
    // Private generation methods
    PlayerSummonedDemon.prototype.addRandomQuestEntitySpellColors = function () {
        // Array of 4*4 used to decide of the colors to add
        var arr = [];
        // Fill the array with false values
        for (var i = 0; i < 4; i++) {
            arr.push([]);
            for (var j = 0; j < 4; j++) {
                arr[i].push(false);
            }
        }
        // Fill the array with some true values
        switch (Random.upTo(1)) {
            // Symmetrical demon (vertical symmetry)
            case 0:
                for (var i = 0; i < 2; i++) {
                    for (var j = 0; j < 4; j++) {
                        if (Random.flipACoin()) {
                            arr[i][j] = true;
                            arr[3 - i][j] = true;
                        }
                    }
                }
                break;
            // Symmetrical demon (horizontal symmetry)
            case 1:
                for (var i = 0; i < 4; i++) {
                    for (var j = 0; j < 2; j++) {
                        if (Random.flipACoin()) {
                            arr[i][j] = true;
                            arr[i][3 - j] = true;
                        }
                    }
                }
                break;
        }
        // Add the colors depending on the array's content
        for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 4; j++) {
                // If we should add a color here, we do so
                if (arr[i][j])
                    this.addColor(new QuestEntitySpellColor(this.getQuest(), new Pos(i * 2, j), new Pos(2, 1), new Color(ColorType.PLAYER_SUMMONED_DEMON, true)));
            }
        }
    };
    PlayerSummonedDemon.prototype.getRandomNaming = function () {
        // The final name in a string
        var finalName = "";
        // How many syllables?
        var howManySyllables;
        if (Random.flipACoin())
            howManySyllables = 3; // a lot of chance
        else if (Random.oneChanceOutOf(10))
            howManySyllables = 4; // small chance
        else if (Random.oneChanceOutOf(10))
            howManySyllables = 1; // small chance
        else
            howManySyllables = 2; // a lot of chance, a but still a little bit less chance then 3 syllables
        // The syllables array
        var syllablesArray = [];
        // Add the syllables to the array
        for (var i = 0; i < howManySyllables; i++) {
            syllablesArray.push(Random.fromArray(["lael", "ezek", "bal", "sen", "zen", "aps", "hir", "ta", "ozn", "eres", "non", "enon", "cesti", "mal", "aser", "oex", "nax", "arir", "nikon", "taor", "rael", "mael", "sael", "epit", "uer", "pod", "ehon", "edeo", "xa"]));
        }
        // Turn the first letter of the firsy syllable into upper case
        syllablesArray[0] = syllablesArray[0].charAt(0).toUpperCase() + syllablesArray[0].slice(1);
        // Create the final name from the syllables
        for (var i = 0; i < syllablesArray.length; i++) {
            finalName += syllablesArray[i];
        }
        // Finally return the naming
        return new Naming("the demon " + finalName);
    };
    // Other private methods
    PlayerSummonedDemon.prototype.handleDamage = function () {
        // We iterate over entities
        for (var i = 0; i < this.getQuest().getEntities().length; i++) {
            // If it is destructible
            if (this.getQuest().getEntities()[i].getDestructible()) {
                // If it has a collision box collection
                if (this.getQuest().getEntities()[i].getCbc() != null) {
                    // If this collision box collection collides with ours
                    if (this.getQuest().getEntities()[i].getCbc().collidesWith(this.damageCollisionBoxCollection)) {
                        // We inflict the damage
                        this.getQuest().getEntities()[i].inflictDamage(this.damage, this.damageReason);
                    }
                }
            }
        }
    };
    return PlayerSummonedDemon;
})(QuestEntitySpell);
///<reference path="QuestEntity.ts"/>
var PlayerSummonedOctopusKing = (function (_super) {
    __extends(PlayerSummonedOctopusKing, _super);
    // Constructor
    function PlayerSummonedOctopusKing(quest, pos) {
        _super.call(this, quest, pos, new Naming("An Octopus King", "an Octopus King"), new RenderArea(6, 4), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(2, 0), new Pos(2, 1)), new CollisionBox(this, new Pos(1, 1), new Pos(4, 1)), new CollisionBox(this, new Pos(1, 2), new Pos(4, 1)), new CollisionBox(this, new Pos(0, 3), new Pos(6, 1))), new QuestEntityMovement());
        // Set gravity
        this.getQuestEntityMovement().setGravity(true);
        this.getQuestEntityMovement().setWormsLike(true);
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(380);
        this.setHp(380);
        // Set the team
        this.setTeam(QuestEntityTeam.PLAYER);
        // Set the ascii art and the transparent character
        this.getRenderArea().drawArray(Database.getAscii("places/quests/octopusKing/octopusKing"));
        this.setTransparency(new RenderTransparency(" "));
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("Its tentacles", "its tentacles"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(8, 6))), 16));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setFixedDelay(3);
    }
    // update()
    PlayerSummonedOctopusKing.prototype.update = function () {
        // Go towards the player
        this.goTowards(this.getGlobalPosition(), this.getQuest().getGame().getPlayer().getGlobalPosition(), 0, new Pos(1, 0));
        // Call the mother class update method
        _super.prototype.update.call(this);
    };
    return PlayerSummonedOctopusKing;
})(QuestEntity);
///<reference path="QuestEntity.ts"/>
var PlayerSummonedTribeWarrior = (function (_super) {
    __extends(PlayerSummonedTribeWarrior, _super);
    // Constructor
    function PlayerSummonedTribeWarrior(quest, pos) {
        _super.call(this, quest, pos, new Naming("A tribe warrior", "a tribe warrior"), new RenderArea(4, 4), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 0), new Pos(1, 1)), new CollisionBox(this, new Pos(0, 1), new Pos(4, 3))), new QuestEntityMovement());
        // Set gravity and worms like
        this.setQuestEntityMovement(new QuestEntityMovement(new Pos(1, 0)));
        this.getQuestEntityMovement().setGravity(true);
        this.getQuestEntityMovement().setWormsLike(true);
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(25);
        this.setHp(25);
        // Set the team
        this.setTeam(QuestEntityTeam.PLAYER);
        // Set the ascii art and the transparent character
        this.getRenderArea().drawArray(Database.getAscii("places/quests/theHole/lostTribeWarrior"));
        this.setTransparency(new RenderTransparency(" "));
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("A tribal spear", "a tribal spear"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(6, 6))), 8));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setFixedDelay(2);
    }
    // update()
    PlayerSummonedTribeWarrior.prototype.update = function () {
        _super.prototype.update.call(this);
    };
    return PlayerSummonedTribeWarrior;
})(QuestEntity);
///<reference path="EqItem.ts"/>
var PolishedSilverSword = (function (_super) {
    __extends(PolishedSilverSword, _super);
    // Constructor
    function PolishedSilverSword() {
        _super.call(this, "eqItemWeaponPolishedSilverSword", "eqItemWeaponPolishedSilverSwordName", "eqItemWeaponPolishedSilverSwordDescription", "eqItems/weapons/polishedSilverSword");
    }
    // Public getters
    PolishedSilverSword.prototype.getQuestEntityWeapon = function (quest, player) {
        var qew = new QuestEntityWeapon(quest, player, new Naming("A polished silver sword", "a polished silver sword"), player.getClassicCollisionBoxCollection(), 7);
        qew.getCloseCombatDelay().setFixedDelay(4, 0);
        return qew;
    };
    return PolishedSilverSword;
})(EqItem);
var PondLine = (function () {
    // Constructor
    function PondLine(x1, x2) {
        // Is the line currently used by a lolligator ?
        this.isUsed = false;
        this.x1 = x1;
        this.x2 = x2;
    }
    // Public getters
    PondLine.prototype.getIsUsed = function () {
        return this.isUsed;
    };
    PondLine.prototype.getX1 = function () {
        return this.x1;
    };
    PondLine.prototype.getX2 = function () {
        return this.x2;
    };
    // Public setters
    PondLine.prototype.setIsUsed = function (isUsed) {
        this.isUsed = isUsed;
    };
    return PondLine;
})();
var PondLolligator = (function () {
    // Constructor
    function PondLolligator(pondLines, pondLineIndex) {
        // Out width
        this.width = 13;
        // Set from the parameters
        this.pondLines = pondLines;
        this.pondLineIndex = pondLineIndex;
        // Set the orientation (randomly)
        this.isLeft = Random.flipACoin();
        // Set the position (depending on the orientation)
        if (this.isLeft == false)
            this.x = this.pondLines[this.pondLineIndex].getX1();
        else
            this.x = this.pondLines[this.pondLineIndex].getX2() - this.width;
        // At first, we're not fully visible
        this.visibleType = PondLolligatorVisibleType.NOT_FULLY_VISIBLE_YET;
        // Set isUsed for the pond lines we use
        this.setIsUsedForPondLines(true);
    }
    // Public methods
    PondLolligator.prototype.draw = function (renderArea, x, y) {
        renderArea.drawArray(Database.getAscii("places/lollipopFarm/lolligator" + (this.isLeft ? "Left" : "Right") + (this.visibleType == PondLolligatorVisibleType.FULLY_VISIBLE ? "Full" : "Top")), x + this.x, y + this.pondLineIndex);
    };
    PondLolligator.prototype.move = function () {
        // If the lolligator is facing left, then it goes to the left
        if (this.isLeft) {
            this.x -= 1;
            // If we're not fully visible but we should be
            if (this.visibleType == PondLolligatorVisibleType.NOT_FULLY_VISIBLE_YET && this.x + this.width < this.pondLines[this.pondLineIndex].getX2() - 2 && Random.oneChanceOutOf(5))
                this.visibleType = PondLolligatorVisibleType.FULLY_VISIBLE;
            else if (this.visibleType == PondLolligatorVisibleType.FULLY_VISIBLE && (this.x < this.pondLines[this.pondLineIndex].getX1() + 2 || Random.oneChanceOutOf(2)))
                this.visibleType = PondLolligatorVisibleType.NOT_FULLY_VISIBLE_ANYMORE;
        }
        else {
            this.x += 1;
            // If we're not fully visible but we should be
            if (this.visibleType == PondLolligatorVisibleType.NOT_FULLY_VISIBLE_YET && this.x > this.pondLines[this.pondLineIndex].getX1() + 2 && Random.oneChanceOutOf(5))
                this.visibleType = PondLolligatorVisibleType.FULLY_VISIBLE;
            else if (this.visibleType == PondLolligatorVisibleType.FULLY_VISIBLE && (this.x + this.width > this.pondLines[this.pondLineIndex].getX2() - 2 || Random.oneChanceOutOf(2)))
                this.visibleType = PondLolligatorVisibleType.NOT_FULLY_VISIBLE_ANYMORE;
        }
    };
    // Called to know if the lolligator should be deleted or not
    PondLolligator.prototype.shouldBeDeleted = function () {
        // It depends on the orientation
        if (this.isLeft == false) {
            // If we're too much on the right, return true
            if (this.x + this.width > this.pondLines[this.pondLineIndex].getX2())
                return true;
            return false;
        }
        else {
            // If we're too much on the left, return true
            if (this.x < this.pondLines[this.pondLineIndex].getX1())
                return true;
            return false;
        }
    };
    // Called just before the lolligator is deleted
    PondLolligator.prototype.willBeDeleted = function () {
        this.setIsUsedForPondLines(false);
    };
    // Private setters
    PondLolligator.prototype.setIsUsedForPondLines = function (isUsed) {
        // Set for the line of the lolligator
        this.pondLines[this.pondLineIndex].setIsUsed(isUsed);
        // Set for the line above if there's a line above
        if (this.pondLineIndex > 0)
            this.pondLines[this.pondLineIndex - 1].setIsUsed(isUsed);
    };
    return PondLolligator;
})();
var PondLolligatorVisibleType;
(function (PondLolligatorVisibleType) {
    PondLolligatorVisibleType[PondLolligatorVisibleType["NOT_FULLY_VISIBLE_YET"] = 0] = "NOT_FULLY_VISIBLE_YET";
    PondLolligatorVisibleType[PondLolligatorVisibleType["FULLY_VISIBLE"] = 1] = "FULLY_VISIBLE";
    PondLolligatorVisibleType[PondLolligatorVisibleType["NOT_FULLY_VISIBLE_ANYMORE"] = 2] = "NOT_FULLY_VISIBLE_ANYMORE";
})(PondLolligatorVisibleType || (PondLolligatorVisibleType = {}));
var Pos = (function () {
    // Constructor
    function Pos(x, y) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        this.x = x;
        this.y = y;
    }
    // Public methods
    Pos.prototype.add = function (pos) {
        this.x += pos.x;
        this.y += pos.y;
    };
    Pos.prototype.copy = function () {
        return new Pos(this.x, this.y);
    };
    Pos.prototype.getDistance = function (pos) {
        return new Pos(this.x - pos.x, this.y - pos.y);
    };
    Pos.prototype.invert = function () {
        var temp = this.x;
        this.x = this.y;
        this.y = temp;
    };
    Pos.prototype.multiply = function (pos) {
        this.x = this.x * pos.x;
        this.y = this.y * pos.y;
        return this;
    };
    Pos.prototype.plus = function (pos) {
        return new Pos(this.x + pos.x, this.y + pos.y);
    };
    return Pos;
})();
var QuestEntityAnimation = (function () {
    // Constructor
    function QuestEntityAnimation(intervalTime, currentTime, currentAsciiIndex) {
        var asciiNames = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            asciiNames[_i - 3] = arguments[_i];
        }
        this.intervalTime = intervalTime;
        this.currentTime = currentTime;
        this.currentAsciiIndex = currentAsciiIndex;
        this.asciiNames = asciiNames;
    }
    // Public methods
    QuestEntityAnimation.prototype.draw = function (renderArea) {
        renderArea.drawArray(Database.getAscii(this.asciiNames[this.currentAsciiIndex]));
    };
    QuestEntityAnimation.prototype.shouldUpdateRenderAreaAtThisFrame = function () {
        return (this.currentTime == this.intervalTime);
    };
    QuestEntityAnimation.prototype.update = function () {
        this.currentTime += 1;
        if (this.currentTime > this.intervalTime) {
            this.currentTime = 0;
            this.currentAsciiIndex += 1;
            if (this.currentAsciiIndex >= this.asciiNames.length)
                this.currentAsciiIndex = 0;
        }
    };
    // Public getters
    QuestEntityAnimation.prototype.getCurrentAsciiIndex = function () {
        return this.currentAsciiIndex;
    };
    return QuestEntityAnimation;
})();
var QuestEntityDamageReason = (function () {
    // Constructor
    function QuestEntityDamageReason(whoType, whatType) {
        // Additional parameters, depeding on the who type
        // NATURE : no parameter
        // ENTITY
        this.questEntity = null;
        this.questEntityTeam = null;
        // Additional parameters, depeding on the what type
        // WEAPON
        this.questEntityWeapon = null;
        // SPELL
        this.spellNaming = null;
        this.whoType = whoType;
        this.whatType = whatType;
    }
    // Public methods
    QuestEntityDamageReason.prototype.getQuestEntityTeam = function () {
        return this.questEntityTeam;
    };
    QuestEntityDamageReason.prototype.getWhatNaming = function () {
        switch (this.whatType) {
            case QuestEntityDamageReasonWhatType.WEAPON:
                return this.questEntityWeapon.getNaming();
                break;
            case QuestEntityDamageReasonWhatType.SPELL:
                return this.spellNaming;
                break;
        }
    };
    QuestEntityDamageReason.prototype.getWhoNaming = function () {
        switch (this.whoType) {
            case QuestEntityDamageReasonWhoType.NATURE:
                return new Naming("Nature", "nature");
                break;
            case QuestEntityDamageReasonWhoType.ENTITY:
                return this.questEntity.getNaming();
                break;
        }
    };
    // Public setters
    QuestEntityDamageReason.prototype.setQuestEntity = function (questEntity, questEntityTeam) {
        if (questEntityTeam === void 0) { questEntityTeam = null; }
        this.questEntity = questEntity;
        if (questEntityTeam == null)
            this.questEntityTeam = questEntity.getTeam();
        else
            this.questEntityTeam = questEntityTeam;
        return this;
    };
    QuestEntityDamageReason.prototype.setQuestEntityWeapon = function (questEntityWeapon) {
        this.questEntityWeapon = questEntityWeapon;
        return this;
    };
    QuestEntityDamageReason.prototype.setSpellNaming = function (naming) {
        this.spellNaming = naming;
        return this;
    };
    return QuestEntityDamageReason;
})();
var QuestEntityDamageReasonWhatType;
(function (QuestEntityDamageReasonWhatType) {
    QuestEntityDamageReasonWhatType[QuestEntityDamageReasonWhatType["WEAPON"] = 0] = "WEAPON";
    QuestEntityDamageReasonWhatType[QuestEntityDamageReasonWhatType["SPELL"] = 1] = "SPELL";
})(QuestEntityDamageReasonWhatType || (QuestEntityDamageReasonWhatType = {}));
var QuestEntityDamageReasonWhoType;
(function (QuestEntityDamageReasonWhoType) {
    QuestEntityDamageReasonWhoType[QuestEntityDamageReasonWhoType["NATURE"] = 0] = "NATURE";
    QuestEntityDamageReasonWhoType[QuestEntityDamageReasonWhoType["ENTITY"] = 1] = "ENTITY";
})(QuestEntityDamageReasonWhoType || (QuestEntityDamageReasonWhoType = {}));
var QuestEntityHealthBar = (function () {
    // Constructor
    function QuestEntityHealthBar(questEntity, barSize, position, // By default, the bar will be above the entity
        positionType, drawEvenIfFull, showText, barType) {
        if (position === void 0) { position = new Pos(0, -1); }
        if (positionType === void 0) { positionType = QuestEntityHealthBarPositionType.RELATIVE; }
        if (drawEvenIfFull === void 0) { drawEvenIfFull = false; }
        if (showText === void 0) { showText = false; }
        if (barType === void 0) { barType = BarType.UNICOLOR_HEALTH; }
        // Create the bar
        this.bar = new Bar(barType);
        // Set the parameters
        this.setBarSize(barSize);
        this.questEntity = questEntity;
        this.position = position;
        this.positionType = positionType;
        this.drawEvenIfFull = drawEvenIfFull;
        this.showText = showText;
        // Update for the first time
        this.update();
    }
    // Public methods
    QuestEntityHealthBar.prototype.draw = function (renderArea) {
        // Draw if we should be drawn
        if (this.shouldBeDrawn) {
            switch (this.positionType) {
                case QuestEntityHealthBarPositionType.FIXED_ON_PAGE:
                    renderArea.drawArea(this.bar, ((this.questEntity.getQuest().getRenderArea().getWidth() - 100) - this.questEntity.getQuest().getGap()) / 2 + this.questEntity.getQuest().getRealQuestPosition().x + this.position.x + this.questEntity.getQuest().getGlobalDrawingOffset().x, this.questEntity.getQuest().getRealQuestPosition().y + this.position.y + this.questEntity.getQuest().getGlobalDrawingOffset().y, new RenderTransparency(" "));
                    break;
                case QuestEntityHealthBarPositionType.FIXED:
                    renderArea.drawArea(this.bar, this.questEntity.getQuest().getRealQuestPosition().x + this.position.x + this.questEntity.getQuest().getGlobalDrawingOffset().x, this.questEntity.getQuest().getRealQuestPosition().y + this.position.y + this.questEntity.getQuest().getGlobalDrawingOffset().y, new RenderTransparency(" "));
                    break;
                case QuestEntityHealthBarPositionType.RELATIVE:
                    if (this.questEntity.getQuest().getRealQuestPosition().x + this.questEntity.getGlobalPosition().x + this.position.x > 0 &&
                        this.questEntity.getQuest().getRealQuestPosition().x + this.questEntity.getGlobalPosition().x + this.position.x + this.bar.getWidth() <= renderArea.getWidth() &&
                        this.questEntity.getGlobalPosition().y + this.position.y > 0 &&
                        this.questEntity.getGlobalPosition().y + this.position.y <= this.questEntity.getQuest().getRealQuestSize().y // And at the bottom
                    ) {
                        renderArea.drawArea(this.bar, this.questEntity.getQuest().getRealQuestPosition().x + this.questEntity.getGlobalPosition().x + this.position.x + this.questEntity.getQuest().getGlobalDrawingOffset().x, this.questEntity.getQuest().getRealQuestPosition().y + this.questEntity.getGlobalPosition().y + this.position.y + this.questEntity.getQuest().getGlobalDrawingOffset().y, new RenderTransparency(" "));
                    }
                    break;
            }
        }
    };
    QuestEntityHealthBar.prototype.update = function () {
        // If we should draw the bar even if full or it isn't full, then we set that we should draw it
        if (this.drawEvenIfFull || this.questEntity.getHp() / this.questEntity.getMaxHp() != 1) {
            this.shouldBeDrawn = true;
        }
        else
            this.shouldBeDrawn = false;
        // Update the bar only if it should be draw
        if (this.shouldBeDrawn) {
            // If we don't have to show text
            if (this.showText == false)
                this.bar.update(this.questEntity.getHp() / this.questEntity.getMaxHp(), this.questEntity.getHp().toString());
            else
                this.bar.update(this.questEntity.getHp() / this.questEntity.getMaxHp(), this.questEntity.getNaming().getBeginning() + " : " + this.questEntity.getHp().toString() + "/" + this.questEntity.getMaxHp().toString());
        }
    };
    // Public setters
    QuestEntityHealthBar.prototype.setBarSize = function (barSize) {
        this.barSize = barSize;
        this.bar.resize(this.barSize.x, this.barSize.y);
    };
    QuestEntityHealthBar.prototype.setDrawEvenIfFull = function (value) {
        this.drawEvenIfFull = value;
    };
    return QuestEntityHealthBar;
})();
var QuestEntityHealthBarPositionType;
(function (QuestEntityHealthBarPositionType) {
    QuestEntityHealthBarPositionType[QuestEntityHealthBarPositionType["RELATIVE"] = 0] = "RELATIVE";
    QuestEntityHealthBarPositionType[QuestEntityHealthBarPositionType["FIXED"] = 1] = "FIXED";
    QuestEntityHealthBarPositionType[QuestEntityHealthBarPositionType["FIXED_ON_PAGE"] = 2] = "FIXED_ON_PAGE"; // The position of the bar is fixd in the quest and not affected by scrolling
})(QuestEntityHealthBarPositionType || (QuestEntityHealthBarPositionType = {}));
var QuestEntityMovement = (function () {
    // Constructor
    function QuestEntityMovement(offset, intervalTime, currentTime) {
        if (offset === void 0) { offset = new Pos(0, 0); }
        if (intervalTime === void 0) { intervalTime = 0; }
        if (currentTime === void 0) { currentTime = 0; }
        // Special bools
        this.gravity = false; // If true, then the entity which has this movement is affected by gravity
        this.wormsLike = false; // If true, then the entity which has this movement will move like a worms (in the Team 17 games) : it can climb steps of one character and don't "fall" if the go down of just one character
        this.offset = offset;
        this.intervalTime = intervalTime;
        this.currentTime = currentTime;
    }
    // Public methods
    QuestEntityMovement.prototype.shouldMoveAtThisFrame = function () {
        return (this.currentTime == this.intervalTime);
    };
    QuestEntityMovement.prototype.update = function () {
        this.currentTime += 1;
        if (this.currentTime > this.intervalTime)
            this.currentTime = 0;
    };
    // Public getters
    QuestEntityMovement.prototype.getCurrentFrameMovement = function () {
        if (this.shouldMoveAtThisFrame())
            return this.offset;
        else
            return new Pos(0, 0);
    };
    QuestEntityMovement.prototype.getGravity = function () {
        return this.gravity;
    };
    QuestEntityMovement.prototype.getOffset = function () {
        return this.offset;
    };
    QuestEntityMovement.prototype.getWormsLike = function () {
        return this.wormsLike;
    };
    // Public setters
    QuestEntityMovement.prototype.setGravity = function (value) {
        this.gravity = value;
    };
    QuestEntityMovement.prototype.setOffset = function (offset) {
        this.offset = offset;
    };
    QuestEntityMovement.prototype.setWormsLike = function (value) {
        this.wormsLike = value;
    };
    return QuestEntityMovement;
})();
var QuestEntitySpellCaster = (function () {
    // Constructor
    function QuestEntitySpellCaster(callbackCollection) {
        // The delay
        this.delay = new QuestEntityWeaponDelay();
        this.callbackCollection = callbackCollection;
    }
    // Public methods
    QuestEntitySpellCaster.prototype.tryToCast = function () {
        if (this.delay.tryToAttack()) {
            this.callbackCollection.fire();
        }
    };
    // Public getters
    QuestEntitySpellCaster.prototype.getDelay = function () {
        return this.delay;
    };
    return QuestEntitySpellCaster;
})();
var QuestEntitySpellColor = (function () {
    // Constructor
    function QuestEntitySpellColor(quest, position, size, color) {
        this.quest = quest;
        this.position = position;
        this.size = size;
        this.color = color;
    }
    // Public methods
    QuestEntitySpellColor.prototype.draw = function (renderArea, areaPosition) {
        var x1;
        var x2;
        var y;
        for (var i = 0; i < this.size.y; i++) {
            // x1
            x1 = this.position.x + areaPosition.x;
            if (x1 < this.quest.getRealQuestPosition().x)
                x1 = this.quest.getRealQuestPosition().x;
            // x2
            x2 = this.position.x + areaPosition.x + this.size.x;
            if (x2 > this.quest.getRealQuestPosition().x + this.quest.getRealQuestSize().x)
                x2 = this.quest.getRealQuestPosition().x + this.quest.getRealQuestSize().x;
            // y
            y = this.position.y + areaPosition.y + i;
            if (x1 < x2 && y >= this.quest.getRealQuestPosition().y && y < this.quest.getRealQuestPosition().y + this.quest.getRealQuestSize().y) {
                renderArea.addBackgroundColor(x1, x2, y, this.color);
            }
        }
    };
    return QuestEntitySpellColor;
})();
var QuestEntityTeam;
(function (QuestEntityTeam) {
    QuestEntityTeam[QuestEntityTeam["PLAYER"] = 0] = "PLAYER";
    QuestEntityTeam[QuestEntityTeam["MOBS"] = 1] = "MOBS";
    QuestEntityTeam[QuestEntityTeam["NATURE"] = 2] = "NATURE";
})(QuestEntityTeam || (QuestEntityTeam = {}));
var QuestEntityWeaponDelay = (function () {
    // Constructor
    function QuestEntityWeaponDelay() {
        // By default, the type is FIXED and the maxDelay is 0
        this.type = QuestEntityWeaponDelayType.FIXED;
        this.currentDelay = 0;
        this.maxDelay = 0;
    }
    // Public methods
    QuestEntityWeaponDelay.prototype.getText = function () {
        // Create the delay var
        var delay;
        // Set the delay we should use
        if (this.type == QuestEntityWeaponDelayType.BETWEEN)
            delay = Math.floor(this.minBetweenDelay + (this.maxBetweenDelay - this.minBetweenDelay) / 2);
        else
            delay = this.maxDelay;
        // Return the text depending on this delay
        switch (delay) {
            case 0:
                return "incredibly fast";
                break;
            case 1:
                return "very fast";
                break;
            case 2:
                return "fast";
                break;
            case 3:
                return "rather fast";
                break;
            case 4: return "medium speed";
            case 5:
                return "rather slow";
                break;
            case 6:
            case 7:
                return "slow";
                break;
            case 8:
            case 9:
                return "very slow";
                break;
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
                return "incredibly slow";
                break;
            default:
                "couldn't be slower";
                break;
        }
    };
    QuestEntityWeaponDelay.prototype.tryToAttack = function () {
        // We increase the current delay
        this.currentDelay++;
        switch (this.type) {
            case QuestEntityWeaponDelayType.FIXED:
                // If it's time to attack
                if (this.currentDelay > this.maxDelay) {
                    this.currentDelay = 0;
                    return true;
                }
                break;
            case QuestEntityWeaponDelayType.BETWEEN:
                // If it's time to attack
                if (this.currentDelay > this.maxDelay) {
                    this.currentDelay = 0;
                    this.chooseBetweenDelay();
                    return true;
                }
                break;
            case QuestEntityWeaponDelayType.ONCE_THEN_WAIT:
                // If it's time to attack
                if (this.currentDelay > this.maxDelay) {
                    return true;
                }
                break;
        }
        return false;
    };
    QuestEntityWeaponDelay.prototype.setBetweenDelay = function (minBetweenDelay, maxBetweenDelay, currentDelay) {
        if (currentDelay === void 0) { currentDelay = 0; }
        this.type = QuestEntityWeaponDelayType.BETWEEN;
        this.minBetweenDelay = minBetweenDelay;
        this.maxBetweenDelay = maxBetweenDelay;
        this.chooseBetweenDelay();
    };
    QuestEntityWeaponDelay.prototype.setFixedDelay = function (maxDelay, currentDelay) {
        if (maxDelay === void 0) { maxDelay = 0; }
        if (currentDelay === void 0) { currentDelay = 0; }
        this.type = QuestEntityWeaponDelayType.FIXED;
        this.maxDelay = maxDelay;
        this.currentDelay = currentDelay;
    };
    QuestEntityWeaponDelay.prototype.setOnceThenWaitDelay = function (maxDelay, currentDelay) {
        if (maxDelay === void 0) { maxDelay = 0; }
        if (currentDelay === void 0) { currentDelay = 0; }
        this.type = QuestEntityWeaponDelayType.ONCE_THEN_WAIT;
        this.maxDelay = maxDelay;
        this.currentDelay = currentDelay;
    };
    QuestEntityWeaponDelay.prototype.theWeaponAttacked = function () {
        if (this.type == QuestEntityWeaponDelayType.ONCE_THEN_WAIT)
            this.currentDelay = 0;
    };
    // Private methods
    QuestEntityWeaponDelay.prototype.chooseBetweenDelay = function () {
        this.maxDelay = Random.between(this.minBetweenDelay, this.maxBetweenDelay);
    };
    return QuestEntityWeaponDelay;
})();
var QuestEntityWeaponDelayType;
(function (QuestEntityWeaponDelayType) {
    QuestEntityWeaponDelayType[QuestEntityWeaponDelayType["FIXED"] = 0] = "FIXED";
    QuestEntityWeaponDelayType[QuestEntityWeaponDelayType["BETWEEN"] = 1] = "BETWEEN";
    QuestEntityWeaponDelayType[QuestEntityWeaponDelayType["ONCE_THEN_WAIT"] = 2] = "ONCE_THEN_WAIT"; // We can attack immediately once, but then we have to wait for another attack
})(QuestEntityWeaponDelayType || (QuestEntityWeaponDelayType = {}));
var QuestItemFound = (function () {
    // Constructor
    function QuestItemFound(quest, savingName, foundText, getText) {
        this.quest = quest;
        this.savingName = savingName;
        this.foundText = foundText;
        this.getText = getText;
    }
    // Public methods
    QuestItemFound.prototype.found = function () {
        this.quest.getGame().getQuestLog().addMessage(new QuestLogMessage(this.foundText, null, true));
    };
    QuestItemFound.prototype.get = function () {
        this.quest.getGame().getQuestLog().addMessage(new QuestLogMessage(this.getText, null, true));
    };
    // Public getters    
    QuestItemFound.prototype.getSavingName = function () {
        return this.savingName;
    };
    return QuestItemFound;
})();
var QuestLog = (function () {
    // Constructor
    function QuestLog() {
        // Array of messages contained in the quest log
        this.messages = [];
    }
    // Public method
    QuestLog.prototype.addDelimiter = function () {
        this.messages.push(new QuestLogMessage("----------------------------------------------------------------------------------------------------"));
        this.messages.push(new QuestLogMessage(""));
    };
    QuestLog.prototype.addMessage = function (message) {
        // We add the message
        this.messages.push(message);
        // We check the log size
        this.checkLogSize();
    };
    QuestLog.prototype.draw = function (renderArea, pos) {
        // We draw the lines
        renderArea.drawHorizontalLine("-", pos.x, pos.x + 100, pos.y);
        renderArea.drawHorizontalLine("-", pos.x, pos.x + 100, pos.y + 11);
        // We draw the messages
        for (var i = 0; i < this.messages.length; i++) {
            this.messages[i].draw(renderArea, new Pos(pos.x, 1 + pos.y + this.messages.length - 1 - i), 100);
        }
    };
    // Private methods
    QuestLog.prototype.checkLogSize = function () {
        if (this.messages.length > 10) {
            this.messages.splice(0, this.messages.length - 10);
        }
    };
    return QuestLog;
})();
var QuestLogMessage = (function () {
    // Constructor
    function QuestLogMessage(left, right, bold) {
        if (right === void 0) { right = null; }
        if (bold === void 0) { bold = false; }
        // Strings
        this.left = null;
        this.right = null;
        // Set the parameters
        this.left = left;
        this.right = right;
        this.bold = bold;
        // If the left string is too big
        if (this.left.length > 100 - (this.right != null ? this.right.length : 0)) {
            this.left = this.left.substr(0, 100 - (this.right != null ? this.right.length : 0) - 7) + " (...)";
        }
    }
    // Public methods
    QuestLogMessage.prototype.draw = function (renderArea, pos, width) {
        if (this.left != null) {
            renderArea.drawString(this.left, pos.x, pos.y);
            if (this.bold)
                renderArea.addBold(pos.x, pos.x + this.left.length, pos.y);
        }
        if (this.right != null) {
            renderArea.drawString(this.right, pos.x + width - this.right.length, pos.y);
            if (this.bold)
                renderArea.addBold(pos.x + width - this.right.length, width, pos.y);
        }
    };
    return QuestLogMessage;
})();
// Potions
Saving.registerBool("questPlayerSpellHealthPotionHasSpell", false);
Saving.registerBool("questPlayerSpellTurtlePotionHasSpell", false);
Saving.registerBool("questPlayerSpellAntiGravityPotionHasSpell", false);
Saving.registerBool("questPlayerSpellBerserkPotionHasSpell", false);
Saving.registerBool("questPlayerSpellCloningPotionHasSpell", false);
Saving.registerBool("questPlayerSpellPPotionHasSpell", false);
Saving.registerBool("questPlayerSpellXPotionHasSpell", false);
Saving.registerNumber("questPlayerSpellHealthPotionQuantity", 0);
Saving.registerNumber("questPlayerSpellAntiGravityPotionQuantity", 0);
Saving.registerNumber("questPlayerSpellTurtlePotionQuantity", 0);
Saving.registerNumber("questPlayerSpellBerserkPotionQuantity", 0);
Saving.registerNumber("questPlayerSpellCloningPotionQuantity", 0);
Saving.registerNumber("questPlayerSpellPPotionQuantity", 0);
Saving.registerNumber("questPlayerSpellXPotionQuantity", 0);
var QuestPlayerSpell = (function () {
    // Constructor
    function QuestPlayerSpell(quest, buttonClassName, buttonPosition, buttonText, buttonColor, callbackCollection, countdownType, countdownTime, underlinedLetter, hotkeyLetter, numberIdWichLimitsQuantity) {
        if (underlinedLetter === void 0) { underlinedLetter = null; }
        if (hotkeyLetter === void 0) { hotkeyLetter = null; }
        if (numberIdWichLimitsQuantity === void 0) { numberIdWichLimitsQuantity = null; }
        this.quest = quest;
        this.buttonClassName = buttonClassName;
        this.buttonPosition = buttonPosition;
        this.buttonText = buttonText;
        this.buttonColor = buttonColor;
        this.callbackCollection = callbackCollection;
        this.countdownType = countdownType;
        this.countdownTime = countdownTime;
        this.underlinedLetter = underlinedLetter;
        this.hotkeyLetter = hotkeyLetter;
        this.numberIdWichLimitsQuantity = numberIdWichLimitsQuantity;
    }
    // Public methods
    QuestPlayerSpell.prototype.draw = function (renderArea, position) {
        // Set the text
        var text = this.buttonText;
        // Possibly modify the text depending on numberIdWichLimitsQuantity
        if (this.numberIdWichLimitsQuantity != null) {
            if (Saving.loadNumber(this.numberIdWichLimitsQuantity) <= 999)
                text += " " + Saving.loadNumber(this.numberIdWichLimitsQuantity);
            else
                text += " 999+";
        }
        // Add the button
        renderArea.addAsciiRealButton(text, position.x + this.buttonPosition.x, position.y + this.buttonPosition.y, this.buttonClassName + " keepBlackTextWhenInverted", "", false, this.underlinedLetter, this.buttonColor);
        // Add the link
        renderArea.addLinkCall("." + this.buttonClassName, new CallbackCollection(this.cast.bind(this)));
    };
    QuestPlayerSpell.prototype.getHotkey = function () {
        return new Hotkey(this.hotkeyLetter, new CallbackCollection(this.cast.bind(this)));
    };
    // Public getters
    QuestPlayerSpell.prototype.getButtonPosition = function () {
        return this.buttonPosition;
    };
    // Private methods
    QuestPlayerSpell.prototype.cast = function () {
        var canWeCast = true;
        // Ceck if the quest is ended to possibly set canWeCast to false
        if (this.quest.getQuestEnded())
            canWeCast = false;
        // Check the countdown to possibly set canWeCast to false
        if (canWeCast == true) {
            switch (this.countdownType) {
                case QuestPlayerSpellCountdownType.SPELLS:
                    if (this.quest.getPlayerSpellsCountdown() > 0)
                        canWeCast = false;
                    break;
                case QuestPlayerSpellCountdownType.POTIONS:
                    if (this.quest.getPlayerPotionsCountdown() > 0)
                        canWeCast = false;
                    break;
                case QuestPlayerSpellCountdownType.BLACKHOLE:
                    if (this.countdownTime <= 0)
                        canWeCast = false;
                    break;
                default: break;
            }
        }
        // Check the numberIdWichLimitsQuantity to possibly set canWeCast to false
        if (this.numberIdWichLimitsQuantity != null) {
            if (Saving.loadNumber(this.numberIdWichLimitsQuantity) <= 0) {
                canWeCast = false;
            }
        }
        // If we can cast
        if (canWeCast == true) {
            // Handle the countdown
            switch (this.countdownType) {
                case QuestPlayerSpellCountdownType.SPELLS:
                    this.quest.increasePlayerSpellsCountdown(this.countdownTime);
                    break;
                case QuestPlayerSpellCountdownType.POTIONS:
                    this.quest.increasePlayerPotionsCountdown(this.countdownTime);
                    break;
                case QuestPlayerSpellCountdownType.BLACKHOLE:
                    this.countdownTime -= 1;
                    break;
                default: break;
            }
            // Handle numberIdWichLimitsQuantity
            if (this.numberIdWichLimitsQuantity != null) {
                Saving.saveNumber(this.numberIdWichLimitsQuantity, Saving.loadNumber(this.numberIdWichLimitsQuantity) - 1);
            }
            // Fire the callback collection which was given to us
            this.callbackCollection.fire();
        }
    };
    return QuestPlayerSpell;
})();
var QuestPlayerSpellCountdownType;
(function (QuestPlayerSpellCountdownType) {
    QuestPlayerSpellCountdownType[QuestPlayerSpellCountdownType["SPELLS"] = 0] = "SPELLS";
    QuestPlayerSpellCountdownType[QuestPlayerSpellCountdownType["POTIONS"] = 1] = "POTIONS";
    QuestPlayerSpellCountdownType[QuestPlayerSpellCountdownType["ITEM_CAPACITIES"] = 2] = "ITEM_CAPACITIES";
    QuestPlayerSpellCountdownType[QuestPlayerSpellCountdownType["BLACKHOLE"] = 3] = "BLACKHOLE";
})(QuestPlayerSpellCountdownType || (QuestPlayerSpellCountdownType = {}));
var Random;
(function (Random) {
    function between(a, b) {
        // BUGS
        if (Bugs.getUltimateBugLevel() >= 2)
            return b;
        return Math.floor(Math.random() * (b - a + 1)) + a;
    }
    Random.between = between;
    function flipACoin() {
        // BUGS
        if (Bugs.getUltimateBugLevel() >= 2)
            return true;
        if (Math.random() < 0.5)
            return false;
        return true;
    }
    Random.flipACoin = flipACoin;
    function fromArray(arr) {
        // BUGS
        if (Bugs.getUltimateBugLevel() >= 4)
            return fromArray(["a", "b", "c", "d", -852, null, "aniwey", "ilovebugs", "42", 42]);
        return arr[upTo(arr.length - 1)];
    }
    Random.fromArray = fromArray;
    function fromPosition(pos) {
        // BUGS
        if (Bugs.getUltimateBugLevel() >= 3)
            return new Pos(-pos.x, -pos.y);
        return new Pos(Random.upTo(pos.x), Random.upTo(pos.y));
    }
    Random.fromPosition = fromPosition;
    function oneChanceOutOf(n) {
        // BUGS
        if (Bugs.getUltimateBugLevel() >= 1)
            return flipACoin();
        if (this.upTo(n - 1) == 0)
            return true;
        return false;
    }
    Random.oneChanceOutOf = oneChanceOutOf;
    function upTo(n) {
        // BUGS
        if (Bugs.getUltimateBugLevel() >= 3)
            return -n;
        return Math.floor(Math.random() * (n + 1));
    }
    Random.upTo = upTo;
})(Random || (Random = {}));
///<reference path="QuestEntity.ts"/>
var Rat = (function (_super) {
    __extends(Rat, _super);
    // Constructor
    function Rat(quest, pos) {
        _super.call(this, quest, pos, new Naming("A rat", "a rat"), new RenderArea(3, 1), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 0), new Pos(3, 1))), new QuestEntityMovement());
        // Set gravity
        this.getQuestEntityMovement().setGravity(true);
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(3);
        this.setHp(3);
        // Set the ascii art
        this.getRenderArea().drawArray(Database.getAscii("places/quests/cellar/rat"));
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("Its teeth", "its teeth"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(5, 2))), 1));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setFixedDelay(3);
    }
    // Public methods
    Rat.prototype.willDie = function () {
        // We find a candy
        if (Random.oneChanceOutOf(3))
            this.getQuest().getGame().getQuestLog().addMessage(new QuestLogMessage(this.getDeathMessage() + " (and found " + Algo.pluralFormat(this.getQuest().foundCandies(1), " candy", " candies") + ")", this.getQuest().getCandiesFoundMessage()));
        else
            this.getQuest().getGame().getQuestLog().addMessage(new QuestLogMessage(this.getDeathMessage()));
    };
    return Rat;
})(QuestEntity);
///<reference path="EqItem.ts"/>
var RedEnchantedGloves = (function (_super) {
    __extends(RedEnchantedGloves, _super);
    // Constructor
    function RedEnchantedGloves() {
        _super.call(this, "eqItemGlovesRedEnchantedGloves", "eqItemGlovesRedEnchantedGlovesName", "eqItemGlovesRedEnchantedGlovesDescription", "eqItems/gloves/redEnchantedGloves");
        // The timer (to avoid casting fireballs too often..)
        this.currentTimer = 0;
        this.maxTimer = 5;
    }
    // Special ability
    RedEnchantedGloves.prototype.getSpecialAbility = function () {
        return "Randomly cast small fireballs around you (red enchanted gloves).";
    };
    // update
    RedEnchantedGloves.prototype.update = function (player, quest) {
        this.currentTimer += 1;
        // If the timer is ready
        if (this.currentTimer >= this.maxTimer) {
            // Cast the fireball
            this.castFireball(player, quest);
            // Reset the timer
            this.currentTimer = 0;
        }
    };
    // Private methods
    RedEnchantedGloves.prototype.castFireball = function (player, quest) {
        // Create the fireball
        var fireball = new Fireball(quest, player.getSpellCastingPosition(), new Naming("A small fireball", "a small fireball"), new Color(ColorType.RED_ENCHANTED_GLOVES_FIREBALL), new Pos(2, 1), 15, player.getAndPossiblyCreateSpellCastingDamageReason(new Naming("A small fireball", "a small fireball")));
        // Set the direction
        fireball.setTargetTypeNoTarget(Algo.getRandomNotImmobileDirectionUpToThisSpeed(1).multiply(new Pos(2, 2)));
        // Add the entity
        quest.addEntity(fireball);
    };
    return RedEnchantedGloves;
})(EqItem);
var RenderLinkCallbackCollection = (function (_super) {
    __extends(RenderLinkCallbackCollection, _super);
    // Constructor
    function RenderLinkCallbackCollection(callbackCollection) {
        _super.call(this);
        this.callbackCollection = callbackCollection;
    }
    // Public methods
    RenderLinkCallbackCollection.prototype.run = function () {
        this.callbackCollection.fire();
    };
    return RenderLinkCallbackCollection;
})(RenderLink);
var RenderLinkChange = (function (_super) {
    __extends(RenderLinkChange, _super);
    // Constructor
    function RenderLinkChange(element, callbackCollection) {
        _super.call(this);
        this.element = element;
        this.callbackCollection = callbackCollection;
    }
    // Public methods
    RenderLinkChange.prototype.run = function () {
        // We copy the render link so we can use it in the functions below
        var renderLink = this;
        $(this.element).change(function (event) {
            renderLink.callbackCollection.fire();
            return false; // Avoid event bubbling
        });
    };
    return RenderLinkChange;
})(RenderLink);
var RenderLinkCheckbox = (function (_super) {
    __extends(RenderLinkCheckbox, _super);
    // Constructor
    function RenderLinkCheckbox(element, callbackCollectionWhenChecked, callbackCollectionWhenUnchecked) {
        _super.call(this);
        this.element = element;
        this.callbackCollectionWhenChecked = callbackCollectionWhenChecked;
        this.callbackCollectionWhenUnchecked = callbackCollectionWhenUnchecked;
    }
    // Public methods
    RenderLinkCheckbox.prototype.run = function () {
        // We copy the render link so we can use it in the functions below
        var renderLink = this;
        // We set the change event
        $(this.element).change(function (event) {
            if ($(this).is(':checked')) {
                // We fire the callback collection
                renderLink.callbackCollectionWhenChecked.fire();
            }
            else {
                renderLink.callbackCollectionWhenUnchecked.fire();
            }
            return false; // Avoid event bubbling
        });
    };
    return RenderLinkCheckbox;
})(RenderLink);
var RenderLinkClick = (function (_super) {
    __extends(RenderLinkClick, _super);
    // Constructor
    function RenderLinkClick(element, callbackCollection) {
        _super.call(this);
        this.element = element;
        this.callbackCollection = callbackCollection;
    }
    // Public methods
    RenderLinkClick.prototype.run = function () {
        // We copy the render link so we can use it in the functions below
        var renderLink = this;
        $(this.element).mouseup(function (event) {
            renderLink.callbackCollection.fire();
            return false; // Avoid event bubbling
        });
    };
    return RenderLinkClick;
})(RenderLink);
var RenderLinkInput = (function (_super) {
    __extends(RenderLinkInput, _super);
    // Constructor
    function RenderLinkInput(element, enigmaAnswer, callbackCollection, callbackCollectionWrong) {
        _super.call(this);
        this.element = element;
        this.enigmaAnswer = enigmaAnswer;
        this.callbackCollection = callbackCollection;
        this.callbackCollectionWrong = callbackCollectionWrong;
    }
    // Public methods
    RenderLinkInput.prototype.run = function () {
        // We copy the render link so we can use it in the functions below
        var renderLink = this;
        // We set the change event
        $(this.element).change(function (event) {
            // We check if the new value correspond to the answer (if it does we fire the callbacks)
            if (renderLink.enigmaAnswer.isRight($(this).val()))
                renderLink.callbackCollection.fire();
            else if (renderLink.callbackCollectionWrong != null) {
                renderLink.callbackCollectionWrong.fire();
            }
            // We empty the input area
            $(this).val("");
            return false; // Avoid event bubbling
        });
        // We set the focus
        $(this.element).focus();
    };
    return RenderLinkInput;
})(RenderLink);
var RenderLinkOnHoverShowTooltip = (function (_super) {
    __extends(RenderLinkOnHoverShowTooltip, _super);
    // Constructor
    function RenderLinkOnHoverShowTooltip(classHover, classTooltip) {
        _super.call(this);
        this.classHover = classHover;
        this.classTooltip = classTooltip;
    }
    // Public methods
    RenderLinkOnHoverShowTooltip.prototype.run = function () {
        // We copy the render link so we can use it in the functions below
        var renderLink = this;
        // If we hover on the classHover elements
        $(this.classHover).hover(function (event) {
            // We show the classTooltip tooltips
            $(renderLink.classTooltip).css({
                "display": "block"
            });
            // Avoid event bubbling
            return false;
        });
        // Else, if we're out of the classHover elements
        $(this.classHover).mouseout(function (event) {
            // We stop showing the classTooltip tooltips
            $(renderLink.classTooltip).css({
                display: "none"
            });
            // Avoid event bubbling
            return false;
        });
        // If the mouse moves, we put the classTooltip elements under the mouse
        $(this.classHover).on('mousemove', function (e) {
            $(renderLink.classTooltip).css({
                left: e.pageX - $(document).scrollLeft(),
                top: e.pageY - $(document).scrollTop()
            });
        });
    };
    return RenderLinkOnHoverShowTooltip;
})(RenderLink);
///<reference path="RenderLink.ts"/>
var RenderLinkOver = (function (_super) {
    __extends(RenderLinkOver, _super);
    // Constructor
    function RenderLinkOver(firstElement, secondElement) {
        _super.call(this);
        this.firstElement = firstElement;
        this.secondElement = secondElement;
    }
    // Public methods
    RenderLinkOver.prototype.run = function () {
        // We copy the render link so we can use it in the functions below
        var renderLink = this;
        $(this.firstElement).mouseenter(function (event) {
            $(renderLink.secondElement).show();
            return false; // Avoid event bubbling
        })
            .mouseleave(function (event) {
            $(renderLink.secondElement).hide();
            return false; // Avoid event bubbling
        });
        /*
        $(this.firstElement).hover(
            function(){
                $(renderLink.secondElement).css('visibility', 'visible');
            },
            function(){
                $(renderLink.secondElement).css('visibility', 'hidden');
            }
        );
        */
    };
    return RenderLinkOver;
})(RenderLink);
var RenderLinkSimpleInput = (function (_super) {
    __extends(RenderLinkSimpleInput, _super);
    // Constructor
    function RenderLinkSimpleInput(element, callbackCollection, defaultValue, hasFocus) {
        _super.call(this);
        this.element = element;
        this.callbackCollection = callbackCollection;
        this.defaultValue = defaultValue;
        this.hasFocus = hasFocus;
    }
    // Public methods
    RenderLinkSimpleInput.prototype.run = function () {
        // We copy the render link so we can use it in the functions below
        var renderLink = this;
        // If the default value isn't null
        if (this.defaultValue != null) {
            // We set the default value
            $(this.element).val(this.defaultValue);
        }
        // We set the change event
        $(this.element).change(function (event) {
            // We fire the callback collection
            renderLink.callbackCollection.fire();
            return false; // Avoid event bubbling
        });
        if (this.hasFocus)
            $(this.element).focus();
    };
    return RenderLinkSimpleInput;
})(RenderLink);
///<reference path="RenderTag.ts"/>
var RenderTagLt = (function (_super) {
    __extends(RenderTagLt, _super);
    // Constructor
    function RenderTagLt(x) {
        _super.call(this, x, "");
    }
    // Public methods
    RenderTagLt.prototype.clone = function () {
        return _super.prototype.clone.call(this);
    };
    RenderTagLt.prototype.draw = function (str) {
        // Instead of adding ourselves, we delete one character under the x position and then add the "&lt;"
        str = str.replaceAt(this.getX(), "&");
        return str.addAt(this.getX() + 1, "lt;");
    };
    return RenderTagLt;
})(RenderTag);
var RenderTransparency = (function () {
    // Constructor
    function RenderTransparency(alphaCharacter, metaAlphaCharacter) {
        if (metaAlphaCharacter === void 0) { metaAlphaCharacter = null; }
        this.alphaCharacter = alphaCharacter;
        this.metaAlphaCharacter = metaAlphaCharacter;
    }
    // Public getters
    RenderTransparency.prototype.getAlphaCharacter = function () {
        return this.alphaCharacter;
    };
    RenderTransparency.prototype.getMetaAlphaCharacter = function () {
        return this.metaAlphaCharacter;
    };
    return RenderTransparency;
})();
///<reference path="EqItem.ts"/>
var RocketBoots = (function (_super) {
    __extends(RocketBoots, _super);
    // Constructor
    function RocketBoots() {
        _super.call(this, "eqItemBootsRocketBoots", "eqItemBootsRocketBootsName", "eqItemBootsRocketBootsDescription", "eqItems/boots/rocketBoots");
    }
    // Special ability
    RocketBoots.prototype.getSpecialAbility = function () {
        return "Jump in mid-air without limit (rocket boots).";
    };
    return RocketBoots;
})(EqItem);
///<reference path="Game.ts"/>
///<reference path="./../../libs/jquery.d.ts"/>
var Main;
(function (Main) {
    // The game
    var game = null;
    // Information about loading
    var loadingType = MainLoadingType.NONE;
    var loadingString = null;
    // Information about the game mode
    var gameMode = null;
    // Public functions    
    function documentIsReady() {
        Keyboard.execute(); // Execute the Kayboard jquery stuff
        start(); // Start the game
    }
    Main.documentIsReady = documentIsReady;
    function reloadEverythingFromFile(fileContent) {
        // Clear intervals for the current game
        game.clearAllIntervals();
        // Set the loading type
        loadingType = MainLoadingType.FILE;
        // Set the loading string
        loadingString = fileContent;
        // Set the gamemode (null so that it is set from loading)
        gameMode = null;
        // We can't register anymore
        Saving.canRegister = false;
        // Finally start (this will erase the current game)
        start();
    }
    Main.reloadEverythingFromFile = reloadEverythingFromFile;
    function setUrlData(urlData) {
        // Create some variables
        var beforeEqual;
        var afterEqual;
        // If there's something in the url and we can find an equal sign and this equal sign isn't the last character of the string
        if (urlData != "" && urlData.indexOf("=") != -1 && urlData.indexOf("=") < urlData.length - 1) {
            // Strip the question mark
            urlData = urlData.substr(1);
            // Separate the data in two parts : before and after the equal sign
            beforeEqual = urlData.substr(0, urlData.indexOf("="));
            afterEqual = urlData.substr(urlData.indexOf("=") + 1);
            // Do different things depending on the value of beforeEqual
            switch (beforeEqual) {
                // If we're trying to load a local slot
                case "slot":
                    loadingType = MainLoadingType.LOCAL;
                    loadingString = "slot" + afterEqual;
                    break;
                // If we're trying to launch a new game with a special mode
                case "gamemode":
                    gameMode = afterEqual;
                    break;
            }
        }
    }
    Main.setUrlData = setUrlData;
    function start() {
        game = new Game(gameMode);
        Keyboard.setGame(game);
        Saving.load(game, loadingType, loadingString);
        game.postLoad();
    }
})(Main || (Main = {}));
$(document).ready(function () {
    Main.setUrlData(window.location.search);
    Main.documentIsReady();
});
///<reference path="Place.ts"/>
///<reference path="main.ts"/>
var Save = (function (_super) {
    __extends(Save, _super);
    // Constructor
    function Save(game) {
        _super.call(this, game);
        // The render area
        this.renderArea = new RenderArea();
        // The currently selected slot (slot1 by default)
        this.selectedSlot = "slot1";
        // The last local autosave minute we drew (used to refresh the page at the right time)
        this.lastLocalAutosaveMinute = null;
        // Should we show the file save warning?
        this.showFileSaveWarning = false;
        // The textarea content
        this.fileSaveTextareaContent = null;
        // Resize
        this.resize();
        // Create the slots array
        this.createSlotsArray();
        // Update
        this.update();
    }
    // getRenderArea()
    Save.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // willBeDisplayed()
    Save.prototype.willBeDisplayed = function () {
        // We resize (we must do this there and not in the constructor because the size depends on the translation)
        this.resize();
        // We add a callback : we will be updated every second (in order to show the correct time for the local autosave countdown)
        this.getGame().getOneSecondCallbackCollection().addCallback(this.oneSecondCallback.bind(this));
    };
    // Private methods
    Save.prototype.clickedAutosave = function () {
        // Save on the selected slot
        Saving.save(this.getGame(), MainLoadingType.LOCAL, this.selectedSlot);
        // Enable autosaving
        this.getGame().enableLocalAutosave(this.selectedSlot);
        // Re-create the slots array
        this.createSlotsArray();
        // Update
        this.update();
        this.getGame().updatePlace();
    };
    Save.prototype.clickedDisableAutosave = function () {
        // We disable auto saving
        this.getGame().disableLocalAutosave();
        // We update
        this.update();
        this.getGame().updatePlace();
    };
    Save.prototype.clickedFileLoad = function () {
        Main.reloadEverythingFromFile($(".saveFileLoadTextarea").val());
    };
    Save.prototype.clickedFileSave = function () {
        // Save some special variables by calling the save() methods of various objects
        this.getGame().save(); // Various variables owned by the game object
        this.getGame().getPlayer().save(); // The player
        // We now show the warning
        this.showFileSaveWarning = true;
        // Reset the textarea content
        this.fileSaveTextareaContent = "";
        // Write bools
        for (var str in Saving.getAllBools()) {
            if (this.fileSaveTextareaContent != "")
                this.fileSaveTextareaContent += ", "; // We add a comma if we're not adding the very first variable
            this.fileSaveTextareaContent += "bool " + str + "=" + Saving.boolToString(Saving.getAllBools()[str]);
        }
        // Write numbers
        for (var str in Saving.getAllNumbers()) {
            if (this.fileSaveTextareaContent != "")
                this.fileSaveTextareaContent += ", "; // We add a comma if we're not adding the very first variable
            this.fileSaveTextareaContent += "number " + str + "=" + Saving.numberToString(Saving.getAllNumbers()[str]);
        }
        // Write strings
        for (var str in Saving.getAllStrings()) {
            if (this.fileSaveTextareaContent != "")
                this.fileSaveTextareaContent += ", "; // We add a comma if we're not adding the very first variable
            this.fileSaveTextareaContent += "string " + str + "=" + Saving.getAllStrings()[str];
        }
        // Update
        this.update();
        this.getGame().updatePlace();
    };
    Save.prototype.clickedSave = function () {
        // Save on the selected slot
        Saving.save(this.getGame(), MainLoadingType.LOCAL, this.selectedSlot);
        // Re-create the slots array
        this.createSlotsArray();
        // Update
        this.update();
        this.getGame().updatePlace();
    };
    Save.prototype.createSlotsArray = function () {
        // Reset the array
        this.slotsArray = [];
        // Fill it
        for (var i = 1; i <= 5; i++) {
            this.slotsArray.push("slot" + i.toString());
            this.slotsArray.push("Slot " + i.toString() + " (" + LocalSaving.getSlotSummaryAsString("slot" + i.toString()) + ")");
        }
    };
    Save.prototype.drawGreen = function (text, x, y, translated) {
        if (translated === void 0) { translated = false; }
        this.renderArea.drawString(text, x, y, translated);
        this.renderArea.addColor(x, x + text.length, y, new Color(ColorType.SAVE_GREEN));
    };
    Save.prototype.drawLocalLoad = function (x, y) {
        // The y we will return (will remain 0 if there's no translation to show)
        var yAdd = 0;
        // Var we will use for link generation
        var link;
        // Title
        this.drawTitle("saveLocalLoadTitle", y + yAdd);
        // If we support local saving
        if (LocalSaving.supportsLocalSaving()) {
            // "You can load.."
            this.drawPoint("saveLocalLoadYouCan", x, y + yAdd + 2);
            if (Database.isTranslated())
                yAdd += 1;
            // The links
            for (var i = 1; i <= 5; i++) {
                link = "http://candybox2.github.io/?slot=" + i.toString();
                this.renderArea.addHtmlLink(x + 2, y + yAdd + 3 + i, link, link);
                this.renderArea.drawString("(slot " + i.toString() + ")", x + link.length + 4, y + yAdd + 3 + i);
            }
            // "Thanks to.."
            this.drawPoint("saveLocalLoadThanksTo", x, y + yAdd + 10);
            if (Database.isTranslated())
                yAdd += 1;
        }
        else {
            // Warning messages
            this.drawWarning(Database.getText("saveLocalSaveWarning0") + " (local storage and application cache)", x, y + yAdd + 2);
            this.drawWarning(Database.getText("saveLocalSaveWarning1"), x, y + yAdd + 3);
            this.drawWarning(Database.getTranslatedText("saveLocalSaveWarning0"), x, y + yAdd + 5, true);
            this.drawWarning(Database.getTranslatedText("saveLocalSaveWarning1"), x, y + yAdd + 6, true);
        }
        // Return yAdd
        return yAdd;
    };
    Save.prototype.drawLocalSave = function (x, y) {
        // The y we will return (will remain 0 if there's no translation to show)
        var yAdd = 0;
        // Title & why
        this.drawTitle("saveLocalSaveTitle", y + yAdd);
        this.drawPoint("saveLocalSaveWhy", x, y + yAdd + 2);
        if (Database.isTranslated())
            yAdd += 1;
        // If we support local saving
        if (LocalSaving.supportsLocalSaving()) {
            // Choose a slot text
            this.drawPoint("saveLocalSaveChooseSlot", x, y + yAdd + 4);
            // Slots list
            this.renderArea.addList(x + 5, x + 45, y + yAdd + 7, "saveLocalSaveSlotsList", new CallbackCollection(this.slotSelected.bind(this)), this.slotsArray);
            // Autosave enabled ?
            if (this.getGame().getLocalAutosaveEnabled()) {
                this.drawGreen(Database.getText("saveLocalSaveAutosaveEnabled"), x, y + yAdd + 9);
                if (Database.getTranslatedText("saveLocalSaveAutosaveEnabled") != "")
                    this.drawGreen("(" + Database.getTranslatedText("saveLocalSaveAutosaveEnabled") + ")", x, y + yAdd + 10, true);
                this.drawGreen("Next save in " + Algo.pluralFormat(Math.ceil(this.getGame().getLocalAutosaveTime() / 60), " minute", " minutes") + " on slot " + this.getGame().getLocalAutosaveSlot().substr(4, 1) + ".", x, y + yAdd + 11);
            }
            // Separation lines
            this.renderArea.drawVerticalLine("|", x + 50, y + yAdd + 5, y + yAdd + 11);
            this.renderArea.drawHorizontalLine("-", x, x + 100, y + yAdd + 3);
            this.renderArea.drawHorizontalLine("-", x, x + 100, y + yAdd + 12);
            // Choose what to do text
            this.drawPoint("saveLocalSaveChooseWhatToDo", x + 51, y + yAdd + 4);
            // Add save button
            this.renderArea.addAsciiRealButton(Database.getText("saveLocalSaveSaveButton") + " on slot " + this.selectedSlot.substr(4, 1), x + 51, y + yAdd + 7, "saveLocalSaveSaveButton", Database.getTranslatedText("saveLocalSaveSaveButton"), true, -1, null, false);
            this.renderArea.addLinkCall(".saveLocalSaveSaveButton", new CallbackCollection(this.clickedSave.bind(this)));
            // If autosave is disabled or it's not enabled on the currently selected slot
            if (this.getGame().getLocalAutosaveEnabled() == false) {
                // Add autosave button
                this.renderArea.addAsciiRealButton(Database.getText("saveLocalSaveAutosaveButton") + " on slot " + this.selectedSlot.substr(4, 1), x + 51, y + yAdd + 10, "saveLocalSaveAutosaveButton", Database.getTranslatedText("saveLocalSaveAutosaveButton"), true, -1, null, false);
                this.renderArea.addLinkCall(".saveLocalSaveAutosaveButton", new CallbackCollection(this.clickedAutosave.bind(this)));
            }
            else {
                // Add disable autosave button
                this.renderArea.addAsciiRealButton(Database.getText("saveLocalSaveDisableAutosaveButton"), x + 51, y + yAdd + 10, "saveLocalSaveDisableAutosaveButton", Database.getTranslatedText("saveLocalSaveDisableAutosaveButton"), true, -1, null, false);
                this.renderArea.addLinkCall(".saveLocalSaveDisableAutosaveButton", new CallbackCollection(this.clickedDisableAutosave.bind(this)));
            }
        }
        else {
            // Warning messages
            this.drawWarning(Database.getText("saveLocalSaveWarning0") + " (local storage and application cache)", x, y + yAdd + 4);
            this.drawWarning(Database.getText("saveLocalSaveWarning1"), x, y + yAdd + 5);
            this.drawWarning(Database.getTranslatedText("saveLocalSaveWarning0"), x, y + yAdd + 7, true);
            this.drawWarning(Database.getTranslatedText("saveLocalSaveWarning1"), x, y + yAdd + 8, true);
        }
        // Return yAdd
        return yAdd;
    };
    Save.prototype.drawFileLoad = function (x, y) {
        // The y we will return (will remain 0 if there's no translation to show)
        var yAdd = 0;
        // Title
        this.drawTitle("saveFileLoadTitle", y + yAdd);
        // Instructions
        this.renderArea.drawString(Database.getText("saveFileLoadPaste"), x, y + yAdd + 2);
        this.renderArea.drawString(Database.getTranslatedText("saveFileLoadPaste"), x, y + yAdd + 3, true);
        // Add the text area
        this.renderArea.addTextarea(x + 2, y + yAdd + 5, 96, 6, "saveFileLoadTextarea");
        // Add the load button
        this.renderArea.addAsciiRealButton(Database.getText("saveFileLoadButton"), 48, y + yAdd + 13, "saveFileLoadButton", Database.getTranslatedText("saveFileLoadButton"), true);
        this.renderArea.addLinkCall(".saveFileLoadButton", new CallbackCollection(this.clickedFileLoad.bind(this)));
        // Return yAdd
        return yAdd;
    };
    Save.prototype.drawFileSave = function (x, y) {
        // The y we will return (will remain 0 if there's no translation to show)
        var yAdd = 0;
        // The title
        this.drawTitle("saveFileSaveTitle", y + yAdd);
        // The "why"
        this.renderArea.drawString(Database.getText("saveFileSaveWhy0"), x, y + yAdd + 2);
        this.renderArea.drawString(" - " + Database.getText("saveFileSaveWhy1"), x, y + yAdd + 3);
        this.renderArea.drawString(" - " + Database.getText("saveFileSaveWhy2"), x, y + yAdd + 4);
        this.renderArea.drawString(" - " + Database.getText("saveFileSaveWhy3"), x, y + yAdd + 5);
        this.renderArea.drawString("   " + Database.getText("saveFileSaveWhy4"), x, y + yAdd + 6);
        // The translated "why" (only if there's a translation)
        if (Database.isTranslated()) {
            this.renderArea.drawString(Database.getTranslatedText("saveFileSaveWhy0"), x, y + yAdd + 8, true);
            this.renderArea.drawString(" - " + Database.getTranslatedText("saveFileSaveWhy1"), x, y + yAdd + 9, true);
            this.renderArea.drawString(" - " + Database.getTranslatedText("saveFileSaveWhy2"), x, y + yAdd + 10, true);
            this.renderArea.drawString(" - " + Database.getTranslatedText("saveFileSaveWhy3"), x, y + yAdd + 11, true);
            this.renderArea.drawString("   " + Database.getTranslatedText("saveFileSaveWhy4"), x, y + yAdd + 12, true);
            yAdd += 6; // We increase yAdd by 6 because the translations took 6 lines
        }
        // Add the button
        this.renderArea.addAsciiRealButton(Database.getText("saveFileSaveButton"), 35, y + yAdd + 8, "saveFileSaveButton", Database.getTranslatedText("saveFileSaveButton"), true);
        this.renderArea.addLinkCall(".saveFileSaveButton", new CallbackCollection(this.clickedFileSave.bind(this)));
        // Add the text area
        this.renderArea.addTextarea(x + 2, y + yAdd + 11, 96, 6, "saveFileSaveTextarea", (this.fileSaveTextareaContent != null ? this.fileSaveTextareaContent : ""));
        // Should we show the warning?
        if (this.showFileSaveWarning) {
            this.drawWarning(Database.getText("saveFileSaveWarning"), x + 2, y + yAdd + 12);
            this.drawWarning(Database.getTranslatedText("saveFileSaveWarning"), x + 2, y + yAdd + 13, true);
        }
        // We return yAdd
        return yAdd;
    };
    Save.prototype.drawPoint = function (textName, x, y) {
        this.renderArea.drawString(Database.getText(textName), x, y);
        this.renderArea.drawString(Database.getTranslatedText(textName), x, y + 1, true);
    };
    Save.prototype.drawTitle = function (textName, y) {
        var x = 50 - Math.floor((Database.getText(textName).length / 2 + 1 + Database.getTranslatedText(textName).length / 2));
        this.renderArea.drawString(Database.getText(textName), x, y);
        this.renderArea.addBold(x, x + Database.getText(textName).length, y);
        this.renderArea.drawString(Database.getTranslatedText(textName), x + Database.getText(textName).length + 1, y, true);
    };
    Save.prototype.drawWarning = function (text, x, y, translated) {
        if (translated === void 0) { translated = false; }
        if (text != "") {
            this.renderArea.drawString(text, x, y, translated);
            this.renderArea.addColor(x, x + text.length, y, new Color(ColorType.SAVE_RED));
        }
    };
    Save.prototype.oneSecondCallback = function () {
        // If there's no last minute or it's different from the current minute
        if (this.lastLocalAutosaveMinute == null || this.lastLocalAutosaveMinute != Math.ceil(this.getGame().getLocalAutosaveTime() / 60)) {
            // We set the minute
            this.lastLocalAutosaveMinute = Math.ceil(this.getGame().getLocalAutosaveTime() / 60);
            // We update
            this.createSlotsArray();
            this.update();
            this.getGame().updatePlace();
        }
    };
    Save.prototype.resize = function () {
        // The size depends on if there's a translation or not
        if (Database.isTranslated())
            this.renderArea.resize(100, 84);
        else
            this.renderArea.resize(100, 74);
    };
    Save.prototype.selectRightSlot = function () {
        // We select the right slot
        $("#" + this.selectedSlot).prop('selected', true);
    };
    Save.prototype.slotSelected = function () {
        // Get the selected language id
        this.selectedSlot = $("#saveLocalSaveSlotsList").find(":selected").attr("id");
        // Update the ligthouse
        this.update();
        this.getGame().updatePlace();
    };
    Save.prototype.update = function () {
        var yPosition = 0; // The y position where we will add things. Can be incremented sometimes, depending on the user's language..
        // Erase everything
        this.renderArea.resetAllButSize();
        // Saving
        this.renderArea.drawArray(Database.getAscii("text/Saving"), 50 - Math.floor((Database.getAsciiWidth("text/Saving") / 2)), yPosition);
        yPosition += this.drawLocalSave(0, yPosition + 7);
        yPosition += this.drawFileSave(0, yPosition + 21);
        // Loading
        this.renderArea.drawArray(Database.getAscii("text/Loading"), 50 - Math.floor((Database.getAsciiWidth("text/Loading") / 2)), yPosition + 40);
        yPosition += this.drawLocalLoad(0, yPosition + 47);
        yPosition += this.drawFileLoad(0, yPosition + 59);
        // Add the link which will call the selectRightSlot method after the html dom is created
        this.renderArea.addLinkCallbackCollection(new CallbackCollection(this.selectRightSlot.bind(this)));
    };
    return Save;
})(Place);
///<reference path="EqItem.ts"/>
var Scythe = (function (_super) {
    __extends(Scythe, _super);
    // Constructor
    function Scythe() {
        _super.call(this, "eqItemWeaponScythe", "eqItemWeaponScytheName", "eqItemWeaponScytheDescription", "eqItems/weapons/scythe");
    }
    // Public getters
    Scythe.prototype.getQuestEntityWeapon = function (quest, player) {
        var qew = new QuestEntityWeapon(quest, player, new Naming("A scythe", "a scythe"), player.getClassicCollisionBoxCollection(), 21);
        qew.getCloseCombatDelay().setFixedDelay(0);
        return qew;
    };
    return Scythe;
})(EqItem);
///<reference path="QuestEntity.ts"/>
var SeaSnake = (function (_super) {
    __extends(SeaSnake, _super);
    // Constructor
    function SeaSnake(quest, pos) {
        _super.call(this, quest, pos, new Naming("A sea snake", "a sea snake"), new RenderArea(78, 11), new Pos(0, 0));
        // Set the movement and the animation
        this.setQuestEntityMovement(new QuestEntityMovement(new Pos(-Random.between(3, 5), 0)));
        this.setQuestEntityAnimation(new QuestEntityAnimation(0, 0, Random.upTo(11), "places/quests/theSea/seaSnake/1", "places/quests/theSea/seaSnake/2", "places/quests/theSea/seaSnake/3", "places/quests/theSea/seaSnake/4", "places/quests/theSea/seaSnake/5", "places/quests/theSea/seaSnake/6", "places/quests/theSea/seaSnake/7", "places/quests/theSea/seaSnake/8", "places/quests/theSea/seaSnake/9", "places/quests/theSea/seaSnake/10", "places/quests/theSea/seaSnake/11", "places/quests/theSea/seaSnake/12"));
        // Set the transparency
        this.setTransparency(new RenderTransparency(" ", "%"));
        // Set destructible
        this.setDestructible(false);
    }
    // update()
    SeaSnake.prototype.update = function () {
        // Launch a magic ball! (2 chances out of 3 to launch one)
        if (Random.oneChanceOutOf(3) == false)
            this.castWaterBall();
        // Call the mother class update method
        _super.prototype.update.call(this);
    };
    // Private methods
    SeaSnake.prototype.castWaterBall = function () {
        // Create the waterBall
        var waterBall = new Fireball(this.getQuest(), this.getGlobalPosition().plus(new Pos(-2, this.getYCastingOffset())), new Naming("A magical water ball", "a magical water ball"), new Color(ColorType.SEAHORSE_WATER_BALL), new Pos(2, 1), 300, this.getAndPossiblyCreateSpellCastingDamageReason(new Naming("A magical water ball", "a magical water ball")));
        // No target
        waterBall.setTargetTypeNoTarget(new Pos(-Random.between(2, 4), Random.fromArray([-1, 0, 1])));
        // Add the entity
        this.getQuest().addEntity(waterBall);
    };
    SeaSnake.prototype.getYCastingOffset = function () {
        switch (this.getQuestEntityAnimation().getCurrentAsciiIndex()) {
            case 0:
                return 4;
                break;
            case 1:
                return 5;
                break;
            case 2:
                return 6;
                break;
            case 3:
                return 7;
                break;
            case 4:
                return 8;
                break;
            case 5:
                return 9;
                break;
            case 6:
                return 10;
                break;
            case 7:
                return 9;
                break;
            case 8:
                return 8;
                break;
            case 9:
                return 7;
                break;
            case 10:
                return 6;
                break;
            case 11:
                return 5;
                break;
        }
    };
    return SeaSnake;
})(QuestEntity);
///<reference path="QuestEntity.ts"/>
var Seahorse = (function (_super) {
    __extends(Seahorse, _super);
    // Constructor
    function Seahorse(quest, pos, intendedXPosition) {
        _super.call(this, quest, pos, new Naming("A magical seahorse", "a magical seahorse"), new RenderArea(4, 4), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 0), new Pos(3, 1)), new CollisionBox(this, new Pos(1, 1), new Pos(3, 1)), new CollisionBox(this, new Pos(2, 2), new Pos(1, 1)), new CollisionBox(this, new Pos(2, 3), new Pos(1, 1))), new QuestEntityMovement(new Pos(-1, 0)));
        // Set the intended x position
        this.intendedXPosition = intendedXPosition;
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(20);
        this.setHp(20);
        // Set the ascii art
        this.getRenderArea().drawArray(Database.getAscii("places/quests/theSea/seahorse"));
        // Set the transparency
        this.setTransparency(new RenderTransparency(" "));
        // Add a spell caster
        this.addQuestEntitySpellCaster(new QuestEntitySpellCaster(new CallbackCollection(this.castWaterBall.bind(this))));
        this.getLastQuestEntitySpellCaster().getDelay().setFixedDelay(30, Random.upTo(30));
    }
    // Public methods
    Seahorse.prototype.tryToGoToIntendedXPosition = function (baseX) {
        this.goTowards(this.getGlobalPosition(), new Pos(baseX + this.intendedXPosition, this.getGlobalPosition().y), 0, new Pos(1, 0));
    };
    // Private methods
    Seahorse.prototype.castWaterBall = function () {
        // Create the waterBall
        var waterBall = new Fireball(this.getQuest(), this.getGlobalPosition().plus(new Pos(-2, 0)), new Naming("A magical water ball", "a magical water ball"), new Color(ColorType.SEAHORSE_WATER_BALL), new Pos(2, 1), 70, this.getAndPossiblyCreateSpellCastingDamageReason(new Naming("A magical water ball", "a magical water ball")));
        // No target
        waterBall.setTargetTypeNoTarget(new Pos(-2, 0));
        // Add the entity
        this.getQuest().addEntity(waterBall);
    };
    // willDie()
    Seahorse.prototype.willDie = function () {
        this.getQuest().getGame().getQuestLog().addMessage(new QuestLogMessage(this.getDeathMessage() + " (and found " + Algo.pluralFormat(this.getQuest().foundCandies(150), " candy", " candies") + ")", this.getQuest().getCandiesFoundMessage()));
    };
    return Seahorse;
})(QuestEntity);
///<reference path="House.ts"/>
// Lollipops
Saving.registerBool("secondHouseLollipop1Bought", false);
Saving.registerBool("secondHouseLollipop2Bought", false);
Saving.registerBool("secondHouseLollipop3Bought", false);
// The leather boots
Saving.registerBool("secondHouseLeatherBootsBought", false);
// The chocolate bar
Saving.registerBool("secondHouseChocolateBarBought", false);
// The merchant's hat
Saving.registerBool("secondHouseMerchantHatBought", false);
// The time ring
Saving.registerBool("secondHouseTimeRingBought", false);
var SecondHouse = (function (_super) {
    __extends(SecondHouse, _super);
    // Constructor
    function SecondHouse(game) {
        // House constructor
        _super.call(this, game);
        this.renderArea = new RenderArea();
        // Items sold by the candy merchant
        this.items = [];
        // Selected item (an item is selected when the players clicks on it)
        this.selectedItemIndex = null;
        // Should we draw the intro speech ? (will be set to false as soon as we select an item)
        this.shouldDrawIntroSpeech = true;
        // We add all the items
        // Lollipops
        this.addItem(new CandyMerchantItem_Lollipop(this.getGame(), "secondHouseLollipop1Bought", "places/village/candyMerchantItems/lollipopRight", new Pos(14, 22), "secondHouseLollipop1Speech", 60, "secondHouseLollipopButtonText", "secondHouseLollipop1Button"));
        this.addItem(new CandyMerchantItem_Lollipop(this.getGame(), "secondHouseLollipop2Bought", "places/village/candyMerchantItems/lollipopLeft", new Pos(12, 23), "secondHouseLollipop2Speech", 60, "secondHouseLollipopButtonText", "secondHouseLollipop2Button"));
        this.addItem(new CandyMerchantItem_Lollipop(this.getGame(), "secondHouseLollipop3Bought", "places/village/candyMerchantItems/lollipopRight", new Pos(18, 24), "secondHouseLollipop3Speech", 60, "secondHouseLollipopButtonText", "secondHouseLollipop3Button"));
        // The leather boots
        this.addItem(new CandyMerchantItem_LeatherBoots(this.getGame(), "eqItemBootsLeatherBoots", "places/village/candyMerchantItems/boots", new Pos(5, 25), "secondHouseLeatherBootsSpeech", 300, "secondHouseLeatherBootsButtonText", "secondHouseLeatherBootsButton"));
        // The chocolate bar
        this.addItem(new CandyMerchantItem_ChocolateBar(this.getGame(), "secondHouseChocolateBarBought", "places/village/candyMerchantItems/chocolateBar", new Pos(62, 27), "secondHouseChocolateBarSpeech", 800, "secondHouseChocolateBarButtonText", "secondHouseChocolateBarButton"));
        // The merchant hat
        this.addItem(new CandyMerchantItem_MerchantHat(this.getGame(), "secondHouseMerchantHatBought", "places/village/candyMerchantItems/hat", new Pos(53, 13), "secondHouseMerchantHatSpeech", 1000000, "secondHouseMerchantHatButtonText", "secondHouseMerchantHatButton"));
        // The time ring
        this.addItem(new CandyMerchantItem_TimeRing(this.getGame(), "secondHouseTimeRingBought", "places/village/candyMerchantItems/timeRing", new Pos(43, 28), "secondHouseTimeRingSpeech", 500, "secondHouseTimeRingButtonText", "secondHouseTimeRingButton"));
        // Leather gloves
        this.addItem(new CandyMerchantItem_LeatherGloves(this.getGame(), "eqItemGlovesLeatherGloves", "places/village/candyMerchantItems/leatherGloves", new Pos(82, 27), "secondHouseLeatherGlovesSpeech", 300, "secondHouseLeatherGlovesButtonText", "secondHouseLeatherGlovesButton"));
        // We resize the render area and update it
        this.renderArea.resizeFromArray(Database.getAscii("places/village/secondHouse"), 0, 3);
        this.update();
    }
    // Public methods
    SecondHouse.prototype.willBeDisplayed = function () {
        // We need to update each time we're going to be displayed in case some item should not be sold anymore because of some stuff we were doing while this place wasn't displayed
        this.update();
    };
    // getRenderArea()
    SecondHouse.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // Private methods
    SecondHouse.prototype.addItem = function (item) {
        this.items.push(item);
    };
    SecondHouse.prototype.buySelectedItem = function () {
        // If we have enough candies to buy it
        if (this.getGame().getCandies().getCurrent() >= this.items[this.selectedItemIndex].getPrice()) {
            // We pay the price
            this.getGame().getCandies().add(-this.items[this.selectedItemIndex].getPrice());
            // We tell the item that we just bought it
            this.items[this.selectedItemIndex].buy();
            // No more selected item
            this.selectedItemIndex = null;
            // We update
            this.update();
            this.getGame().updatePlace();
        }
    };
    SecondHouse.prototype.clickedOnItem = function (index) {
        // Set the currently selected item index
        this.selectedItemIndex = index;
        // We shouldn't draw the intro speech anymore
        this.shouldDrawIntroSpeech = false;
        // Update
        this.update();
        this.getGame().updatePlace();
    };
    SecondHouse.prototype.drawIntroSpeech = function () {
        this.drawSpeech("secondHouseIntroSpeech");
    };
    SecondHouse.prototype.drawItems = function () {
        for (var i = 0; i < this.items.length; i++) {
            // If we can show this item
            if (this.items[i].canBeShown()) {
                // We draw the item at the correct position
                this.renderArea.drawArray(Database.getAscii(this.items[i].getAsciiName()), this.items[i].getAsciiPosition().x, this.items[i].getAsciiPosition().y, new RenderTransparency(" ", "%"));
                // If it can be clicked
                if (this.items[i].canBeClicked()) {
                    // We add the button and the link to be able to click it (we add it on each line of the ascii art)
                    for (var j = 0; j < Database.getAsciiHeight(this.items[i].getAsciiName()); j++) {
                        // Button
                        this.renderArea.addAsciiButton(this.items[i].getAsciiPosition().x, this.items[i].getAsciiPosition().x + Database.getAsciiWidth(this.items[i].getAsciiName()), this.items[i].getAsciiPosition().y + j, this.items[i].getButtonName() + "RealItem");
                        // Link
                        this.renderArea.addLinkCall("." + this.items[i].getButtonName() + "RealItem", new CallbackCollection(this.clickedOnItem.bind(this, i)));
                    }
                }
            }
        }
    };
    SecondHouse.prototype.drawSelectedItemStuff = function () {
        var yPos; // Will contain the y position of the bottom of the speech
        // Draw the speech
        yPos = this.drawSpeech(this.items[this.selectedItemIndex].getMerchantSpeech());
        // If we can buy this item
        if (this.items[this.selectedItemIndex].canBeBought()) {
            // Add the buying button
            this.renderArea.addAsciiRealButton(Database.getText(this.items[this.selectedItemIndex].getButtonText()), 45 - Math.floor(Database.getText(this.items[this.selectedItemIndex].getButtonText()).length / 2), yPos + 2, this.items[this.selectedItemIndex].getButtonName() + "BuyingButton", Database.getTranslatedText(this.items[this.selectedItemIndex].getButtonText()), true);
            // Add the link
            this.renderArea.addLinkCall("." + this.items[this.selectedItemIndex].getButtonName() + "BuyingButton", new CallbackCollection(this.buySelectedItem.bind(this)));
        }
    };
    SecondHouse.prototype.drawSpeech = function (speechName) {
        return this.renderArea.drawSpeech(Database.getText(speechName), 3, 30, 60, "secondHouseMerchantSpeech", Database.getTranslatedText(speechName));
    };
    SecondHouse.prototype.update = function () {
        // Erase everything
        this.renderArea.resetAllButSize();
        // Back to the village button
        this.addBackToTheVillageButton(this.renderArea, "secondHouseBackToTheVillageButton");
        // Draw the house
        this.renderArea.drawArray(Database.getAscii("places/village/secondHouse"), 0, 3);
        // Draw items
        this.drawItems();
        // Should we draw the intro speech ?
        if (this.shouldDrawIntroSpeech)
            this.drawIntroSpeech();
        // If there's a selected item, draw the stuff related to it (speech and possibly buying button)
        if (this.selectedItemIndex != null) {
            this.drawSelectedItemStuff();
        }
    };
    return SecondHouse;
})(House);
///<reference path="QuestEntity.ts"/>
var ShellPowder = (function (_super) {
    __extends(ShellPowder, _super);
    // Constructor
    function ShellPowder(quest, leftDownCornerPosition) {
        // Create the real global position
        var globalPosition = leftDownCornerPosition;
        globalPosition.add(new Pos(0, -Database.getAsciiHeight("places/quests/theSea/shellPowder") + 1));
        // Call the mother constructor
        _super.call(this, quest, globalPosition, new Naming("Shell powder", "shell powder"), new RenderArea(), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 0), new Pos(6, 3))));
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(10);
        this.setHp(10);
        // Set the team (nature)
        this.setTeam(QuestEntityTeam.NATURE);
        // Draw the ascii art
        this.getRenderArea().resizeFromArray(Database.getAscii("places/quests/theSea/shellPowder"));
        this.getRenderArea().drawArray(Database.getAscii("places/quests/theSea/shellPowder"));
    }
    // willDie()
    ShellPowder.prototype.willDie = function () {
        _super.prototype.willDie.call(this);
        this.getQuest().foundGridOrEqItem(new QuestItemFound(this.getQuest(), "gridItemPossessedShellPowder", "You found shell powder.", "You gain shell powder."));
    };
    return ShellPowder;
})(QuestEntity);
///<reference path="QuestEntity.ts"/>
var SmallestFish = (function (_super) {
    __extends(SmallestFish, _super);
    // Constructor
    function SmallestFish(quest, pos) {
        _super.call(this, quest, pos, new Naming("A very small fish", "a very small fish"), new RenderArea(3, 1), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 0), new Pos(3, 1))), new QuestEntityMovement(new Pos(-1, 0)));
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(10);
        this.setHp(10);
        // Set the ascii art
        this.getRenderArea().drawArray(Database.getAscii("places/quests/theSea/smallestFish"));
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("Its fins", "its fins"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(5, 2))), 1));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setFixedDelay(6);
    }
    return SmallestFish;
})(QuestEntity);
var Smoke = (function () {
    // Constructor
    function Smoke(x, y, width, height, minWaitingTime, maxWaitingTime) {
        if (minWaitingTime === void 0) { minWaitingTime = 0; }
        if (maxWaitingTime === void 0) { maxWaitingTime = 0; }
        // Position
        this.x = x;
        this.y = y;
        // Size
        this.width = width;
        this.height = height;
        // Waiting time
        this.minWaitingTime = minWaitingTime;
        this.maxWaitingTime = maxWaitingTime;
        // Init the smoke
        this.init(false);
    }
    // Public methods
    Smoke.prototype.draw = function (renderArea) {
        // If we're not waiting, we draw a smoke
        if (this.weAreWaiting == false) {
            if (this.inverted == false) {
                renderArea.drawString("(", this.x + this.xGap, this.y + this.yGap);
                renderArea.drawString(")", this.x + this.xGap + 1, this.y + this.yGap - 1);
            }
            else {
                renderArea.drawString("(", this.x + this.xGap, this.y + this.yGap - 1);
                renderArea.drawString(")", this.x + this.xGap + 1, this.y + this.yGap);
            }
        }
    };
    Smoke.prototype.move = function () {
        if (this.weAreWaiting == false) {
            // We make the smoke going up
            this.yGap--;
            // If it's too high, we call init()
            if (-this.yGap >= this.height) {
                this.init();
            }
            else {
                this.inverted = !this.inverted;
            }
        }
        else {
            this.currentWaitingTime++;
            if (this.currentWaitingTime > this.chosenWaitingTime)
                this.weAreWaiting = false;
        }
    };
    // Private methods
    Smoke.prototype.init = function (weMustBeWaitingAtFirst) {
        if (weMustBeWaitingAtFirst === void 0) { weMustBeWaitingAtFirst = true; }
        // Inverted
        this.inverted = Random.flipACoin();
        // Step
        this.xGap = Random.upTo(this.width - 1);
        // At first we're not waiting
        if (Random.flipACoin() && weMustBeWaitingAtFirst == false) {
            // Y position
            this.yGap = -Random.upTo(this.height - 1);
            // Waiting stuff
            this.weAreWaiting = false;
        }
        else {
            // Y position
            this.yGap = 0;
            // Waiting stuff
            this.weAreWaiting = true;
            this.chosenWaitingTime = Random.between(this.minWaitingTime, this.maxWaitingTime); // We choose the waiting time
            this.currentWaitingTime = 0; // We begin at 0
        }
    };
    return Smoke;
})();
///<reference path="EqItem.ts"/>
var SorceressHat = (function (_super) {
    __extends(SorceressHat, _super);
    // Constructor
    function SorceressHat() {
        _super.call(this, "eqItemHatSorceressHat", "eqItemHatSorceressHatName", "eqItemHatSorceressHatDescription", "eqItems/hats/sorceressHat");
    }
    // Special ability
    SorceressHat.prototype.getSpecialAbility = function () {
        return "Enhances your spells & potions effects (sorceress hat).";
    };
    return SorceressHat;
})(EqItem);
///<reference path="Place.ts"/>
Saving.registerBool("sorceressHutTookLollipop", false);
Saving.registerBool("sorceressHutBoughtGrimoire", false);
Saving.registerBool("sorceressHutBoughtGrimoire2", false);
Saving.registerBool("sorceressHutBoughtCauldron", false);
Saving.registerBool("sorceressHutBoughtHat", false);
var SorceressHut = (function (_super) {
    __extends(SorceressHut, _super);
    // Constructor
    function SorceressHut(game) {
        _super.call(this, game);
        // The render area
        this.renderArea = new RenderArea();
        // Set the default speech
        this.currentSpeech = "sorceressHutHello";
        // Resize & update
        this.renderArea.resize(144, 48);
        this.update();
    }
    // getRenderArea()
    SorceressHut.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // Private methods
    SorceressHut.prototype.buyCauldron = function () {
        // If we have enough lollipops
        if (this.getGame().getLollipops().getCurrent() >= 100000) {
            this.getGame().getLollipops().add(-100000); // We spend the lollipops
            Saving.saveBool("statusBarUnlockedCauldron", true); // We unlock the cauldron
            Saving.saveBool("sorceressHutBoughtCauldron", true); // We now bought the cauldron
            this.getGame().updateStatusBar(true); // We update the status bar
            this.currentSpeech = "sorceressHutBuyCauldronSpeech"; // We set the speech
            // We update
            this.update();
            this.getGame().updatePlace();
        }
    };
    SorceressHut.prototype.buyGrimoire = function () {
        // If we have enough lollipops
        if (this.getGame().getLollipops().getCurrent() >= 5000) {
            this.getGame().getLollipops().add(-5000); // We spend the lollipops
            this.getGame().gainItem("gridItemPossessedBeginnersGrimoire"); // We gain the grimoire
            Saving.saveBool("sorceressHutBoughtGrimoire", true); // We now bought the grimoire
            this.currentSpeech = "sorceressHutBuyGrimoireSpeech"; // We set the speech
            // We update
            this.update();
            this.getGame().updatePlace();
        }
    };
    SorceressHut.prototype.buyGrimoire2 = function () {
        // If we have enough lollipops
        if (this.getGame().getLollipops().getCurrent() >= 20000) {
            this.getGame().getLollipops().add(-20000); // We spend the lollipops
            this.getGame().gainItem("gridItemPossessedAdvancedGrimoire"); // We gain the grimoire
            Saving.saveBool("sorceressHutBoughtGrimoire2", true); // We now bought the grimoire
            this.currentSpeech = "sorceressHutBuyGrimoire2Speech"; // We set the speech
            // We update
            this.update();
            this.getGame().updatePlace();
        }
    };
    SorceressHut.prototype.buyHat = function () {
        // If we have enough lollipops
        if (this.getGame().getLollipops().getCurrent() >= 1000000000) {
            this.getGame().getLollipops().add(-1000000000); // We spend the lollipops
            Saving.saveBool("sorceressHutBoughtHat", true); // We now bought the hat
            this.getGame().gainItem("eqItemHatSorceressHat"); // We have the hat!
            this.currentSpeech = "sorceressHutBuyHatSpeech"; // We set the speech
            // We update
            this.update();
            this.getGame().updatePlace();
        }
    };
    SorceressHut.prototype.clickedCauldron = function () {
        // Set the new speech
        this.currentSpeech = "sorceressHutClickedCauldron";
        // Update
        this.update();
        this.drawBuyingButton("sorceressHutBuyCauldronButton", new CallbackCollection(this.buyCauldron.bind(this)));
        this.getGame().updatePlace();
    };
    SorceressHut.prototype.clickedGrimoire = function () {
        // Set the new speech
        this.currentSpeech = "sorceressHutClickedGrimoire";
        // Update
        this.update();
        this.drawBuyingButton("sorceressHutBuyGrimoireButton", new CallbackCollection(this.buyGrimoire.bind(this)));
        this.getGame().updatePlace();
    };
    SorceressHut.prototype.clickedGrimoire2 = function () {
        // Set the new speech
        this.currentSpeech = "sorceressHutClickedGrimoire2";
        // Update
        this.update();
        this.drawBuyingButton("sorceressHutBuyGrimoire2Button", new CallbackCollection(this.buyGrimoire2.bind(this)));
        this.getGame().updatePlace();
    };
    SorceressHut.prototype.clickedHat = function () {
        // Set the new speech
        this.currentSpeech = "sorceressHutClickedHat";
        // Update
        this.update();
        this.drawBuyingButton("sorceressHutBuyHatButton", new CallbackCollection(this.buyHat.bind(this)));
        this.getGame().updatePlace();
    };
    SorceressHut.prototype.drawBackground = function (x, y) {
        this.renderArea.drawArray(Database.getAscii("places/sorceressHut/background"), x, y);
    };
    SorceressHut.prototype.drawBroom = function (x, y) {
        this.renderArea.drawArray(Database.getAscii("places/sorceressHut/broom"), x, y);
    };
    SorceressHut.prototype.drawBuyingButton = function (textName, callbackCollection) {
        this.renderArea.addAsciiRealButton(Database.getText(textName), 73, 22, "sorceressHutBuyingButton", Database.getTranslatedText(textName), true, -1, null, false);
        this.renderArea.addLinkCall(".sorceressHutBuyingButton", callbackCollection);
    };
    SorceressHut.prototype.drawCauldron = function (x, y) {
        // If we didn't buy the cauldron yet
        if (Saving.loadBool("sorceressHutBoughtCauldron") == false) {
            // Draw it
            this.renderArea.drawArray(Database.getAscii("places/sorceressHut/cauldron"), x, y, new RenderTransparency(" ", "%"));
            // Add the button
            this.renderArea.addMultipleAsciiButtons("sorceressHutBuyCauldronButton", x + 11, x + 30, y + 1, x + 10, x + 31, y + 2, x + 8, x + 33, y + 3, x + 7, x + 34, y + 4, x + 6, x + 35, y + 5, x + 5, x + 36, y + 6, x + 4, x + 37, y + 7, x + 4, x + 37, y + 8, x + 4, x + 37, y + 9, x + 5, x + 36, y + 10, x + 6, x + 35, y + 11, x + 8, x + 33, y + 12);
            // Add the link
            this.renderArea.addLinkCall(".sorceressHutBuyCauldronButton", new CallbackCollection(this.clickedCauldron.bind(this)));
        }
    };
    SorceressHut.prototype.drawCurrentSpeech = function (x, y) {
        this.renderArea.drawSpeech(Database.getText(this.currentSpeech), y, x, x + 27, "sorceressHutSpeech", Database.getTranslatedText(this.currentSpeech));
    };
    SorceressHut.prototype.drawHat = function (x, y) {
        // If we didn't buy the hat yet
        if (Saving.loadBool("sorceressHutBoughtHat") == false) {
            // Draw it
            this.renderArea.drawArray(Database.getAscii("places/sorceressHut/hat"), x, y, new RenderTransparency(" ", "%"));
            // Add the button
            this.renderArea.addMultipleAsciiButtons("sorceressHutBuyHatButton", x + 20, x + 23, y, x + 16, x + 25, y + 1, x + 14, x + 26, y + 2, x + 11, x + 19, y + 3, x + 10, x + 19, y + 4, x + 9, x + 20, y + 5, x + 1, x + 27, y + 6);
            // Add the link
            this.renderArea.addLinkCall(".sorceressHutBuyHatButton", new CallbackCollection(this.clickedHat.bind(this)));
        }
    };
    SorceressHut.prototype.drawShelves = function (x, y) {
        // Draw the ascii art
        this.renderArea.drawArray(Database.getAscii("places/sorceressHut/shelves"), x, y);
        // If we didn't take the lollipop yet
        if (Saving.loadBool("sorceressHutTookLollipop") == false) {
            // Draw the lollipop
            this.renderArea.drawArray(Database.getAscii("places/sorceressHut/lollipop"), x + 32, y + 16);
            // Add the button and the link
            this.renderArea.addAsciiButton(x + 32, x + 37, y + 16, "sorceressHutTakeLollipopButton");
            this.renderArea.addLinkCall(".sorceressHutTakeLollipopButton", new CallbackCollection(this.takeLollipop.bind(this)));
        }
        // If we didn't buy the grimoire yet
        if (Saving.loadBool("sorceressHutBoughtGrimoire") == false) {
            // Draw the grimoire
            this.renderArea.drawArray(Database.getAscii("places/sorceressHut/grimoire"), x + 18, y + 8);
            // Add the button and the link
            this.renderArea.addAsciiButton(x + 18, x + 20, y + 9, "sorceressHutBuyGrimoireButton");
            this.renderArea.addAsciiButton(x + 18, x + 20, y + 10, "sorceressHutBuyGrimoireButton");
            this.renderArea.addAsciiButton(x + 18, x + 20, y + 11, "sorceressHutBuyGrimoireButton");
            this.renderArea.addLinkCall(".sorceressHutBuyGrimoireButton", new CallbackCollection(this.clickedGrimoire.bind(this)));
        }
        // If we didn't buy the second grimoire yet
        if (Saving.loadBool("sorceressHutBoughtGrimoire2") == false) {
            // Draw the grimoire
            this.renderArea.drawArray(Database.getAscii("places/sorceressHut/grimoire2"), x + 30, y + 1);
            // Add the button and the link
            this.renderArea.addAsciiButton(x + 31, x + 34, y + 2, "sorceressHutBuyGrimoire2Button");
            this.renderArea.addAsciiButton(x + 31, x + 34, y + 3, "sorceressHutBuyGrimoire2Button");
            this.renderArea.addAsciiButton(x + 31, x + 34, y + 4, "sorceressHutBuyGrimoire2Button");
            this.renderArea.addAsciiButton(x + 31, x + 34, y + 5, "sorceressHutBuyGrimoire2Button");
            this.renderArea.addAsciiButton(x + 31, x + 34, y + 6, "sorceressHutBuyGrimoire2Button");
            this.renderArea.addLinkCall(".sorceressHutBuyGrimoire2Button", new CallbackCollection(this.clickedGrimoire2.bind(this)));
        }
    };
    SorceressHut.prototype.takeLollipop = function () {
        // We took the lollipop
        Saving.saveBool("sorceressHutTookLollipop", true);
        // Add 1 lollipop
        this.getGame().getLollipops().add(1);
        // Update
        this.update();
        this.getGame().updatePlace();
    };
    SorceressHut.prototype.update = function () {
        // Erase everything
        this.renderArea.resetAllButSize();
        // Back to the map button
        this.addBackToMainMapButton(this.renderArea, "theHoleBackToTheMapButton");
        // Draw everything
        this.drawBackground(0, 3);
        this.drawHat(14, 3);
        this.drawShelves(73, 3);
        this.drawCauldron(80, 27);
        this.drawBroom(49, 18);
        // Draw the speech
        this.drawCurrentSpeech(43, 4);
    };
    return SorceressHut;
})(Place);
///<reference path="QuestEntity.ts"/>
var Spikes = (function (_super) {
    __extends(Spikes, _super);
    // Constructor
    function Spikes(quest, globalPosition, width, damage, inverted) {
        if (damage === void 0) { damage = 200; }
        if (inverted === void 0) { inverted = false; }
        // Call the mother constructor
        _super.call(this, quest, globalPosition, new Naming("Some spikes", "some spikes"), new RenderArea(), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 0), new Pos(width, 1))));
        // Set the team (nature)
        this.setTeam(QuestEntityTeam.NATURE);
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("Its spikes", "its spikes"), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, (inverted ? 1 : -1)), new Pos(width, 1))), damage));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setFixedDelay(0);
        // Draw the ascii art
        this.getRenderArea().resize(width, 1);
        for (var i = 0; i < Math.floor(width / 2); i++) {
            if (inverted == false)
                this.getRenderArea().drawString("/\\", i * 2, 0);
            else
                this.getRenderArea().drawString("\\/", i * 2, 0);
        }
    }
    return Spikes;
})(QuestEntity);
///<reference path="QuestEntity.ts"/>
var Sponge = (function (_super) {
    __extends(Sponge, _super);
    // Constructor
    function Sponge(quest, leftDownCornerPosition) {
        // Create the real global position
        var globalPosition = leftDownCornerPosition;
        globalPosition.add(new Pos(0, -Database.getAsciiHeight("places/quests/theSea/sponge") + 1));
        // Call the mother constructor
        _super.call(this, quest, globalPosition, new Naming("A sponge", "a sponge"), new RenderArea(), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 0), new Pos(6, 3))));
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(40);
        this.setHp(40);
        // Set the team (nature)
        this.setTeam(QuestEntityTeam.NATURE);
        // Draw the ascii art
        this.getRenderArea().resizeFromArray(Database.getAscii("places/quests/theSea/sponge"));
        this.getRenderArea().drawArray(Database.getAscii("places/quests/theSea/sponge"));
    }
    // willDie()
    Sponge.prototype.willDie = function () {
        _super.prototype.willDie.call(this);
        this.getQuest().foundGridOrEqItem(new QuestItemFound(this.getQuest(), "gridItemPossessedSponge", "You found a sponge.", "You gain a sponge."));
    };
    return Sponge;
})(QuestEntity);
// Saving stuff related to the status bar itself
Saving.registerBool("statusBarUnlocked", false);
// Saving stuff related to unlocked tabs
Saving.registerBool("statusBarUnlockedCfg", false);
Saving.registerBool("statusBarUnlockedSave", false);
Saving.registerBool("statusBarUnlockedMap", false);
Saving.registerBool("statusBarUnlockedInventory", false);
Saving.registerBool("statusBarUnlockedLollipopFarm", false);
Saving.registerBool("statusBarUnlockedCauldron", false);
Saving.registerBool("statusBarUnlockedInsideYourBox", false);
Saving.registerBool("statusBarUnlockedTheComputer", false);
Saving.registerBool("statusBarUnlockedTheArena", false);
// Saving stuff for the unlocked health bar
Saving.registerBool("statusBarUnlockedHealthBar", false);
// The corner step
Saving.registerNumber("statusBarCornerStep", 0);
var StatusBar = (function () {
    // Constructor
    function StatusBar(game, selectedTabIndex) {
        // Render areas
        this.playerHealthBar = null;
        this.renderArea = new RenderArea(100, 6, " ");
        // Tabs
        this.tabs = [];
        // Se the game
        this.game = game;
        // Set the default selected tab index
        this.selectedTabIndex = selectedTabIndex;
        // Add everything for the first time
        this.deleteAndReAddEverything();
    }
    // Public methods
    StatusBar.prototype.deleteAndReAddEverything = function () {
        // Delete tabs
        this.tabs = [];
        // Reset special hotkeys
        this.game.resetSpecialHotkeys();
        // Delete the player health bar
        this.playerHealthBar = null;
        // Add the player health bar
        if (Saving.loadBool("statusBarUnlockedHealthBar")) {
            this.playerHealthBar = new Bar(BarType.HEALTH);
            this.playerHealthBar.resize(72, 1);
        }
        // Add tabs
        if (Saving.loadBool("statusBarUnlocked"))
            this.addTab(StatusBarTabType.CANDY_BOX, 0, " THE", "CANDY", " BOX", new CallbackCollection(this.game.goToCandyBox.bind(this.game)));
        if (Saving.loadBool("statusBarUnlockedInventory"))
            this.addTab(StatusBarTabType.INVENTORY, 8, "INV", " ENT", "ORY", new CallbackCollection(this.game.goToInventory.bind(this.game)));
        if (Saving.loadBool("statusBarUnlockedMap"))
            this.addTab(StatusBarTabType.MAP, 15, "", "MAP", "", new CallbackCollection(this.game.goToMap.bind(this.game)));
        if (Saving.loadBool("statusBarUnlockedLollipopFarm"))
            this.addTab(StatusBarTabType.FARM, 21, "LOLL", "IPOP", "FARM", new CallbackCollection(this.game.goToLollipopFarm.bind(this.game)));
        if (Saving.loadBool("statusBarUnlockedCauldron"))
            this.addTab(StatusBarTabType.CAULDRON, 28, "", "CLDR", "", new CallbackCollection(this.game.goToCauldron.bind(this.game)));
        if (Saving.loadBool("statusBarUnlockedInsideYourBox"))
            this.addTab(StatusBarTabType.INSIDE_YOUR_BOX, 35, "INSIDE", " YOUR", " BOX!", new CallbackCollection(this.game.goToInsideYourBox.bind(this.game)));
        if (Saving.loadBool("statusBarUnlockedTheComputer"))
            this.addTab(StatusBarTabType.THE_COMPUTER, 44, " THE", " COM", "PUTER", new CallbackCollection(this.game.goToTheComputer.bind(this.game)));
        if (Saving.loadBool("statusBarUnlockedTheArena"))
            this.addTab(StatusBarTabType.THE_ARENA, 52, " THE", "ARENA", " /!\\", new CallbackCollection(this.game.goToTheArena.bind(this.game)));
        if (Saving.loadBool("statusBarUnlockedSave"))
            this.addTab(StatusBarTabType.SAVE, 60, "", "SAVE", "", new CallbackCollection(this.game.goToSave.bind(this.game)));
        if (Saving.loadBool("statusBarUnlockedCfg"))
            this.addTab(StatusBarTabType.CFG, 67, "C", "F", "G", new CallbackCollection(this.game.goToCfg.bind(this.game)));
        // Add special hotkeys to go to the next or previous tab
        if (Saving.loadBool("statusBarUnlocked")) {
            this.game.addSpecialHotkey(new Hotkey("n", new CallbackCollection(this.nextTab.bind(this))));
        }
    };
    StatusBar.prototype.selectTab = function (index) {
        this.selectedTabIndex = index;
        this.game.updateStatusBar();
    };
    StatusBar.prototype.selectTabByType = function (type) {
        for (var i = 0; i < this.tabs.length; i++) {
            // If this is the tab we're searching for
            if (this.tabs[i].getType() == type) {
                // We select it and we break
                this.selectedTabIndex = i;
                this.game.updateStatusBar();
            }
        }
    };
    StatusBar.prototype.updateAll = function () {
        // We erase
        this.renderArea.resetAllButSize();
        // We draw the borders
        if (Saving.loadBool("statusBarUnlocked")) {
            this.renderArea.drawString("+", 0, 0);
            this.renderArea.drawString("+", this.renderArea.getWidth() - 1, 0);
            this.renderArea.drawString("+", 0, 5);
            this.renderArea.drawString("+", this.renderArea.getWidth() - 1, 5);
            this.renderArea.drawVerticalLine("|", 0, 1, 4);
            this.renderArea.drawVerticalLine("|", this.renderArea.getWidth() - 1, 1, 4);
            this.renderArea.drawHorizontalLine("-", 1, this.renderArea.getWidth() - 1, 0);
            this.renderArea.drawHorizontalLine("-", 1, this.renderArea.getWidth() - 1, 5);
        }
        // We draw the candies we have
        this.renderArea.drawString(this.game.getCandies().getCurrentAsString(26), 2, 1);
        // We draw the lollipops we have, if we had at least one at some point
        if (this.game.getLollipops().getMax() > 0)
            this.renderArea.drawString(this.game.getLollipops().getCurrentAsString(26), 2, 2);
        // We draw the chocolate bars we have, if we had at least one at some point
        if (this.game.getChocolateBars().getMax() > 0)
            this.renderArea.drawString(this.game.getChocolateBars().getCurrentAsString(26), 2, 3);
        // We draw the pains au chocolat we have, if we had at least one at some point
        if (this.game.getPainsAuChocolat().getMax() > 0)
            this.renderArea.drawString(this.game.getPainsAuChocolat().getCurrentAsString(26), 2, 4);
        // We draw tabs
        this.drawTabs();
        // We draw the health bar
        this.updateHealthBar();
        // We draw the stuff about the status bar's corners
        this.drawStatusBarCornersStuff();
    };
    StatusBar.prototype.updateHealthBar = function () {
        // We update the health bar if it isn't null
        if (this.playerHealthBar != null) {
            // We update the bar from the player's health
            this.playerHealthBar.update(this.game.getPlayer().getHp() / this.game.getPlayer().getMaxHp(), "Your health : " + this.game.getPlayer().getHp() + "/" + this.game.getPlayer().getMaxHp());
            // We draw the bar
            this.renderArea.drawArea(this.playerHealthBar, 28, 4);
        }
    };
    // Public getters
    StatusBar.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // Private methods
    StatusBar.prototype.addTab = function (type, xPos, text1, text2, text3, callbackCollection) {
        // We add the tab
        this.tabs.push(new StatusBarTab(this, type, xPos, text1, text2, text3, this.tabs.length, callbackCollection));
    };
    StatusBar.prototype.clickedOnCorner = function () {
        this.setNextCornerStep();
        this.game.updateStatusBar();
    };
    StatusBar.prototype.drawAllCorners = function (character) {
        this.drawUpLeftCorner(character);
        this.drawUpRightCorner(character);
        this.drawDownLeftCorner(character);
        this.drawDownRightCorner(character);
    };
    StatusBar.prototype.drawDownLeftCorner = function (character) {
        this.renderArea.drawString(character, 0, 5);
    };
    StatusBar.prototype.drawDownRightCorner = function (character) {
        this.renderArea.drawString(character, 99, 5);
    };
    StatusBar.prototype.drawStatusBarCornersStuff = function () {
        // We add buttons
        this.renderArea.addAsciiNinjaButton(0, 1, 0, "statusBarCornerButton");
        this.renderArea.addAsciiNinjaButton(99, 100, 0, "statusBarCornerButton");
        this.renderArea.addAsciiNinjaButton(0, 1, 5, "statusBarCornerButton");
        this.renderArea.addAsciiNinjaButton(99, 100, 5, "statusBarCornerButton");
        // We add the link
        this.renderArea.addLinkCall(".statusBarCornerButton", new CallbackCollection(this.clickedOnCorner.bind(this)));
        // We possibly draw a different corner, depending on the corner step
        switch (Saving.loadNumber("statusBarCornerStep")) {
            case 0: break; // Default corner, we do nothing
            case 1:
                this.drawAllCorners("*");
                break;
            case 2:
                this.drawAllCorners("#");
                break;
            case 3:
                this.drawAllCorners("-");
                break;
            case 4:
                this.drawUpLeftCorner("A");
                this.drawUpRightCorner("B");
                this.drawDownRightCorner("C");
                this.drawDownLeftCorner("D");
                break;
            case 5:
                this.drawUpLeftCorner("0");
                this.drawUpRightCorner("1");
                this.drawDownRightCorner("2");
                this.drawDownLeftCorner("3");
                break;
            case 6:
                this.drawAllCorners("@");
                break;
        }
    };
    StatusBar.prototype.drawTabs = function () {
        if (Saving.loadBool("statusBarUnlocked")) {
            this.renderArea.drawVerticalLine("|", 28, 1, 4);
            for (var i = 0; i < this.tabs.length; i++) {
                this.tabs[i].render(this.renderArea, 29, 1, (this.selectedTabIndex == i ? true : false));
            }
        }
    };
    StatusBar.prototype.drawUpLeftCorner = function (character) {
        this.renderArea.drawString(character, 0, 0);
    };
    StatusBar.prototype.drawUpRightCorner = function (character) {
        this.renderArea.drawString(character, 99, 0);
    };
    StatusBar.prototype.previousTab = function () {
        if (this.selectedTabIndex - 1 >= 0)
            this.tabs[this.selectedTabIndex - 1].clicked();
    };
    StatusBar.prototype.nextTab = function () {
        // If we're allowed to.. (this will be disable when using the computer)
        if (this.game.getIsStatusBarAllowedToUseTheNKey()) {
            if (this.selectedTabIndex + 1 < this.tabs.length)
                this.tabs[this.selectedTabIndex + 1].clicked();
            else
                this.tabs[0].clicked();
        }
    };
    StatusBar.prototype.setNextCornerStep = function () {
        var nextCornerStep = Saving.loadNumber("statusBarCornerStep");
        nextCornerStep += 1;
        if (nextCornerStep > 6)
            nextCornerStep = 0;
        Saving.saveNumber("statusBarCornerStep", nextCornerStep);
    };
    return StatusBar;
})();
var StatusBarTab = (function () {
    // Constructor
    function StatusBarTab(statusBar, type, xPos, text1, text2, text3, tabIndexWhenSelected, callbackCollectionWhenSelected) {
        if (tabIndexWhenSelected === void 0) { tabIndexWhenSelected = -1; }
        if (callbackCollectionWhenSelected === void 0) { callbackCollectionWhenSelected = new CallbackCollection(); }
        // Set the status bar
        this.statusBar = statusBar;
        // Set teh type
        this.type = type;
        // Set xPos
        this.xPos = xPos;
        // Add the three strings to our 3 strings array
        this.setText(text1, text2, text3);
        // Set the rest
        this.tabIndexWhenSelected = tabIndexWhenSelected;
        this.callbackCollectionWhenSelected = callbackCollectionWhenSelected;
    }
    // Public methods
    StatusBarTab.prototype.clicked = function () {
        this.callbackCollectionWhenSelected.fire();
        this.statusBar.selectTab(this.tabIndexWhenSelected);
    };
    StatusBarTab.prototype.render = function (renderArea, x, y, selected) {
        // We draw the borders
        renderArea.drawVerticalLine("|", x + this.xPos - 1, y, 3);
        renderArea.drawVerticalLine("|", x + this.xPos + this.width, y, 3);
        // We draw the text
        for (var i = 0; i < 3; i++) {
            // We draw the string
            renderArea.drawString(this.text[i], x + this.xPos + 1, y + i);
            // If the tab is selected, we add a special color
            if (selected)
                renderArea.addBackgroundColor(x + this.xPos, x + this.xPos + this.width, y + i, new Color(ColorType.STATUS_BAR_SELECTED_TAB, true));
        }
        // If the tab isn't selected, we add a button to click it !
        if (selected == false) {
            renderArea.addMultipleAsciiButtons("statusBarTabButton" + this.tabIndexWhenSelected, x + this.xPos, x + this.xPos + this.width, y, x + this.xPos, x + this.xPos + this.width, y + 1, x + this.xPos, x + this.xPos + this.width, y + 2);
            renderArea.addLinkCall(".statusBarTabButton" + this.tabIndexWhenSelected, new CallbackCollection(this.clicked.bind(this)));
        }
    };
    // Public getters
    StatusBarTab.prototype.getType = function () {
        return this.type;
    };
    StatusBarTab.prototype.getWidth = function () {
        return this.width;
    };
    // Private methods
    StatusBarTab.prototype.calculateWidth = function () {
        this.width = 0;
        for (var i = 0; i < 3; i++) {
            if (this.text[i].length > this.width)
                this.width = this.text[i].length;
        }
        // We add two ! (because a tab has two spaces on left and right
        this.width += 2;
    };
    StatusBarTab.prototype.setText = function (text1, text2, text3) {
        // We empty the text array
        this.text = [];
        // We add the three strings given in parameters
        this.text.push(text1);
        this.text.push(text2);
        this.text.push(text3);
        // We re-calculate the tab's width
        this.calculateWidth();
    };
    return StatusBarTab;
})();
var StatusBarTabType;
(function (StatusBarTabType) {
    StatusBarTabType[StatusBarTabType["CANDY_BOX"] = 0] = "CANDY_BOX";
    StatusBarTabType[StatusBarTabType["INVENTORY"] = 1] = "INVENTORY";
    StatusBarTabType[StatusBarTabType["MAP"] = 2] = "MAP";
    StatusBarTabType[StatusBarTabType["FARM"] = 3] = "FARM";
    StatusBarTabType[StatusBarTabType["CAULDRON"] = 4] = "CAULDRON";
    StatusBarTabType[StatusBarTabType["INSIDE_YOUR_BOX"] = 5] = "INSIDE_YOUR_BOX";
    StatusBarTabType[StatusBarTabType["THE_COMPUTER"] = 6] = "THE_COMPUTER";
    StatusBarTabType[StatusBarTabType["THE_ARENA"] = 7] = "THE_ARENA";
    StatusBarTabType[StatusBarTabType["SAVE"] = 8] = "SAVE";
    StatusBarTabType[StatusBarTabType["CFG"] = 9] = "CFG";
})(StatusBarTabType || (StatusBarTabType = {}));
///<reference path="EqItem.ts"/>
var SummoningTribalSpear = (function (_super) {
    __extends(SummoningTribalSpear, _super);
    // Constructor
    function SummoningTribalSpear() {
        _super.call(this, "eqItemWeaponSummoningTribalSpear", "eqItemWeaponSummoningTribalSpearName", "eqItemWeaponSummoningTribalSpearDescription", "eqItems/weapons/summoningTribalSpear");
        // Time since we last summoned a warrior
        this.timeSinceSummon = 0;
    }
    // Public getters
    SummoningTribalSpear.prototype.getQuestEntityWeapon = function (quest, player) {
        var qew = new QuestEntityWeapon(quest, player, new Naming("A summoning tribal spear", "a summoning tribal spear"), player.getClassicCollisionBoxCollection(), 10);
        qew.getCloseCombatDelay().setFixedDelay(2);
        return qew;
    };
    // Special ability
    SummoningTribalSpear.prototype.getSpecialAbility = function () {
        return "Frequently summons tribe warriors fighting on your side (summoning tribal spear).";
    };
    // update()
    SummoningTribalSpear.prototype.update = function (player, quest) {
        this.timeSinceSummon += 1;
        if (this.timeSinceSummon > 35) {
            this.summon(player, quest);
        }
    };
    // Private methods
    SummoningTribalSpear.prototype.summon = function (player, quest) {
        // Create the warrior
        var warrior = new PlayerSummonedTribeWarrior(quest, player.getSpellCastingPosition().plus(new Pos(1, -3)));
        // Add the health bar
        warrior.setHealthBar(new QuestEntityHealthBar(warrior, new Pos(4, 1)));
        // Add it to the quest
        quest.addEntity(warrior);
        // Reset the summon time
        this.timeSinceSummon = 0;
    };
    return SummoningTribalSpear;
})(EqItem);
///<reference path="ThirdHouseGame.ts"/>
Saving.registerBool("SuperRPGReward1", false);
Saving.registerBool("SuperRPGReward2", false);
Saving.registerBool("SuperRPGReward3", false);
Saving.registerBool("SuperRPGReward4", false);
Saving.registerBool("SuperRPGUnlockedHardmode", false);
var SuperRPG = (function (_super) {
    __extends(SuperRPG, _super);
    function SuperRPG() {
        _super.apply(this, arguments);
        // The global step of the game (splash screen, the menu, or the game itself
        this.step = SuperRPGStep.SPLASH_SCREEN;
        // The timer used for the splash screen
        this.splashScreenTimer = 39;
        // The current menu
        this.menu = null;
        // Should we exit the game?
        this.shouldExitGame = false;
    }
    // Public methods
    SuperRPG.prototype.exitGame = function () {
        this.shouldExitGame = true;
    };
    SuperRPG.prototype.nextFloorStep = function () {
        switch (this.floorStep) {
            case SuperRPGFloorStep.SHOP:
                this.floorStep = SuperRPGFloorStep.MONSTER1;
                this.goToMonster();
                break;
            case SuperRPGFloorStep.MONSTER1:
                this.floorStep = SuperRPGFloorStep.MONSTER2;
                this.goToMonster();
                break;
            case SuperRPGFloorStep.MONSTER2:
                this.floorStep = SuperRPGFloorStep.MONSTER3;
                this.goToMonster();
                break;
            case SuperRPGFloorStep.MONSTER3:
                this.floorStep = SuperRPGFloorStep.SHOP;
                this.floor += 1;
                this.goToShop();
                break;
        }
    };
    SuperRPG.prototype.startGame = function (hardmode) {
        // Set the hardmode (from parameter)
        this.hardmode = hardmode;
        // Set various stuff
        this.floor = 0;
        this.floorStep = SuperRPGFloorStep.SHOP;
        this.coins = 15;
        this.hp = 10;
        this.maxHp = 10;
        this.weapon = "Your fists";
        this.damage = 1;
        this.defenseItem = "Nothing";
        this.defense = 0;
        // Load the shop
        this.goToShop();
    };
    SuperRPG.prototype.run = function () {
        // To store the return value
        var returnValue = false;
        // If we should exit the game, we do so now
        if (this.shouldExitGame)
            return true;
        // Reset the area
        this.getRenderArea().resetAllButSize();
        // Do something different depending on the step
        switch (this.step) {
            case SuperRPGStep.SPLASH_SCREEN:
                this.drawSplashScreen();
                returnValue = this.runSplashScreen();
                break;
            case SuperRPGStep.GAME:
                this.drawGame();
                returnValue = this.runGame();
                break;
            case SuperRPGStep.LOSE:
                this.drawLose();
                returnValue = false;
                break;
        }
        // We return
        return returnValue;
    };
    // Public getters
    SuperRPG.prototype.getCoins = function () {
        return this.coins;
    };
    SuperRPG.prototype.getDamage = function () {
        return this.damage;
    };
    SuperRPG.prototype.getDefense = function () {
        return this.defense;
    };
    SuperRPG.prototype.getDefenseItem = function () {
        return this.defenseItem;
    };
    SuperRPG.prototype.getFloor = function () {
        return this.floor;
    };
    SuperRPG.prototype.getFloorStep = function () {
        return this.floorStep;
    };
    SuperRPG.prototype.getHardmode = function () {
        return this.hardmode;
    };
    SuperRPG.prototype.getHp = function () {
        return this.hp;
    };
    SuperRPG.prototype.getMaxHp = function () {
        return this.maxHp;
    };
    SuperRPG.prototype.getWeapon = function () {
        return this.weapon;
    };
    // Public setters
    SuperRPG.prototype.setCoins = function (coins) {
        this.coins = coins;
    };
    SuperRPG.prototype.setDamage = function (damage) {
        this.damage = damage;
    };
    SuperRPG.prototype.setDefense = function (defense) {
        this.defense = defense;
    };
    SuperRPG.prototype.setDefenseItem = function (defenseItem) {
        this.defenseItem = defenseItem;
    };
    SuperRPG.prototype.setHp = function (hp) {
        this.hp = hp;
        // If we have more hp than the maximum, we correct that
        if (this.hp > this.maxHp)
            this.hp = this.maxHp;
        // If we have 0 or less hp, we lose!!
        if (this.hp <= 0)
            this.goToLose();
    };
    SuperRPG.prototype.setMaxHp = function (maxHp) {
        this.maxHp = maxHp;
    };
    SuperRPG.prototype.setWeapon = function (weapon) {
        this.weapon = weapon;
    };
    // Private methods
    SuperRPG.prototype.drawGame = function () {
        this.menu.draw(this.getRenderArea());
    };
    SuperRPG.prototype.drawLose = function () {
        this.getRenderArea().drawArray(Database.getAscii("places/village/thirdHouseGames/SuperRPG/youLose"), 8, 1);
        if (this.reward == 0)
            this.getRenderArea().drawString("At floor " + this.floor + ". And got no candies.", 8, 7);
        else
            this.getRenderArea().drawString("At floor " + this.floor + ". And got " + this.reward + " candies.", 8, 7);
    };
    SuperRPG.prototype.drawSplashScreen = function () {
        this.getRenderArea().drawArray(Database.getAscii("places/village/thirdHouseGames/SuperRPG/splashScreen"), -67 + this.splashScreenTimer * 3, 2);
    };
    SuperRPG.prototype.getCandiesWeWillGain = function () {
        // The reward
        var reward = 0;
        // Test the first reward
        if (Saving.loadBool("SuperRPGReward1") == false && this.floor > 5) {
            reward += 100;
            Saving.saveBool("SuperRPGReward1", true);
        }
        // Test the second reward
        if (Saving.loadBool("SuperRPGReward2") == false && this.floor > 10) {
            reward += 1000;
            Saving.saveBool("SuperRPGReward2", true);
        }
        // Test the third reward
        if (Saving.loadBool("SuperRPGReward3") == false && this.floor > 15) {
            reward += 10000;
            Saving.saveBool("SuperRPGReward3", true);
        }
        // Test the fourth reward
        if (Saving.loadBool("SuperRPGReward4") == false && this.floor > 20) {
            reward += 30000;
            Saving.saveBool("SuperRPGReward4", true);
            Saving.saveBool("SuperRPGUnlockedHardmode", true);
        }
        // We return the reward
        return reward;
    };
    SuperRPG.prototype.goToLose = function () {
        // No more menu
        this.menu = null;
        // Change the step
        this.step = SuperRPGStep.LOSE;
        // Get the candies
        this.reward = this.getCandiesWeWillGain();
        this.getThirdHouse().getGame().getCandies().add(this.reward);
    };
    SuperRPG.prototype.goToMainMenu = function () {
        // Change the step
        this.step = SuperRPGStep.GAME;
        // Set the main menu
        this.menu = new SuperRPGMenu_Main(this);
    };
    SuperRPG.prototype.goToMonster = function () {
        // Create the new menu
        var menu = new SuperRPGMenu_Monster(this);
        // Add the entry used to quit the shop
        menu.addUsualEntries();
        // Set the monster / add entries, depending on the floor
        switch (this.floor) {
            case 0:
                if (Random.oneChanceOutOf(100))
                    menu.setChest(20);
                else
                    menu.setBlob();
                break;
            case 1:
                if (Random.oneChanceOutOf(100))
                    menu.setChest(30);
                else if (Random.flipACoin())
                    menu.setBlob();
                else
                    menu.setFerociousBlob();
                break;
            case 2:
                if (Random.oneChanceOutOf(100))
                    menu.setChest(40);
                else if (Random.flipACoin()) {
                    if (Random.oneChanceOutOf(5))
                        menu.setBlob();
                    else
                        menu.setFerociousBlob();
                }
                else
                    menu.setGoblin();
                break;
            case 3:
                if (Random.oneChanceOutOf(100))
                    menu.setChest(50);
                else if (this.floorStep == SuperRPGFloorStep.MONSTER3)
                    menu.setGoblin();
                else
                    menu.setFerociousGoblin();
                break;
            case 4:
                if (Random.oneChanceOutOf(100))
                    menu.setChest(60);
                else if (Random.oneChanceOutOf(3))
                    menu.setFerociousGoblin();
                else
                    menu.setSkeletonOrBillGatesSkeleton();
                break;
            case 5:
                if (Random.oneChanceOutOf(100))
                    menu.setChest(70);
                else if (Random.oneChanceOutOf(3))
                    menu.setSkeletonOrBillGatesSkeleton();
                else
                    menu.setFerociousSkeleton();
                break;
            case 6:
                if (Random.oneChanceOutOf(100))
                    menu.setChest(80);
                else
                    menu.setFerociousSkeleton();
                break;
            case 7:
                // Big spider
                if (this.floorStep == SuperRPGFloorStep.MONSTER3)
                    menu.setSpider();
                else
                    menu.setSpiders();
                break;
            case 8:
                if (Random.oneChanceOutOf(100))
                    menu.setChest(100);
                else
                    menu.setBabyVampire();
                break;
            case 9:
                if (Random.oneChanceOutOf(100))
                    menu.setChest(110);
                else {
                    if (this.floorStep == SuperRPGFloorStep.MONSTER2)
                        menu.setSpiders();
                    else
                        menu.setSpider();
                }
                break;
            case 10:
                if (Random.oneChanceOutOf(100))
                    menu.setChest(120);
                else
                    menu.setThing();
                break;
            case 11:
                if (Random.oneChanceOutOf(100))
                    menu.setChest(130);
                else
                    menu.setSpider();
                break;
            case 12:
                if (Random.flipACoin())
                    menu.setChest(140);
                else
                    menu.setBomb();
                break;
            case 13:
                switch (this.floorStep) {
                    case SuperRPGFloorStep.MONSTER1:
                        menu.setCorpse1();
                        break;
                    case SuperRPGFloorStep.MONSTER2:
                        menu.setCorpse2();
                        break;
                    case SuperRPGFloorStep.MONSTER3:
                        menu.setDragon();
                        break;
                }
                break;
            default:
                menu.setAbstract(10 + (this.floor - 14) * 12, 0, Math.ceil(500 * (1 / (this.floor - 13))), 30 + (this.floor - 13) * 3);
                break;
        }
        // Set the menu
        this.menu = menu;
    };
    SuperRPG.prototype.goToShop = function () {
        // Create the new menu
        var menu = new SuperRPGMenu_Shop(this);
        // Add different items depending on the floor
        switch (this.floor) {
            case 0:
                menu.addBuyingWeapon("Wooden sword", 2, 10);
                menu.addBuyingDefenseItem("Wooden shield", 1, 10);
                break;
            case 1:
                menu.addBuyingWeapon("Copper sword", 3, 15);
                menu.addBuyingDefenseItem("Copper shield", 2, 15);
                menu.addBuyingHealthPotion();
                break;
            case 2:
                menu.addBuyingWeapon("Iron sword", 4, 20);
                menu.addBuyingDefenseItem("Iron shield", 3, 20);
                menu.addBuyingHealthPotion();
                break;
            case 3:
                menu.addBuyingWeapon("Silver sword", 5, 30);
                menu.addBuyingDefenseItem("Silver shield", 4, 30);
                menu.addBuyingHealthPotion();
                menu.addBuyingHealthPendant();
                break;
            case 4:
                menu.addBuyingWeapon("Gold sword", 6, 40);
                menu.addBuyingDefenseItem("Gold shield", 5, 40);
                menu.addBuyingHealthPotion();
                menu.addBuyingHealthPendant();
                break;
            case 5:
                menu.addBuyingWeapon("Diamond sword", 7, 50);
                menu.addBuyingDefenseItem("Diamond shield", 6, 50);
                menu.addBuyingHealthPotion();
                menu.addBuyingHealthPendant();
                break;
            case 6:
                menu.addBuyingWeapon("Falchion", 8, 100);
                menu.addBuyingDefenseItem("Diamond shield", 6, 50);
                menu.addBuyingHealthPotion();
                menu.addBuyingHealthPendant();
                break;
            case 7:
                menu.addBuyingWeapon("Falchion", 8, 100);
                menu.addBuyingDefenseItem("Shield of El Cid", 8, 100);
                menu.addBuyingHealthPotion();
                menu.addBuyingHealthPendant();
                break;
            case 8:
                menu.addBuyingWeapon("Dagger of Time", 10, 180);
                menu.addBuyingDefenseItem("Shield of El Cid", 8, 100);
                menu.addBuyingHealthPotion();
                menu.addBuyingHealthPendant();
                break;
            case 9:
                menu.addBuyingWeapon("Dagger of Time", 10, 180);
                menu.addBuyingDefenseItem("Shield of Achilles", 10, 180);
                menu.addBuyingHealthPotion();
                menu.addBuyingHealthPendant();
                break;
            case 10:
                menu.addBuyingWeapon("Vorpal sword", 12, 250);
                menu.addBuyingDefenseItem("Shield of Achilles", 10, 180);
                menu.addBuyingHealthPotion();
                menu.addBuyingHealthPendant();
                break;
            case 11:
                menu.addBuyingWeapon("Vorpal sword", 12, 250);
                menu.addBuyingDefenseItem("Wynebgwrthucher", 12, 250);
                menu.addBuyingHealthPotion();
                menu.addBuyingHealthPendant();
                break;
            case 12:
                menu.addBuyingWeapon("Morgul-blade", 14, 400);
                menu.addBuyingDefenseItem("Wynebgwrthucher", 12, 250);
                menu.addBuyingHealthPotion();
                menu.addBuyingHealthPendant();
                break;
            case 13:
                menu.addBuyingWeapon("Morgul-blade", 14, 400);
                menu.addBuyingDefenseItem("Ancile", 14, 400);
                menu.addBuyingHealthPotion();
                menu.addBuyingHealthPendant();
                break;
            case 14:
                menu.addBuyingWeapon("Excalibur", 16, 600);
                menu.addBuyingDefenseItem("Ancile", 14, 400);
                menu.addBuyingSuperHealthPotion();
                menu.addBuyingHealthCrystal();
                break;
            case 15:
                menu.addBuyingWeapon("Excalibur", 16, 600);
                menu.addBuyingDefenseItem("Aegis", 16, 600);
                menu.addBuyingSuperHealthPotion();
                menu.addBuyingHealthCrystal();
                break;
            case 16:
                menu.addBuyingWeapon("Tonbogiri", 18, 1000);
                menu.addBuyingDefenseItem("Aegis", 16, 600);
                menu.addBuyingSuperHealthPotion();
                menu.addBuyingHealthCrystal();
                break;
            case 17:
            case 18:
            case 19:
                menu.addBuyingWeapon("Gungnir", 20, 1500);
                menu.addBuyingDefenseItem("Aegis", 16, 600);
                menu.addBuyingSuperHealthPotion();
                menu.addBuyingHealthCrystal();
                break;
            default:
                menu.addBuyingWeapon("Mjolnir", 30, 2000);
                menu.addBuyingDefenseItem("Aegis", 16, 600);
                menu.addBuyingSuperHealthPotion();
                menu.addBuyingHealthCrystal();
                break;
        }
        // Add the entry used to quit the shop
        menu.addQuitTheShop();
        // Set the menu
        this.menu = menu;
    };
    SuperRPG.prototype.pressedDownButton = function () {
        if (this.menu != null)
            this.menu.pressedDownButton();
    };
    SuperRPG.prototype.pressedSpaceButton = function () {
        if (this.step == SuperRPGStep.LOSE) {
            this.shouldExitGame = true;
        }
        if (this.menu != null)
            this.menu.pressedSpaceButton();
    };
    SuperRPG.prototype.pressedUpButton = function () {
        if (this.menu != null)
            this.menu.pressedUpButton();
    };
    SuperRPG.prototype.runGame = function () {
        return false;
    };
    SuperRPG.prototype.runSplashScreen = function () {
        // If the timer is >= 0
        if (this.splashScreenTimer >= 0) {
            // Reduce the timer
            this.splashScreenTimer -= 1;
        }
        else {
            // Switch to the next step
            this.goToMainMenu();
        }
        // We can't end the game during the splash screen
        return false;
    };
    return SuperRPG;
})(ThirdHouseGame);
var SuperRPGFloorStep;
(function (SuperRPGFloorStep) {
    SuperRPGFloorStep[SuperRPGFloorStep["SHOP"] = 0] = "SHOP";
    SuperRPGFloorStep[SuperRPGFloorStep["MONSTER1"] = 1] = "MONSTER1";
    SuperRPGFloorStep[SuperRPGFloorStep["MONSTER2"] = 2] = "MONSTER2";
    SuperRPGFloorStep[SuperRPGFloorStep["MONSTER3"] = 3] = "MONSTER3";
})(SuperRPGFloorStep || (SuperRPGFloorStep = {}));
var SuperRPGMenu = (function () {
    // Constructor
    function SuperRPGMenu(superRPG, asciiName, currentlySelectedEntryIndex) {
        // Menu entries
        this.entries = [];
        // Set from parameters
        this.superRPG = superRPG;
        this.asciiName = asciiName;
        this.currentlySelectedEntryIndex = currentlySelectedEntryIndex;
    }
    // Public methods
    SuperRPGMenu.prototype.addEntry = function (entry) {
        this.entries.push(entry);
    };
    SuperRPGMenu.prototype.draw = function (renderArea) {
        // Draw the separating line
        renderArea.drawVerticalLine("|", 26, 3, 11);
        // Draw the ascii art on the left
        renderArea.drawArray(Database.getAscii(this.asciiName), 0 + Math.floor((26 - Database.getAsciiWidth(this.asciiName)) / 2), 2 + Math.floor((10 - Database.getAsciiHeight(this.asciiName)) / 2));
        // Draw the entries
        for (var i = 0; i < this.entries.length; i++) {
            this.entries[i].draw(renderArea, 27, 3 + Math.floor((10 - (this.entries.length * 2)) / 2) + i * 2, (this.currentlySelectedEntryIndex == i), 26);
        }
    };
    SuperRPGMenu.prototype.pressedDownButton = function () {
        this.currentlySelectedEntryIndex += 1;
        if (this.currentlySelectedEntryIndex >= this.entries.length)
            this.currentlySelectedEntryIndex = this.entries.length - 1;
    };
    SuperRPGMenu.prototype.pressedSpaceButton = function () {
        this.entries[this.currentlySelectedEntryIndex].getCallbackCollection().fire();
    };
    SuperRPGMenu.prototype.pressedUpButton = function () {
        this.currentlySelectedEntryIndex -= 1;
        if (this.currentlySelectedEntryIndex < 0)
            this.currentlySelectedEntryIndex = 0;
    };
    // Public getters
    SuperRPGMenu.prototype.getSuperRPG = function () {
        return this.superRPG;
    };
    // Public setters
    SuperRPGMenu.prototype.setAsciiName = function (asciiName) {
        this.asciiName = asciiName;
    };
    SuperRPGMenu.prototype.setEntries = function () {
        var entries = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            entries[_i - 0] = arguments[_i];
        }
        this.entries = entries;
    };
    return SuperRPGMenu;
})();
var SuperRPGMenuEntry = (function () {
    // Constructor
    function SuperRPGMenuEntry(text, callbackCollection) {
        this.text = text;
        this.callbackCollection = callbackCollection;
    }
    // Public methods
    SuperRPGMenuEntry.prototype.draw = function (renderArea, x, y, selected, width) {
        // Create a var which will contain the text to draw
        var textToDraw;
        // Set the text to draw
        if (selected)
            textToDraw = "> " + this.text + " <";
        else
            textToDraw = this.text;
        // Draw the text to draw
        renderArea.drawString(textToDraw, x + Math.floor((width - textToDraw.length) / 2), y);
    };
    // Public getters
    SuperRPGMenuEntry.prototype.getCallbackCollection = function () {
        return this.callbackCollection;
    };
    return SuperRPGMenuEntry;
})();
///<reference path="SuperRPGMenu.ts"/>
var SuperRPGMenu_Ingame = (function (_super) {
    __extends(SuperRPGMenu_Ingame, _super);
    function SuperRPGMenu_Ingame() {
        _super.apply(this, arguments);
    }
    // Public methods
    SuperRPGMenu_Ingame.prototype.draw = function (renderArea) {
        // First status bar line
        // Floor
        renderArea.drawString("Floor " + this.getSuperRPG().getFloor(), 0, 0);
        // Separation bar
        renderArea.drawString("|", 10, 0);
        // Shop / 1st monster / etc
        switch (this.getSuperRPG().getFloorStep()) {
            case SuperRPGFloorStep.SHOP:
                renderArea.drawString("shop", 15, 0);
                break;
            case SuperRPGFloorStep.MONSTER1:
                renderArea.drawString("1st monster", 12, 0);
                break;
            case SuperRPGFloorStep.MONSTER2:
                renderArea.drawString("2nd monster", 12, 0);
                break;
            case SuperRPGFloorStep.MONSTER3:
                renderArea.drawString("3rd monster", 12, 0);
                break;
        }
        // Separation bar
        renderArea.drawString("|", 24, 0);
        // Hp and max hp
        renderArea.drawString("HP " + this.getSuperRPG().getHp().toString() + "/" + this.getSuperRPG().getMaxHp().toString(), 26, 0);
        // Separation bar
        renderArea.drawString("|", 39, 0);
        // Coins
        renderArea.drawString("Coins " + this.getSuperRPG().getCoins(), 41, 0);
        // Second status bar line
        // ATK + weapon + damage
        renderArea.drawString("ATK " + this.getSuperRPG().getWeapon() + " (" + this.getSuperRPG().getDamage() + ")", 0, 1);
        // Separation bar
        renderArea.drawString("|", 24, 1);
        // DEF + defense item + defense
        renderArea.drawString("DEF " + this.getSuperRPG().getDefenseItem() + " (" + this.getSuperRPG().getDefense() + ")", 26, 1);
        // Call the mother class draw method
        _super.prototype.draw.call(this, renderArea);
    };
    return SuperRPGMenu_Ingame;
})(SuperRPGMenu);
///<reference path="SuperRPGMenu.ts"/>
var SuperRPGMenu_Main = (function (_super) {
    __extends(SuperRPGMenu_Main, _super);
    // Constructor
    function SuperRPGMenu_Main(superRPG) {
        _super.call(this, superRPG, "places/village/thirdHouseGames/SuperRPG/mainMenu", 0);
        this.addEntry(new SuperRPGMenuEntry("Start", new CallbackCollection(this.getSuperRPG().startGame.bind(this.getSuperRPG(), false))));
        if (Saving.loadBool("SuperRPGUnlockedHardmode"))
            this.addEntry(new SuperRPGMenuEntry("Start (hardmode)", new CallbackCollection(this.getSuperRPG().startGame.bind(this.getSuperRPG(), true))));
        this.addEntry(new SuperRPGMenuEntry("Exit", new CallbackCollection(this.getSuperRPG().exitGame.bind(this.getSuperRPG()))));
    }
    // Public methods
    SuperRPGMenu_Main.prototype.draw = function (renderArea) {
        // Draw the "main menu" text
        renderArea.drawString("Main menu", 22, 0);
        // Mother class draw method
        _super.prototype.draw.call(this, renderArea);
    };
    return SuperRPGMenu_Main;
})(SuperRPGMenu);
///<reference path="SuperRPGMenu_Ingame.ts"/>
var SuperRPGMenu_Monster = (function (_super) {
    __extends(SuperRPGMenu_Monster, _super);
    // Constructor
    function SuperRPGMenu_Monster(superRPG) {
        _super.call(this, superRPG, "", 0);
    }
    // Public methods
    SuperRPGMenu_Monster.prototype.addUsualEntries = function () {
        this.addEntry(new SuperRPGMenuEntry("Attack", new CallbackCollection(this.playerAttacks.bind(this))));
    };
    SuperRPGMenu_Monster.prototype.draw = function (renderArea) {
        // Draw the monster damage
        renderArea.drawString("ATK " + this.damage, 0, 11);
        // Draw the monster defense
        renderArea.drawString("DEF " + this.defense, 7, 11);
        // Draw the monster hp and max hp
        renderArea.drawString("HP " + this.hp + "/" + this.maxHp, 14, 11);
        // Call the mother class draw method
        _super.prototype.draw.call(this, renderArea);
    };
    SuperRPGMenu_Monster.prototype.setAbstract = function (atk, def, coins, hp) {
        this.setMonster("places/village/thirdHouseGames/SuperRPG/" + Random.fromArray(["cross", "mobius", "triforce", "randomShape", "circle", "dna", "hive", "star"]), atk, def, coins, hp);
    };
    SuperRPGMenu_Monster.prototype.setBabyVampire = function () {
        this.setMonster("places/village/thirdHouseGames/SuperRPG/babyVampire", 10, 2, 8, 30);
    };
    SuperRPGMenu_Monster.prototype.setBlob = function () {
        this.setMonster("places/village/thirdHouseGames/SuperRPG/blob", Random.between(1, 3), 0, Random.between(5, 8), 3);
    };
    SuperRPGMenu_Monster.prototype.setBomb = function () {
        this.setMonster("places/village/thirdHouseGames/SuperRPG/bomb", 99, 0, 0, 12);
    };
    SuperRPGMenu_Monster.prototype.setChest = function (coins) {
        this.setMonster("places/village/thirdHouseGames/SuperRPG/chest", 0, 0, coins, 10);
    };
    SuperRPGMenu_Monster.prototype.setCorpse1 = function () {
        this.setMonster("places/village/thirdHouseGames/SuperRPG/corpse1", 0, 0, (Random.flipACoin() ? 0 : Random.between(1, 300)), 0);
    };
    SuperRPGMenu_Monster.prototype.setCorpse2 = function () {
        this.setMonster("places/village/thirdHouseGames/SuperRPG/corpse2", 0, 0, (Random.flipACoin() ? 0 : Random.between(1, 300)), 0);
    };
    SuperRPGMenu_Monster.prototype.setDragon = function () {
        this.setMonster("places/village/thirdHouseGames/SuperRPG/dragon", Random.between(28, 32), Random.between(7, 9), 1000, Random.fromArray([45, 50, 55]));
    };
    SuperRPGMenu_Monster.prototype.setFerociousBlob = function () {
        this.setMonster("places/village/thirdHouseGames/SuperRPG/ferociousBlob", Random.between(2, 4), 0, Random.between(7, 10), 2);
    };
    SuperRPGMenu_Monster.prototype.setFerociousGoblin = function () {
        this.setMonster("places/village/thirdHouseGames/SuperRPG/ferociousGoblin", 5, 3, 20, 5);
    };
    SuperRPGMenu_Monster.prototype.setFerociousSkeleton = function () {
        this.setMonster("places/village/thirdHouseGames/SuperRPG/ferociousSkeleton", 8, 1, 40, 10);
    };
    SuperRPGMenu_Monster.prototype.setGoblin = function () {
        this.setMonster("places/village/thirdHouseGames/SuperRPG/goblin", 4, 1, 15, 5);
    };
    SuperRPGMenu_Monster.prototype.setSkeletonOrBillGatesSkeleton = function () {
        // Bill gates skeleton
        if (Random.oneChanceOutOf(10))
            this.setMonster("places/village/thirdHouseGames/SuperRPG/billGatesSkeleton", 6, 1, 50, 7);
        else
            this.setMonster("places/village/thirdHouseGames/SuperRPG/skeleton", 6, 1, 25, 7);
    };
    SuperRPGMenu_Monster.prototype.setSpider = function () {
        this.setMonster("places/village/thirdHouseGames/SuperRPG/spider", 10, 5, Random.between(100, 200), 25);
    };
    SuperRPGMenu_Monster.prototype.setSpiders = function () {
        this.setMonster("places/village/thirdHouseGames/SuperRPG/spiders", 9, 2, 9, 15);
    };
    SuperRPGMenu_Monster.prototype.setThing = function () {
        switch (Random.between(0, 2)) {
            case 0:
                this.setMonster("places/village/thirdHouseGames/SuperRPG/thing", 20, 3, 120, 10);
                break;
            case 1:
                this.setMonster("places/village/thirdHouseGames/SuperRPG/thing", 12, 6, 120, 30);
                break;
            case 2:
                this.setMonster("places/village/thirdHouseGames/SuperRPG/thing", 14, 4, 120, 20);
                break;
        }
    };
    // Private methods
    SuperRPGMenu_Monster.prototype.playerAttacks = function () {
        // Variable used for damage calculation
        var damage;
        // We lose hp
        damage = this.getSuperRPG().getDamage() - this.defense;
        if (damage > 0) {
            this.hp -= damage;
            // If we have 0 or less hp, we get the coins, go to the next floor step and return
            if (this.hp <= 0) {
                this.getSuperRPG().setCoins(this.getSuperRPG().getCoins() + this.coins);
                this.getSuperRPG().nextFloorStep();
                return;
            }
        }
        // We didn't return : it means we're still alive : we counter attack
        damage = this.damage - this.getSuperRPG().getDefense();
        if (damage > 0) {
            this.getSuperRPG().setHp(this.getSuperRPG().getHp() - damage);
        }
    };
    SuperRPGMenu_Monster.prototype.setMonster = function (asciiName, damage, defense, coins, hp, maxHp) {
        if (maxHp === void 0) { maxHp = null; }
        // Set from the parameters
        this.setAsciiName(asciiName);
        this.damage = (this.getSuperRPG().getHardmode() ? Math.floor(damage * 1.2) : damage);
        this.defense = (this.getSuperRPG().getHardmode() ? Math.floor(defense * 1.2) : defense);
        this.coins = (this.getSuperRPG().getHardmode() ? Math.ceil(coins * 0.8) : coins);
        this.hp = (this.getSuperRPG().getHardmode() ? Math.floor(hp * 1.2) : hp);
        if (maxHp == null)
            this.maxHp = this.hp;
        else
            this.maxHp = (this.getSuperRPG().getHardmode() ? Math.floor(maxHp * 1.2) : maxHp);
    };
    return SuperRPGMenu_Monster;
})(SuperRPGMenu_Ingame);
///<reference path="SuperRPGMenu_Ingame.ts"/>
var SuperRPGMenu_Shop = (function (_super) {
    __extends(SuperRPGMenu_Shop, _super);
    // Constructor
    function SuperRPGMenu_Shop(superRPG) {
        _super.call(this, superRPG, "places/village/thirdHouseGames/SuperRPG/shop", 0);
    }
    // Public methods
    SuperRPGMenu_Shop.prototype.addBuyingDefenseItem = function (defenseItem, defense, price) {
        this.addEntry(new SuperRPGMenuEntry(defenseItem + " (" + price + ")", new CallbackCollection(this.buyDefenseItem.bind(this, defenseItem, defense, price))));
    };
    SuperRPGMenu_Shop.prototype.addBuyingHealthCrystal = function () {
        this.addEntry(new SuperRPGMenuEntry("Health crystal (100)", new CallbackCollection(this.buyHealthCrystal.bind(this))));
    };
    SuperRPGMenu_Shop.prototype.addBuyingHealthPendant = function () {
        this.addEntry(new SuperRPGMenuEntry("Health pendant (30)", new CallbackCollection(this.buyHealthPendant.bind(this))));
    };
    SuperRPGMenu_Shop.prototype.addBuyingHealthPotion = function () {
        this.addEntry(new SuperRPGMenuEntry("Health potion (5)", new CallbackCollection(this.buyHealthPotion.bind(this))));
    };
    SuperRPGMenu_Shop.prototype.addBuyingSuperHealthPotion = function () {
        this.addEntry(new SuperRPGMenuEntry("Health potion ++ (25)", new CallbackCollection(this.buySuperHealthPotion.bind(this))));
    };
    SuperRPGMenu_Shop.prototype.addBuyingWeapon = function (weapon, damage, price) {
        this.addEntry(new SuperRPGMenuEntry(weapon + " (" + price + ")", new CallbackCollection(this.buyWeapon.bind(this, weapon, damage, price))));
    };
    SuperRPGMenu_Shop.prototype.addQuitTheShop = function () {
        this.addEntry(new SuperRPGMenuEntry("Quit the shop", new CallbackCollection(this.getSuperRPG().nextFloorStep.bind(this.getSuperRPG()))));
    };
    // Private methods
    SuperRPGMenu_Shop.prototype.buyDefenseItem = function (defenseItem, defense, price) {
        if (this.getSuperRPG().getCoins() >= price && this.getSuperRPG().getDefense() < defense) {
            this.getSuperRPG().setCoins(this.getSuperRPG().getCoins() - price);
            this.getSuperRPG().setDefenseItem(defenseItem);
            this.getSuperRPG().setDefense(defense);
        }
    };
    SuperRPGMenu_Shop.prototype.buyHealthCrystal = function () {
        if (this.getSuperRPG().getCoins() >= 100) {
            this.getSuperRPG().setCoins(this.getSuperRPG().getCoins() - 100);
            this.getSuperRPG().setMaxHp(this.getSuperRPG().getMaxHp() + 20);
            this.getSuperRPG().setHp(this.getSuperRPG().getHp() + 20);
        }
    };
    SuperRPGMenu_Shop.prototype.buyHealthPendant = function () {
        if (this.getSuperRPG().getCoins() >= 30) {
            this.getSuperRPG().setCoins(this.getSuperRPG().getCoins() - 30);
            this.getSuperRPG().setMaxHp(this.getSuperRPG().getMaxHp() + 5);
            this.getSuperRPG().setHp(this.getSuperRPG().getHp() + 5);
        }
    };
    SuperRPGMenu_Shop.prototype.buyHealthPotion = function () {
        if (this.getSuperRPG().getCoins() >= 5 && this.getSuperRPG().getHp() < this.getSuperRPG().getMaxHp()) {
            this.getSuperRPG().setCoins(this.getSuperRPG().getCoins() - 5);
            this.getSuperRPG().setHp(this.getSuperRPG().getHp() + 8);
        }
    };
    SuperRPGMenu_Shop.prototype.buySuperHealthPotion = function () {
        if (this.getSuperRPG().getCoins() >= 25 && this.getSuperRPG().getHp() < this.getSuperRPG().getMaxHp()) {
            this.getSuperRPG().setCoins(this.getSuperRPG().getCoins() - 25);
            this.getSuperRPG().setHp(this.getSuperRPG().getHp() + 50);
        }
    };
    SuperRPGMenu_Shop.prototype.buyWeapon = function (weapon, damage, price) {
        if (this.getSuperRPG().getCoins() >= price && this.getSuperRPG().getDamage() < damage) {
            this.getSuperRPG().setCoins(this.getSuperRPG().getCoins() - price);
            this.getSuperRPG().setWeapon(weapon);
            this.getSuperRPG().setDamage(damage);
        }
    };
    return SuperRPGMenu_Shop;
})(SuperRPGMenu_Ingame);
var SuperRPGStep;
(function (SuperRPGStep) {
    SuperRPGStep[SuperRPGStep["SPLASH_SCREEN"] = 0] = "SPLASH_SCREEN";
    SuperRPGStep[SuperRPGStep["GAME"] = 1] = "GAME";
    SuperRPGStep[SuperRPGStep["LOSE"] = 2] = "LOSE";
})(SuperRPGStep || (SuperRPGStep = {}));
///<reference path="QuestEntity.ts"/>
var Teapot = (function (_super) {
    __extends(Teapot, _super);
    // Constructor
    function Teapot(quest, pos) {
        _super.call(this, quest, pos, new Naming("A teapot", "a teapot"), new RenderArea(19, 6), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 1), new Pos(3, 1)), new CollisionBox(this, new Pos(6, 1), new Pos(8, 1)), new CollisionBox(this, new Pos(1, 2), new Pos(18, 1)), new CollisionBox(this, new Pos(2, 3), new Pos(17, 1)), new CollisionBox(this, new Pos(3, 4), new Pos(16, 1)), new CollisionBox(this, new Pos(5, 5), new Pos(12, 1))), new QuestEntityMovement());
        // Set gravity
        this.getQuestEntityMovement().setGravity(true);
        this.getQuestEntityMovement().setWormsLike(true);
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(1000000);
        this.setHp(1000000);
        // Set the ascii art and the transparent character
        this.getRenderArea().drawArray(Database.getAscii("places/quests/fortress/teapot"));
        this.setTransparency(new RenderTransparency(" ", "%"));
    }
    // update()
    Teapot.prototype.update = function () {
        _super.prototype.update.call(this);
        console.log(this.getHp());
        // We heal ourselves if the player is too far on the left
        if (this.getQuest().getGame().getPlayer().getGlobalPosition().x < this.getGlobalPosition().x - 50)
            this.heal(50);
    };
    // willDie()
    Teapot.prototype.willDie = function () {
        // Candies
        this.getQuest().getGame().getQuestLog().addMessage(new QuestLogMessage(this.getDeathMessage()));
        // The spoon
        this.getQuest().foundGridOrEqItem(new QuestItemFound(this.getQuest(), "eqItemWeaponGiantSpoon", "You found a giant spoon inside the teapot.", "You gain a giant spoon."));
    };
    return Teapot;
})(QuestEntity);
///<reference path="Place.ts"/>
var TheArena = (function (_super) {
    __extends(TheArena, _super);
    // Constructor
    function TheArena(game) {
        _super.call(this, game);
        // The render area
        this.renderArea = new RenderArea();
        this.renderArea.resize(100, 20);
        this.update();
    }
    // getRenderArea()
    TheArena.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // Private methods
    TheArena.prototype.drawQuestLogo = function (questFolderName, x, y) {
        // If the quest folder name given isn't null
        if (questFolderName != null) {
            // If this quest doesn't exist
            if (TheArenaModule.getQuest(questFolderName) == null)
                console.log("Trying to draw the arena quest " + questFolderName + " which wasn't added to the arena module.");
            else {
                // Draw the logo
                TheArenaModule.getQuest(questFolderName).drawLogo(this.renderArea, x, y, this.getGame());
            }
        }
        // Draw the borders
        this.renderArea.drawHorizontalLine("-", x, x + 19, y);
        this.renderArea.drawHorizontalLine("-", x, x + 19, y + 5);
        this.renderArea.drawVerticalLine("|", x, y, y + 5);
        this.renderArea.drawVerticalLine("|", x + 19, y, y + 5);
    };
    TheArena.prototype.update = function () {
        // Erase everything
        this.renderArea.resetAllButSize();
        // Quick explanation
        this.renderArea.drawString("The Arena is a special area featuring additional quests written by players.", 12, 1);
        // List of quests
        this.drawQuestLogo("peacefulForest", 2, 3);
        this.drawQuestLogo("hardcorePlatformer", 21, 3);
        this.drawQuestLogo(null, 40, 3);
        this.drawQuestLogo(null, 59, 3);
        this.drawQuestLogo(null, 78, 3);
        this.drawQuestLogo(null, 2, 8);
        this.drawQuestLogo(null, 21, 8);
        this.drawQuestLogo(null, 40, 8);
        this.drawQuestLogo(null, 59, 8);
        this.drawQuestLogo(null, 78, 8);
        // Hardmode
        this.renderArea.drawString("If you want more challenge, you can also play hardmode here : ", 1, 17);
        this.renderArea.addHtmlLink(63, 17, "http://candybox2.github.io/?gamemode=hard", "http://candybox2.github.io/?gamemode=hard");
        // Create your quest!
        this.renderArea.drawString("If you're a programmer and you want to create a quest,                     and                 !", 1, 15);
        this.renderArea.addHtmlLink(56, 15, "source_code.html", "get the source code");
        this.renderArea.addHtmlLink(80, 15, "create_quest.html", "follow the guide");
    };
    return TheArena;
})(Place);
var TheArenaModule;
(function (TheArenaModule) {
    var quests = {};
    // Add a quest
    function addQuest(quest) {
        quests[quest.getQuestFolderName()] = quest;
    }
    TheArenaModule.addQuest = addQuest;
    // Get a quest
    function getQuest(questFolderName) {
        return quests[questFolderName];
    }
    TheArenaModule.getQuest = getQuest;
})(TheArenaModule || (TheArenaModule = {}));
var TheArenaModuleQuest = (function () {
    // Constructor
    function TheArenaModuleQuest(questFolderName, specialCallback) {
        // Set from parameters
        this.questFolderName = questFolderName;
        this.specialCallback = specialCallback;
    }
    // Public methods
    TheArenaModuleQuest.prototype.drawLogo = function (renderArea, x, y, game) {
        // Draw the logo ascii art
        renderArea.drawArray(Database.getAscii("arena/" + this.questFolderName + "/logo"), x + 1, y + 1);
        // Add the button and the link
        renderArea.addMultipleAsciiButtons("theArenaQuest" + this.questFolderName, x + 1, x + 19, y + 1, x + 1, x + 19, y + 2, x + 1, x + 19, y + 3, x + 1, x + 19, y + 4);
        renderArea.addLinkCall(".theArenaQuest" + this.questFolderName, new CallbackCollection(this.launchQuest.bind(this, game)));
    };
    // Public getters
    TheArenaModuleQuest.prototype.getQuestFolderName = function () {
        return this.questFolderName;
    };
    // Private methods
    TheArenaModuleQuest.prototype.launchQuest = function (game) {
        if (game.canStartQuest()) {
            game.getStatusBar().selectTabByType(StatusBarTabType.MAP);
            game.goToMap();
            game.setPlace(this.specialCallback(game));
        }
    };
    return TheArenaModuleQuest;
})();
///<reference path="Place.ts"/>
var TheCave = (function (_super) {
    __extends(TheCave, _super);
    // Constructor
    function TheCave(game) {
        _super.call(this, game);
        // The render area
        this.renderArea = new RenderArea();
        // Last moves chosen
        this.lastMoves = [];
        // Database text names for the first sentence below
        this.firstSentence = null;
        // Pattern currently in use
        this.pattern = null;
        // Add the additional characters to the array
        this.createAdditionalCharactersPossible();
        // Add the additional characters positions to the array
        this.createAdditionalCharactersPositionsPossible();
        // Create the current way
        this.createWay();
        // Resize & update
        this.renderArea.resizeFromArray(Database.getAscii("places/theCave/ways"), 42, 7); // 3 for the return to map button + 4 for the two sentences = 7
        this.update();
    }
    // getRenderArea()
    TheCave.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // Public methods
    TheCave.prototype.aPatternNeedsUpdating = function () {
        this.update();
        this.getGame().updatePlace();
    };
    // Public getters
    TheCave.prototype.getAdditionalCharactersPositionsPossible = function () {
        return this.additionalCharactersPositionsPossible;
    };
    TheCave.prototype.getAdditionalCharactersPossible = function () {
        return this.additionalCharactersPossible;
    };
    // Private methods
    TheCave.prototype.createAdditionalCharactersPositionsPossible = function () {
        // Reset the array
        this.additionalCharactersPositionsPossible = [];
        // Add positions
        this.additionalCharactersPositionsPossible.push(new Pos(20, 6));
        this.additionalCharactersPositionsPossible.push(new Pos(19, 9));
        this.additionalCharactersPositionsPossible.push(new Pos(17, 13));
        this.additionalCharactersPositionsPossible.push(new Pos(20, 18));
        this.additionalCharactersPositionsPossible.push(new Pos(17, 24));
        this.additionalCharactersPositionsPossible.push(new Pos(41, 19));
        this.additionalCharactersPositionsPossible.push(new Pos(56, 16));
        this.additionalCharactersPositionsPossible.push(new Pos(52, 22));
        this.additionalCharactersPositionsPossible.push(new Pos(31, 23));
        this.additionalCharactersPositionsPossible.push(new Pos(64, 28));
        this.additionalCharactersPositionsPossible.push(new Pos(64, 12));
        this.additionalCharactersPositionsPossible.push(new Pos(75, 5));
        this.additionalCharactersPositionsPossible.push(new Pos(80, 12));
        this.additionalCharactersPositionsPossible.push(new Pos(77, 17));
        this.additionalCharactersPositionsPossible.push(new Pos(80, 20));
        this.additionalCharactersPositionsPossible.push(new Pos(78, 26));
    };
    TheCave.prototype.createAdditionalCharactersPossible = function () {
        // Reset the array
        this.additionalCharactersPossible = [];
        // Add characters
        this.additionalCharactersPossible.push("V");
        this.additionalCharactersPossible.push("\\");
        this.additionalCharactersPossible.push("/");
        this.additionalCharactersPossible.push("'");
        this.additionalCharactersPossible.push("`");
        this.additionalCharactersPossible.push("~");
        this.additionalCharactersPossible.push(")");
        this.additionalCharactersPossible.push("(");
        this.additionalCharactersPossible.push("}");
        this.additionalCharactersPossible.push("{");
        this.additionalCharactersPossible.push("@");
        this.additionalCharactersPossible.push(">");
        this.additionalCharactersPossible.push("^");
    };
    TheCave.prototype.createWay = function (moveType) {
        if (moveType === void 0) { moveType = null; }
        // A variable used in the loop choosing the new pattern
        var cont;
        // Reset the additional characters array
        this.additionalCharacters = [];
        // Set the first sentence
        switch (moveType) {
            case TheCaveMoveType.STRAIGHT:
                this.firstSentence = "theCaveFirstSentenceWentStraight";
                break;
            case TheCaveMoveType.LEFT:
                this.firstSentence = "theCaveFirstSentenceWentLeft";
                break;
            case TheCaveMoveType.RIGHT:
                this.firstSentence = "theCaveFirstSentenceWentRight";
                break;
            case null:
                this.firstSentence = "theCaveFirstSentenceYouAre";
                break;
        }
        // If there's a pattern, we possibly set it to null
        if (this.pattern != null) {
            // If this pattern should end, there's no pattern anymore
            if (this.pattern.ended()) {
                this.pattern = null;
            }
        }
        // If there's no pattern (and we moved at least once)
        if (this.pattern == null && this.lastMoves.length > 0) {
            // One chance out of two to use a new one
            if (Random.flipACoin()) {
                cont = 10;
                while (cont > 0 && this.pattern == null) {
                    cont -= 1;
                    switch (Random.upTo(4)) {
                        case 0:
                            if (Saving.loadBool("gridItemPossessedHeartPlug") == false)
                                this.pattern = new TheCavePattern_ArrowsToHeartPlug(this);
                            break;
                        case 1:
                            if (Saving.loadBool("TheCavePattern_ChocolateBarNowGotTheBar") == false)
                                this.pattern = new TheCavePattern_ChocolateBarNow(this);
                            break;
                        case 2:
                            if (Saving.loadBool("TheCavePattern_TreasureMapFoundTreasure") == false)
                                this.pattern = new TheCavePattern_TreasureMap(this);
                            break;
                        case 3:
                            this.pattern = new TheCavePattern_MonkeyWizard(this);
                            break;
                        case 4:
                            this.pattern = new TheCavePattern_OctopusKing(this);
                            break;
                    }
                }
            }
        }
        // Add some additional characters
        for (var i = 0; i < 10; i++) {
            this.additionalCharacters.push(new TheCaveAdditionalCharacter(this));
        }
    };
    TheCave.prototype.drawWays = function (x, y) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 3; }
        // Draw the background
        this.renderArea.drawArray(Database.getAscii("places/theCave/ways"), x + 21, y);
        // Draw additional characters
        for (var i = 0; i < this.additionalCharacters.length; i++) {
            this.renderArea.drawString(this.additionalCharacters[i].getString(), x + this.additionalCharacters[i].getPosition().x, y + this.additionalCharacters[i].getPosition().y);
        }
        // Draw the sentences
        if (this.firstSentence != null) {
            this.renderArea.drawString(Database.getText(this.firstSentence), x + 23, y + 32);
            this.renderArea.drawString(Database.getTranslatedText(this.firstSentence), x + 23, y + 33, true);
        }
        if (this.pattern != null && this.pattern.getSentence() != null) {
            this.renderArea.drawString(Database.getText(this.pattern.getSentence()), x + 23, y + 34);
            this.renderArea.drawString(Database.getTranslatedText(this.pattern.getSentence()), x + 23, y + 35, true);
        }
        // If there's a pattern, draw pattern related stuff
        if (this.pattern != null)
            this.pattern.draw(this.renderArea, x, y);
        // Add the black background color
        for (var i = 0; i <= 4; i++) {
            this.renderArea.addBackgroundColor(x + 46, x + 54, y + 1 + i, new Color(ColorType.THECAVE_BACKGROUND_COLOR));
        }
        // Add the button to go left
        this.renderArea.addMultipleAsciiButtons("theCaveGoLeftButton", x + 30, x + 32, y + 5, x + 29, x + 33, y + 6, x + 27, x + 33, y + 7, x + 26, x + 32, y + 8, x + 26, x + 32, y + 9, x + 26, x + 32, y + 10, x + 25, x + 32, y + 11, x + 24, x + 32, y + 12, x + 25, x + 31, y + 13, x + 25, x + 31, y + 14, x + 25, x + 32, y + 15, x + 25, x + 32, y + 16, x + 25, x + 32, y + 17, x + 25, x + 32, y + 18, x + 24, x + 32, y + 19, x + 24, x + 31, y + 20, x + 25, x + 30, y + 21, x + 26, x + 29, y + 22, x + 26, x + 28, y + 23, x + 25, x + 27, y + 24, x + 25, x + 26, y + 25);
        this.renderArea.addLinkCall(".theCaveGoLeftButton", new CallbackCollection(this.move.bind(this, TheCaveMoveType.LEFT)));
        // Add the button to go right
        this.renderArea.addMultipleAsciiButtons("theCaveGoRightButton", x + 68, x + 70, y + 6, x + 68, x + 72, y + 7, x + 68, x + 73, y + 8, x + 68, x + 73, y + 9, x + 69, x + 74, y + 10, x + 69, x + 74, y + 11, x + 69, x + 74, y + 12, x + 69, x + 75, y + 13, x + 69, x + 75, y + 14, x + 68, x + 74, y + 15, x + 68, x + 74, y + 16, x + 68, x + 74, y + 17, x + 68, x + 74, y + 18, x + 68, x + 74, y + 19, x + 69, x + 74, y + 20, x + 70, x + 74, y + 21, x + 71, x + 74, y + 22, x + 72, x + 73, y + 23);
        this.renderArea.addLinkCall(".theCaveGoRightButton", new CallbackCollection(this.move.bind(this, TheCaveMoveType.RIGHT)));
        // Add the button to go straight
        this.renderArea.addMultipleAsciiButtons("theCaveGoStraightButton", x + 46, x + 54, y + 1, x + 46, x + 54, y + 2, x + 46, x + 54, y + 3, x + 46, x + 54, y + 4, x + 46, x + 54, y + 5);
        this.renderArea.addLinkCall(".theCaveGoStraightButton", new CallbackCollection(this.move.bind(this, TheCaveMoveType.STRAIGHT)));
    };
    TheCave.prototype.goToTheCaveExit = function () {
        Saving.saveBool("mainMapDoneCaveEntrance", true);
        this.getGame().setPlace(new TheCaveExit(this.getGame()));
    };
    TheCave.prototype.move = function (type) {
        // If we made more than 12 moves and there's no pattern, we reach the exit
        if (this.lastMoves.length > 12 && this.pattern == null) {
            this.goToTheCaveExit();
        }
        // If there's a pattern, we call its move method
        if (this.pattern != null)
            this.pattern.move(type);
        // Add this move to the last moves
        this.lastMoves.push(type);
        // Create the new way
        this.createWay(type);
        // Update
        this.update();
        this.getGame().updatePlace();
    };
    TheCave.prototype.update = function () {
        // Erase everything
        this.renderArea.resetAllButSize();
        // Back to the map button
        this.addBackToMainMapButton(this.renderArea, "theCaveBackToTheMapButton");
        // Draw the ways
        this.drawWays();
    };
    return TheCave;
})(Place);
var TheCaveAdditionalCharacter = (function () {
    // Constructor
    function TheCaveAdditionalCharacter(theCave, characterString, characterPosition) {
        if (characterString === void 0) { characterString = null; }
        if (characterPosition === void 0) { characterPosition = null; }
        // We set the cave
        this.theCave = theCave;
        // If the string given in parameter isn't null
        if (characterString != null) {
            // We set our string from this one
            this.characterString = characterString;
        }
        else {
            // We choose a string randomly from the possible strings
            this.characterString = this.theCave.getAdditionalCharactersPossible()[Random.upTo(this.theCave.getAdditionalCharactersPossible().length - 1)];
        }
        // If the position given in parameters isn't null
        if (characterPosition != null) {
            // We set our position from this one
            this.characterPosition = characterPosition;
        }
        else {
            // We choose a position randomly from the possible positions
            this.characterPosition = this.theCave.getAdditionalCharactersPositionsPossible()[Random.upTo(this.theCave.getAdditionalCharactersPositionsPossible().length - 1)];
        }
    }
    // Public getters
    TheCaveAdditionalCharacter.prototype.getPosition = function () {
        return this.characterPosition;
    };
    TheCaveAdditionalCharacter.prototype.getString = function () {
        return this.characterString;
    };
    return TheCaveAdditionalCharacter;
})();
///<reference path="Place.ts"/>
var TheCaveExit = (function (_super) {
    __extends(TheCaveExit, _super);
    // Constructor
    function TheCaveExit(game) {
        _super.call(this, game);
        // The render area
        this.renderArea = new RenderArea();
        this.renderArea.resizeFromArray(Database.getAscii("places/theCave/exit"), 42, 3);
        this.update();
    }
    // getRenderArea()
    TheCaveExit.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // Private methods
    TheCaveExit.prototype.update = function () {
        // Erase everything
        this.renderArea.resetAllButSize();
        // Draw the background
        this.renderArea.drawArray(Database.getAscii("places/theCave/exit"), 21, 3);
        // Draw the text
        this.renderArea.drawString(Database.getText("theCaveExitText0"), 30, 3);
        this.renderArea.drawString(Database.getText("theCaveExitText1"), 30, 4);
        // Draw the translated text
        this.renderArea.drawString(Database.getTranslatedText("theCaveExitText0"), 30, 6, true);
        this.renderArea.drawString(Database.getTranslatedText("theCaveExitText1"), 30, 7, true);
        // Add the button to return to the main map
        this.renderArea.addAsciiRealButton(Database.getText("theCaveExitButtonText"), 41, 20, "theCaveExitReturnToMapButton", Database.getTranslatedText("theCaveExitButtonText"), true);
        this.renderArea.addLinkCall(".theCaveExitReturnToMapButton", new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())));
    };
    return TheCaveExit;
})(Place);
var TheCaveMoveType;
(function (TheCaveMoveType) {
    TheCaveMoveType[TheCaveMoveType["LEFT"] = 0] = "LEFT";
    TheCaveMoveType[TheCaveMoveType["RIGHT"] = 1] = "RIGHT";
    TheCaveMoveType[TheCaveMoveType["STRAIGHT"] = 2] = "STRAIGHT";
})(TheCaveMoveType || (TheCaveMoveType = {}));
var TheCavePattern = (function () {
    // Constructor
    function TheCavePattern(theCave) {
        this.theCave = theCave;
    }
    // Public methods
    TheCavePattern.prototype.draw = function (renderArea, x, y) {
    };
    TheCavePattern.prototype.ended = function () {
        return false;
    };
    TheCavePattern.prototype.getSentence = function () {
        return null;
    };
    TheCavePattern.prototype.move = function (type) {
    };
    // Public getters
    TheCavePattern.prototype.getTheCave = function () {
        return this.theCave;
    };
    return TheCavePattern;
})();
///<reference path="TheCavePattern.ts"/>
var TheCavePattern_ArrowsToHeartPlug = (function (_super) {
    __extends(TheCavePattern_ArrowsToHeartPlug, _super);
    // Constructor
    function TheCavePattern_ArrowsToHeartPlug(theCave) {
        _super.call(this, theCave);
        // Is the pattern stopped?
        this.stopped = false;
        // Should we draw an arrow?
        this.arrow = true;
        // Number of times the player correctly followed the arrows
        this.followedNumber = 0;
        // Did we find the heart plug?
        this.foundPlug = false;
        // Did we get the heart plug? (true if the player clicked on it)
        this.gotPlug = false;
        // Choose a random direction
        this.arrowAtRight = Random.flipACoin();
    }
    // Public methods
    TheCavePattern_ArrowsToHeartPlug.prototype.draw = function (renderArea, x, y) {
        // If we should draw an arrow
        if (this.arrow) {
            // Draw a different arrow depending on the direction
            if (this.arrowAtRight == true) {
                renderArea.drawString("->", x + 71, y + 17);
            }
            else {
                renderArea.drawString("<-", x + 26, y + 17);
            }
        }
        // If we found the plug and didn't pick it up yet
        if (this.foundPlug == true && this.gotPlug == false) {
            // Draw the plug ascii art
            renderArea.drawArray(Database.getAscii("places/theCave/heartPlug"), x + 46, y + 14);
            // Draw the button over the plug
            renderArea.addMultipleAsciiButtons("theCavePattern_ArrowsToHeartPlugButton", x + 46, x + 53, y + 14, x + 46, x + 53, y + 15);
            // Add the button link
            renderArea.addLinkCall(".theCavePattern_ArrowsToHeartPlugButton", new CallbackCollection(this.getPlug.bind(this)));
        }
    };
    TheCavePattern_ArrowsToHeartPlug.prototype.ended = function () {
        return this.stopped;
    };
    TheCavePattern_ArrowsToHeartPlug.prototype.getSentence = function () {
        // If we found the plug but didn't get it yet, we return the sentence
        if (this.foundPlug == true && this.gotPlug == false) {
            return "theCavePattern_ArrowsToHeartPlugSeeStrangePlug";
        }
        // Else, we return null
        return null;
    };
    TheCavePattern_ArrowsToHeartPlug.prototype.move = function (type) {
        // If the arrow is at right and we just went right or the arrow is at left and we just went left, we continue
        if ((this.arrowAtRight == true && type == TheCaveMoveType.RIGHT) ||
            (this.arrowAtRight == false && type == TheCaveMoveType.LEFT)) {
            // If we didn't find the plug yet
            if (this.foundPlug == false) {
                // If we followed at least six arrows
                if (this.followedNumber > 6) {
                    this.foundPlug = true;
                    this.arrow = false;
                }
                else {
                    // Possibly change the arrow direction
                    this.arrowAtRight = Random.flipACoin();
                    // Increase the followed number
                    this.followedNumber += 1;
                }
            }
            else
                this.stopped = true;
        }
        else {
            this.stopped = true;
        }
    };
    // Private methods
    TheCavePattern_ArrowsToHeartPlug.prototype.getPlug = function () {
        // Get the plug
        this.getTheCave().getGame().gainItem("gridItemPossessedHeartPlug");
        this.gotPlug = true;
        // Ask the cave for an update
        this.getTheCave().aPatternNeedsUpdating();
    };
    return TheCavePattern_ArrowsToHeartPlug;
})(TheCavePattern);
///<reference path="TheCavePattern.ts"/>
Saving.registerBool("TheCavePattern_ChocolateBarNowGotTheBar", false);
var TheCavePattern_ChocolateBarNow = (function (_super) {
    __extends(TheCavePattern_ChocolateBarNow, _super);
    // Constructor
    function TheCavePattern_ChocolateBarNow(theCave) {
        _super.call(this, theCave);
        // Did we clicked to get the bar?
        this.gotTheBar = false;
    }
    // Public methods
    TheCavePattern_ChocolateBarNow.prototype.draw = function (renderArea, x, y) {
        // If we didn't pick the bar yet
        if (this.gotTheBar == false) {
            // Draw the bar ascii art
            renderArea.drawArray(Database.getAscii("places/theCave/chocolateBar"), x + 40, y + 25);
            // Draw the button over the plug
            renderArea.addMultipleAsciiButtons("theCavePattern_ChocolateBarNowButton", x + 40, x + 57, y + 26, x + 40, x + 57, y + 27);
            // Add the button link
            renderArea.addLinkCall(".theCavePattern_ChocolateBarNowButton", new CallbackCollection(this.getTheBar.bind(this)));
        }
    };
    TheCavePattern_ChocolateBarNow.prototype.ended = function () {
        return true;
    };
    TheCavePattern_ChocolateBarNow.prototype.getSentence = function () {
        // If we didn't pick the bar yet, we return the sentence
        if (this.gotTheBar == false) {
            return "theCavePattern_ChocolateBarNowSeeChocolateBar";
        }
        // Else, we return null
        return null;
    };
    // Private methods
    TheCavePattern_ChocolateBarNow.prototype.getTheBar = function () {
        // Get the bar
        this.getTheCave().getGame().getChocolateBars().add(1);
        this.gotTheBar = true;
        // We can't get the bar anymore (we can't start this pattern)
        Saving.saveBool("TheCavePattern_ChocolateBarNowGotTheBar", true);
        // Ask the cave for an update
        this.getTheCave().aPatternNeedsUpdating();
    };
    return TheCavePattern_ChocolateBarNow;
})(TheCavePattern);
///<reference path="TheCavePattern.ts"/>
var TheCavePattern_MonkeyWizard = (function (_super) {
    __extends(TheCavePattern_MonkeyWizard, _super);
    // Constructor
    function TheCavePattern_MonkeyWizard(theCave) {
        _super.call(this, theCave);
    }
    // Public methods
    TheCavePattern_MonkeyWizard.prototype.draw = function (renderArea, x, y) {
        // Draw the monkey wizard
        renderArea.drawArray(Database.getAscii("places/theCave/monkeyWizard"), x + 32, y + 6, new RenderTransparency(" ", "%"));
        // Add the button & the link allowing the player to challenge him
        renderArea.addAsciiRealButton(Database.getText("theCavePattern_MonkeyWizardButton"), x + 39, y + 26, "theCavePattern_MonkeyWizardButton", Database.getTranslatedText("theCavePattern_MonkeyWizardButton"));
        renderArea.addLinkCall(".theCavePattern_MonkeyWizardButton", new CallbackCollection(this.challenge.bind(this)));
    };
    TheCavePattern_MonkeyWizard.prototype.ended = function () {
        return true;
    };
    TheCavePattern_MonkeyWizard.prototype.getSentence = function () {
        return "theCavePattern_MonkeyWizardSentence";
    };
    // Private methods
    TheCavePattern_MonkeyWizard.prototype.challenge = function () {
        if (this.getTheCave().getGame().canStartQuest())
            this.getTheCave().getGame().setPlace(new MonkeyWizardQuest(this.getTheCave().getGame()));
    };
    return TheCavePattern_MonkeyWizard;
})(TheCavePattern);
///<reference path="TheCavePattern.ts"/>
var TheCavePattern_OctopusKing = (function (_super) {
    __extends(TheCavePattern_OctopusKing, _super);
    // Constructor
    function TheCavePattern_OctopusKing(theCave) {
        _super.call(this, theCave);
    }
    // Public methods
    TheCavePattern_OctopusKing.prototype.draw = function (renderArea, x, y) {
        // Draw the monkey wizard
        renderArea.drawArray(Database.getAscii("places/theCave/octopusKing"), x + 32, y + 6, new RenderTransparency(" ", "%"));
        // Add the button & the link allowing the player to challenge him
        renderArea.addAsciiRealButton(Database.getText("theCavePattern_OctopusKingButton"), x + 39, y + 26, "theCavePattern_OctopusKingButton", Database.getTranslatedText("theCavePattern_OctopusKingButton"));
        renderArea.addLinkCall(".theCavePattern_OctopusKingButton", new CallbackCollection(this.challenge.bind(this)));
    };
    TheCavePattern_OctopusKing.prototype.ended = function () {
        return true;
    };
    TheCavePattern_OctopusKing.prototype.getSentence = function () {
        return "theCavePattern_OctopusKingSentence";
    };
    // Private methods
    TheCavePattern_OctopusKing.prototype.challenge = function () {
        if (this.getTheCave().getGame().canStartQuest())
            this.getTheCave().getGame().setPlace(new OctopusKingQuest(this.getTheCave().getGame()));
    };
    return TheCavePattern_OctopusKing;
})(TheCavePattern);
///<reference path="TheCavePattern.ts"/>
Saving.registerBool("TheCavePattern_TreasureMapSawMap", false);
Saving.registerBool("TheCavePattern_TreasureMapFoundTreasure", false);
var TheCavePattern_TreasureMap = (function (_super) {
    __extends(TheCavePattern_TreasureMap, _super);
    // Constructor
    function TheCavePattern_TreasureMap(theCave) {
        _super.call(this, theCave);
        // We saw the map!
        Saving.saveBool("TheCavePattern_TreasureMapSawMap", true);
    }
    // Public methods
    TheCavePattern_TreasureMap.prototype.draw = function (renderArea, x, y) {
        renderArea.drawArray(Database.getAscii("places/theCave/treasureMap"), x + 38, y + 22);
    };
    TheCavePattern_TreasureMap.prototype.ended = function () {
        return true;
    };
    TheCavePattern_TreasureMap.prototype.getSentence = function () {
        return "theCavePattern_TreasureMapSentence";
    };
    return TheCavePattern_TreasureMap;
})(TheCavePattern);
///<reference path="Place.ts"/>
var TheComputer = (function (_super) {
    __extends(TheComputer, _super);
    // Constructor
    function TheComputer(game) {
        _super.call(this, game);
        // The render area
        this.renderArea = new RenderArea();
        // The lines
        this.lines = [];
        // The current command text
        this.currentCommandText = "";
        // Did we already add hotkeys?
        this.hotkeysAdded = false;
        // Resize and update
        this.renderArea.resize(100, 40);
        this.update();
    }
    // getRenderArea()
    TheComputer.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // willStopBeingDisplayed()
    TheComputer.prototype.willStopBeingDisplayed = function () {
        this.getGame().setIsStatusBarAllowedToUseTheNKey(true); // The status bar can use the n key now
    };
    // Private methods
    TheComputer.prototype.addHotkeys = function () {
        // Hotkeys are added now
        this.hotkeysAdded = true;
        // Add the enter hotkey
        this.getGame().addHotkey(new Hotkey("enter", new CallbackCollection(this.pressedEnter.bind(this))));
        // Add hotkeys for each letter from a to z
        for (var i = 97; i <= 122; i++) {
            this.getGame().addHotkey(new Hotkey(String.fromCharCode(i), new CallbackCollection(this.pressedKey.bind(this, String.fromCharCode(i)))));
        }
        // Same thing for the numbers from 0 to 9
        for (var i = 48; i <= 57; i++) {
            this.getGame().addHotkey(new Hotkey(String.fromCharCode(i), new CallbackCollection(this.pressedKey.bind(this, String.fromCharCode(i)))));
            this.getGame().addHotkey(new Hotkey("numpad" + String.fromCharCode(i), new CallbackCollection(this.pressedKey.bind(this, String.fromCharCode(i)))));
        }
        // Add the hotkey for the space key
        this.getGame().addHotkey(new Hotkey("space", new CallbackCollection(this.pressedKey.bind(this, " "))));
        // Add the hotkey for the delete key
        this.getGame().addHotkey(new Hotkey("delete", new CallbackCollection(this.pressedDelete.bind(this))));
    };
    TheComputer.prototype.addLine = function (line) {
        this.lines.push(line);
    };
    TheComputer.prototype.addMisunderstood = function () {
        this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "This command was misunderstood. Try \"help\" for a list of available commands."));
    };
    TheComputer.prototype.draw = function () {
        // Erase everything
        this.renderArea.resetAllButSize();
        // Draw the computer
        this.renderArea.drawArray(Database.getAscii("general/theComputer/computer"), 19, 0);
        // Draw the on button
        this.drawOnButton(69, 14);
        // Draw the lines
        this.drawLines(22, 16, 6);
    };
    TheComputer.prototype.drawOnButton = function (x, y) {
        // Draw the button
        this.renderArea.addMultipleAsciiButtons("theComputerOnButton", x + 1, x + 4, y, x, x + 5, y + 1, x + 1, x + 4, y + 2);
        // Add the link
        this.renderArea.addLinkCall(".theComputerOnButton", new CallbackCollection(this.switchOnOff.bind(this)));
    };
    TheComputer.prototype.drawLines = function (x, y, minY) {
        for (var i = this.lines.length - 1; i >= 0; i--) {
            // We add the return value to our y var because it returns the extra lines it used
            y -= this.lines[i].draw(this.renderArea, new Pos(x, y - (this.lines.length - 1 - i)), minY);
        }
    };
    TheComputer.prototype.executeCommand = function (commandText) {
        // Create an array from the command words
        var words = commandText.split(" ");
        // Try to understand the command from the first word
        if (commandText.length > 0 && words.length > 0) {
            switch (words[0]) {
                // Some hidden commands :P
                case "no":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "Yes!"));
                    break;
                case "yes":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "No!"));
                    break;
                case "aniwey":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "He made this game :)"));
                    break;
                case "cedric":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "A nice guy who made the online saving system of the first Candy Box."));
                    break;
                case "17":
                case "dixsept":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "A beta tester and ascii artist. Some people say that he has a big nose. Don't listen to them."));
                    break;
                case "soinou":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "A beta tester. He also made the tab system of the first Candy Box."));
                    break;
                case "42":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "The answer to the ultimate question of life, the universe, and everything."));
                    break;
                case "cp":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "No, you can't copy anything, sorry."));
                    break;
                case "rm":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "No, you can't remove anything, sorry."));
                    break;
                case "cd":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "Where would you like to go anyway?"));
                    break;
                case "ls":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, ". .."));
                    break;
                case "emacs":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "The best text editor ever after vim."));
                    break;
                case "vim":
                case "vi":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "The best text editor ever after emacs."));
                    break;
                case "nano":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "Come on, do you seriously want to use this?"));
                    break;
                case "startx":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "Fatal server error: Cannot establish any listening sockets - Make sure an X server isn't already running"));
                    break;
                case "mkdir":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "Cannot create directory. No, you won't be given any precision."));
                    break;
                case "sudo":
                case "su":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "To gain root access, please use \"su -\". (hint : you can't type the \"-\")"));
                    break;
                case "lol":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "Haha. That's funny."));
                    break;
                case "pwd":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "/home/player"));
                    break;
                case "mv":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "What would you like to move anyway?"));
                    break;
                case "man":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "Nah. Use help instead."));
                    break;
                case "pacman":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "The best package manager ever."));
                    break;
                case "whoami":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "player"));
                    break;
                case "tobias":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "Tobias Nordqvist, an ascii artist. From sweden. Thanks to him!"));
                    break;
                case "deinol":
                case "dani":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "Dani \"Deinol\" Gómez, an ascii artist. Thanks to him!"));
                    break;
                case "godsturf":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "GodsTurf, an ascii artist. Thanks to him!"));
                    break;
                case "mlp":
                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "PONIES PONIES PONIES PONIES PONIES PONIES PONIES PONIES PONIES PONIES"));
                    break;
                // The help command
                case "help":
                    // If there's a second word
                    if (words.length > 1) {
                        // If there's a third word, the command is incorrect
                        if (words.length > 2) {
                            this.addMisunderstood();
                        }
                        else {
                            switch (words[1]) {
                                case "help":
                                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "The help command displays informations about other system commands."));
                                    break;
                                case "add":
                                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "The add command allows you to add a given quantity of a given resource. Usage : \"add quantity resource\"."));
                                    break;
                                case "quantity":
                                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "A quantity is expressed by a number, which is composed of multiple figures."));
                                    break;
                                case "resource":
                                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "List of available resources : candies, lollipops, chocolatebars, painsauchocolat."));
                                    break;
                                case "bug":
                                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "The bug command allows you to configure the bugs generated by the computer. Usage : \"bug type level\"."));
                                    break;
                                case "type":
                                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "The bug type is the kind of bug you want to configure. Allowed types are \"graphical\", \"quest\" and \"ultimate\". Use \"help graphical\", \"help quest\" or \"help ultimate\" for more information."));
                                    break;
                                case "graphical":
                                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "Graphical bugs only affect how the game display informations. They won't be kept after reloading your game."));
                                    break;
                                case "quest":
                                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "Quest bugs affect the quests gameplay. Results are unexpected. They probably won't be kept after reloading your game."));
                                    break;
                                case "ultimate":
                                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "Ultimate bugs can affect a lot of things. They will probably be kept after reloading your game, and they basically could destroy your save. Your browser may even crash. Be careful with them."));
                                    break;
                                case "level":
                                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "The bug level describes how much the bugs will impact the game. Allowed values are 0, 1, 2, 3 and 4. 0 means no bug and 4 is the most powerful bug."));
                                    break;
                                case "command":
                                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "No, you're not supposed to type \"help command\", you should type \"help bug\" or \"help add\" for example."));
                                    break;
                                // Default : misunderstood
                                default:
                                    this.addMisunderstood();
                                    break;
                            }
                        }
                    }
                    else {
                        this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "List of available commands : add, bug, help. Use \"help command\" to get more informations about a specific command. There are probably no hidden commands. I guess."));
                    }
                    break;
                // The add command
                case "add":
                    // If there's a second word
                    if (words.length > 1) {
                        // If there's a third word
                        if (words.length > 2) {
                            // If there's a fourth word
                            if (words.length > 3) {
                                // Misunderstood
                                this.addMisunderstood();
                            }
                            else {
                                // If the second word cannot be converted to a number
                                if (isNaN(parseFloat(words[1])))
                                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "The quantity must be a number. See \"help quantity\" for more informations."));
                                else if (words[2] != "candies" && words[2] != "lollipops" && words[2] != "chocolatebars" && words[2] != "painsauchocolat")
                                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "The resource is invalid. See \"help resource\" for more informations."));
                                else {
                                    // Execute the command, depending on the resource given
                                    switch (words[2]) {
                                        case "candies":
                                            this.getGame().getCandies().add(parseFloat(words[1]));
                                            break;
                                        case "lollipops":
                                            this.getGame().getLollipops().add(parseFloat(words[1]));
                                            break;
                                        case "chocolatebars":
                                            this.getGame().getChocolateBars().add(parseFloat(words[1]));
                                            break;
                                        case "painsauchocolat":
                                            this.getGame().getPainsAuChocolat().add(parseFloat(words[1]));
                                            break;
                                    }
                                    // Write the result
                                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, words[1] + " " + words[2] + " added successfully."));
                                }
                            }
                        }
                        else {
                            this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "You must give a resource. See \"help add\" for more informations."));
                        }
                    }
                    else {
                        this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "You must give a quantity. See \"help add\" for more informations."));
                    }
                    break;
                // The bug command
                case "bug":
                    // If there's a second word
                    if (words.length > 1) {
                        // If there's a third word
                        if (words.length > 2) {
                            // If there's a fourth word
                            if (words.length > 3) {
                                // Misunderstood
                                this.addMisunderstood();
                            }
                            else {
                                // If the second word isn't a valid type
                                if (words[1] != "graphical" && words[1] != "quest" && words[1] != "ultimate")
                                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "The bug type is incorrect. See \"help type\" for more informations."));
                                else if (words[2] != "0" && words[2] != "1" && words[2] != "2" && words[2] != "3" && words[2] != "4")
                                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "The bug level is invalid. See \"help level\" for more informations."));
                                else {
                                    // Execute the command, depending on the type given
                                    switch (words[1]) {
                                        case "graphical":
                                            Bugs.setGraphicalBugLevel(parseInt(words[2]));
                                            break;
                                        case "quest":
                                            Bugs.setQuestBugLevel(parseInt(words[2]));
                                            break;
                                        case "ultimate":
                                            Bugs.setUltimateBugLevel(parseInt(words[2]));
                                            break;
                                    }
                                    // Write the result
                                    this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "Bug type " + words[1] + " set successfully at level " + words[2] + "."));
                                }
                            }
                        }
                        else {
                            this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "You must give a bug level. See \"help level\" for more informations."));
                        }
                    }
                    else {
                        this.addLine(new TheComputerLine(TheComputerLineType.TEXT, "You must give a bug type. See \"help type\" for more informations."));
                    }
                    break;
                // Default : misunderstood
                default:
                    this.addMisunderstood();
                    break;
            }
        }
    };
    TheComputer.prototype.pressedDelete = function () {
        // If we're currently waiting for a command
        if (this.state == TheComputerState.WAITING_FOR_COMMAND) {
            // If the current command text contains at least one letter
            if (this.currentCommandText.length > 0) {
                // We delete the last character
                this.currentCommandText = this.currentCommandText.slice(0, this.currentCommandText.length - 1);
                // We update
                this.update();
                this.getGame().updatePlace();
            }
        }
    };
    TheComputer.prototype.pressedEnter = function () {
        // Do something different depending on the current state
        switch (this.state) {
            // If we were waiting for the return key
            case TheComputerState.WAITING_FOR_RETURN:
                // We change our state
                this.state = TheComputerState.WAITING_FOR_COMMAND;
                // We add an empty text line
                this.addLine(new TheComputerLine(TheComputerLineType.TEXT, ""));
                // We add an empty command line
                this.addLine(new TheComputerLine(TheComputerLineType.COMMAND, ""));
                // We update
                this.update();
                this.getGame().updatePlace();
                break;
            // If we were writing a command
            case TheComputerState.WAITING_FOR_COMMAND:
                // We try to execute the command
                this.executeCommand(this.currentCommandText);
                // We empty the current command text
                this.currentCommandText = "";
                // We add an empty text line
                this.addLine(new TheComputerLine(TheComputerLineType.TEXT, ""));
                // We add an empty command line
                this.addLine(new TheComputerLine(TheComputerLineType.COMMAND, ""));
                // We update
                this.update();
                this.getGame().updatePlace();
                break;
        }
    };
    TheComputer.prototype.pressedKey = function (key) {
        // If we're currently waiting for a command
        if (this.state == TheComputerState.WAITING_FOR_COMMAND) {
            // Create an array of words from the current command text (for checking purposes)
            var words = this.currentCommandText.split(" ");
            // If the last word of the current command text isn't too big and the current command text itself isn't too big either
            if ((words.length == 0 || words[words.length - 1].length < 25 || key == " ") && this.currentCommandText.length < 100) {
                // We add the letter to the command
                this.currentCommandText = this.currentCommandText + key;
                // We update
                this.update();
                this.getGame().updatePlace();
            }
        }
    };
    TheComputer.prototype.switchOnOff = function () {
        // If the computer was on
        if (this.on) {
            this.on = false; // Now it's off
            this.lines = []; // Clear the lines
            this.getGame().setIsStatusBarAllowedToUseTheNKey(true); // The status bar can use the n key now
        }
        else {
            this.on = true; // Now it's on
            // Add the first lines
            this.addLine(new TheComputerLine(TheComputerLineType.COMMAND, "Booting GNU/Candies system version 4.2... OK"));
            this.addLine(new TheComputerLine(TheComputerLineType.COMMAND, "Initializing the memory stack... OK"));
            this.addLine(new TheComputerLine(TheComputerLineType.COMMAND, "Checking every piece of the system is free software... OK"));
            this.addLine(new TheComputerLine(TheComputerLineType.TEXT, ""));
            this.addLine(new TheComputerLine(TheComputerLineType.CENTER, "Press return to continue"));
            // Set the current computer state
            this.state = TheComputerState.WAITING_FOR_RETURN;
            // The status bar isn't allowed to use the n key anymore
            this.getGame().setIsStatusBarAllowedToUseTheNKey(false);
            // If we didn't add hotkeys yet, we do so
            if (this.hotkeysAdded == false)
                this.addHotkeys();
        }
        // Update
        this.update();
        this.getGame().updatePlace();
    };
    TheComputer.prototype.update = function () {
        // If we have too much lines, delete some of them
        if (this.lines.length > 12) {
            this.lines.splice(0, this.lines.length - 12);
        }
        // If the last line type is COMMAND, we change its text by the current command text
        if (this.lines.length > 0 && this.lines[this.lines.length - 1].getType() == TheComputerLineType.COMMAND) {
            this.lines[this.lines.length - 1].setLinesFromText(this.currentCommandText);
        }
        // Draw
        this.draw();
    };
    return TheComputer;
})(Place);
var TheComputerLine = (function () {
    // Constructor
    function TheComputerLine(type, text) {
        // Set the type
        this.type = type;
        // Set the lines of text depending on the text given in parameter
        this.setLinesFromText(text);
    }
    // Public methods
    TheComputerLine.prototype.draw = function (renderArea, pos, minY) {
        // Draw our lines of text
        for (var i = this.linesOfText.length - 1; i >= 0; i--) {
            // If the line isn't out of the screen
            if (pos.y - (this.linesOfText.length - 1 - i) >= minY) {
                // If our type isn't "CENTER"
                if (this.type != TheComputerLineType.CENTER) {
                    // We draw it
                    renderArea.drawString(this.linesOfText[i], pos.x, pos.y - (this.linesOfText.length - 1 - i));
                }
                else {
                    // We draw it centered
                    renderArea.drawString(this.linesOfText[i], pos.x + 16 - Math.floor(this.linesOfText[i].length / 2), pos.y - (this.linesOfText.length - 1 - i));
                }
            }
        }
        // We return the extra lines we took to draw
        return this.linesOfText.length - 1;
    };
    TheComputerLine.prototype.setLinesFromText = function (text) {
        // Set the first line, empty
        this.linesOfText = [""];
        // Possibly change the text given in parameter, depending on the type
        switch (this.type) {
            case TheComputerLineType.COMMAND:
                text = " > " + text;
                break;
        }
        // Create the array of words
        var words = text.split(" ");
        // Add the words one by one to our lines
        for (var i = 0; i < words.length; i++) {
            // If we can add this word to the line OR the word is way too big to fit in any line anyway
            if (words[i].length + this.linesOfText[this.linesOfText.length - 1].length < 32 || words[i].length > 30) {
                // We add the word
                this.linesOfText[this.linesOfText.length - 1] = this.linesOfText[this.linesOfText.length - 1] + words[i] + " ";
            }
            else {
                // We add a new line
                this.linesOfText.push(words[i] + " ");
            }
        }
    };
    // Public getters
    TheComputerLine.prototype.getType = function () {
        return this.type;
    };
    return TheComputerLine;
})();
var TheComputerLineType;
(function (TheComputerLineType) {
    TheComputerLineType[TheComputerLineType["TEXT"] = 0] = "TEXT";
    TheComputerLineType[TheComputerLineType["COMMAND"] = 1] = "COMMAND";
    TheComputerLineType[TheComputerLineType["CENTER"] = 2] = "CENTER"; // Centered text
})(TheComputerLineType || (TheComputerLineType = {}));
var TheComputerState;
(function (TheComputerState) {
    TheComputerState[TheComputerState["WAITING_FOR_RETURN"] = 0] = "WAITING_FOR_RETURN";
    TheComputerState[TheComputerState["WAITING_FOR_COMMAND"] = 1] = "WAITING_FOR_COMMAND";
})(TheComputerState || (TheComputerState = {}));
///<reference path="Quest.ts"/>
// To know if the player found the chests
Saving.registerBool("theHoleFirstChestFound", false);
Saving.registerBool("theHoleSecondChestFound", false);
Saving.registerBool("theHoleThirdChestFound", false);
Saving.registerBool("theHoleFourthChestFound", false);
var TheHole = (function (_super) {
    __extends(TheHole, _super);
    // Constructor
    function TheHole(game) {
        _super.call(this, game, "You can move with the left and right arrow keys!");
        // Variables which store the open states of the chests for the current quest
        this.firstChestOpened = false;
        this.secondChestOpened = false;
        this.thirdChestOpened = false;
        this.fourthChestOpened = false;
        // A bool to know if the player is going left or right (useful to choose the fireball spell direction)
        // By default we're going right because in most quests the fireball is launched to the right, so it just seems more logical
        // But anyway as soon as the player will press the left key this can change
        this.isGoingRight = true;
        // Resize the quest
        this.resizeQuest(100, 35, new Pos(100, 136));
        // Add collision boxes around
        this.addPlayerCollisionBoxes(true, true, true, true);
        // Add the player
        this.getGame().getPlayer().loadCandyBoxCharacter(this);
        this.getGame().getPlayer().setGlobalPosition(new Pos(48, 0));
        this.configPlayerOrClone(this.getGame().getPlayer());
        this.addEntity(this.getGame().getPlayer());
        // Add the walls
        this.createWalls();
        // Add the spikes
        this.addSpikes(new Spikes(this, new Pos(44, 42), 20));
        this.addSpikes(new Spikes(this, new Pos(23, 59), 22));
        this.addSpikes(new Spikes(this, new Pos(90, 62), 8));
        this.addSpikes(new Spikes(this, new Pos(87, 69), 4));
        this.addSpikes(new Spikes(this, new Pos(94, 69), 4));
        this.addSpikes(new Spikes(this, new Pos(93, 74), 2));
        this.addSpikes(new Spikes(this, new Pos(66, 74), 14));
        this.addSpikes(new Spikes(this, new Pos(66, 82), 4));
        this.addSpikes(new Spikes(this, new Pos(76, 83), 6));
        this.addSpikes(new Spikes(this, new Pos(3, 95), 8));
        this.addSpikes(new Spikes(this, new Pos(13, 97), 10));
        this.addSpikes(new Spikes(this, new Pos(24, 96), 2));
        this.addSpikes(new Spikes(this, new Pos(29, 96), 2));
        this.addSpikes(new Spikes(this, new Pos(33, 95), 12));
        this.addSpikes(new Spikes(this, new Pos(64, 64), 4));
        // Add the chests
        this.addChest(new Chest(this, new Pos(27, 67), true, new CallbackCollection(this.openFirstChest.bind(this)), Saving.loadBool("theHoleFirstChestFound")));
        this.addChest(new Chest(this, new Pos(59, 74), true, new CallbackCollection(this.openSecondChest.bind(this)), Saving.loadBool("theHoleSecondChestFound")));
        this.addChest(new Chest(this, new Pos(37, 107), false, new CallbackCollection(this.openThirdChest.bind(this)), Saving.loadBool("theHoleThirdChestFound")));
        this.addChest(new Chest(this, new Pos(4, 129), true, new CallbackCollection(this.openFourthChest.bind(this)), Saving.loadBool("theHoleFourthChestFound")));
        // Add the lost tribe warrior alone in its room
        this.addLostTribeWarrior(new LostTribeWarrior(this, new Pos(68, 89), new Pos(63, 85), new Pos(93, 95)));
        // Add the lost tribe warriors in the big room
        this.addLostTribeWarrior(new LostTribeWarrior(this, new Pos(14, 126), new Pos(2, 112), new Pos(79, 129)));
        this.addLostTribeWarrior(new LostTribeWarrior(this, new Pos(21, 126), new Pos(2, 112), new Pos(79, 129)));
        this.addLostTribeWarrior(new LostTribeWarrior(this, new Pos(31, 125), new Pos(2, 112), new Pos(79, 129)));
        this.addLostTribeWarrior(new LostTribeWarrior(this, new Pos(51, 123), new Pos(2, 112), new Pos(79, 129)));
        // Add the message
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You jumped into the big hole! You're falling quickly, try to stay alive!"));
    }
    // willBeDisplayed()
    TheHole.prototype.willBeDisplayed = function () {
        // We call the mother willBeDisplayed()
        _super.prototype.willBeDisplayed.call(this);
        // Register hotkeys so that they can't be used by the player's browser
        this.getGame().addHotkey(new Hotkey("left", null));
        this.getGame().addHotkey(new Hotkey("right", null));
    };
    // Public methods
    TheHole.prototype.castPlayerFireball = function () {
        // If we're going right, we cast a fireball going right ; if we're going left, we cast a fireball going left
        if (this.isGoingRight)
            _super.prototype.castPlayerFireball.call(this, new Pos(2, 0));
        else
            _super.prototype.castPlayerFireball.call(this, new Pos(-2, 0));
    };
    TheHole.prototype.castPlayerTeleport = function () {
        _super.prototype.castPlayerTeleport.call(this, new Pos(48, 0), new Pos(1, 1));
    };
    TheHole.prototype.configPlayerOrClone = function (entity) {
        entity.setQuestEntityMovement(new QuestEntityMovement());
        entity.getQuestEntityMovement().setGravity(true);
        entity.getQuestEntityMovement().setWormsLike(true);
    };
    TheHole.prototype.endQuest = function (win) {
        if (win) {
            // We add the message
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You managed to reach the bottom of the hole!"));
        }
        else {
            // We add the message
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You died while falling in the hole. No one will probably ever find your body down there."));
        }
        // We call the endQuest method of our mother class
        _super.prototype.endQuest.call(this, win);
        // If we won, we possibly confirm the opening of some of the chests, depending on our variables
        if (win) {
            if (this.firstChestOpened)
                Saving.saveBool("theHoleFirstChestFound", true);
            if (this.secondChestOpened)
                Saving.saveBool("theHoleSecondChestFound", true);
            if (this.thirdChestOpened)
                Saving.saveBool("theHoleThirdChestFound", true);
            if (this.fourthChestOpened)
                Saving.saveBool("theHoleFourthChestFound", true);
        }
    };
    TheHole.prototype.update = function () {
        if (this.getQuestEnded() == false) {
            // Test if the player won the quest, if so, end the quest and return
            if (this.thePlayerWon()) {
                this.endQuest(true);
                return;
            }
            // Test if the player is dead, if so, end the quest and return
            if (this.getGame().getPlayer().shouldDie()) {
                this.endQuest(false);
                return;
            }
            // Move the player horizontally
            this.moveHorizontally();
            // Update entities
            this.updateEntities();
            // Calculate the new global drawing offset
            this.calcNewGlobalDrawingOffset();
        }
        // Draw
        this.preDraw();
        this.getRenderArea().drawArray(Database.getPartOfAscii("places/quests/theHole/background", -this.getGlobalDrawingOffset().y, -this.getGlobalDrawingOffset().y + 35), this.getRealQuestPosition().x, this.getRealQuestPosition().y);
        this.drawEntities();
        this.drawAroundQuest();
        if (this.getQuestEnded() == false)
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestNoKeeping");
        else if (this.getQuestEndedAndWeWon() == false)
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestNoKeepingBecauseLose");
        else
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestKeeping");
        this.postDraw();
    };
    // Private methods
    TheHole.prototype.addChest = function (chest) {
        this.addEntity(chest);
    };
    TheHole.prototype.addLostTribeWarrior = function (lostTribeWarrior) {
        lostTribeWarrior.setHealthBar(new QuestEntityHealthBar(lostTribeWarrior, new Pos(4, 1)));
        this.addEntity(lostTribeWarrior);
    };
    TheHole.prototype.addSpikes = function (spikes) {
        this.addEntity(spikes);
    };
    TheHole.prototype.addWalls = function () {
        var positions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            positions[_i - 0] = arguments[_i];
        }
        // Create the wall entity
        this.addEntity(new Wall(this, new Pos(0, 0)));
        var wall = (this.getLastEntity());
        // Add the boxes
        for (var i = 0; i < positions.length / 4; i++) {
            wall.addBox(new Pos(positions[i * 4], positions[i * 4 + 1]), new Pos(positions[i * 4 + 2] - positions[i * 4] + 1, positions[i * 4 + 3] - positions[i * 4 + 1] + 1));
        }
    };
    TheHole.prototype.calcNewGlobalDrawingOffset = function () {
        // If the player is too low or too high on the screen (that's why we take the offset in account here), we set the offset to follow the player
        if (this.getGame().getPlayer().getGlobalPosition().y + this.getGlobalDrawingOffset().y > 10)
            this.setGlobalDrawingOffset(new Pos(0, -this.getGame().getPlayer().getGlobalPosition().y + 10));
        else if (this.getGame().getPlayer().getGlobalPosition().y + this.getGlobalDrawingOffset().y < 5) {
            if (this.getGame().getPlayer().getGlobalPosition().y > 5)
                this.setGlobalDrawingOffset(new Pos(0, -this.getGame().getPlayer().getGlobalPosition().y + 5));
            else
                this.setGlobalDrawingOffset(new Pos(0, 0));
        }
    };
    TheHole.prototype.createWalls = function () {
        // Yes, I know that the code below is quite ugly
        // But I had two choices : either write the bounding boxes manually (this is what I chose)
        // Or write a specific level editor to do the work for me (it could work with something like the height maps in 3d games - there would be a second "ascii art" composed of 0 and 1 for example, 0 would mean no collision and 1 would mean collision)
        // But this is the only level which requires such complicated bounding boxes, so really, writing a level editor for one level isn't worth it
        this.addWalls(0, 0, 40, 22, 0, 23, 39, 23, 0, 24, 38, 24, 0, 25, 37, 25, 0, 26, 36, 26, 0, 27, 33, 27, 0, 28, 32, 28, 0, 29, 31, 29, 0, 30, 30, 30, 0, 31, 29, 31, 0, 32, 28, 32, 0, 33, 27, 33, 0, 34, 26, 34, 0, 35, 25, 35, 0, 36, 24, 36, 0, 37, 23, 37, 0, 38, 22, 59, 0, 60, 44, 60, 0, 61, 43, 61, 0, 62, 27, 62, 34, 62, 38, 62, 0, 63, 26, 63, 0, 64, 25, 66, 0, 67, 26, 67, 0, 68, 33, 68, 0, 69, 32, 69, 0, 70, 31, 70, 0, 71, 27, 71, 0, 72, 26, 72, 0, 73, 25, 73, 0, 74, 24, 74, 0, 75, 16, 75, 0, 76, 15, 76, 0, 77, 4, 77, 0, 78, 3, 80, 0, 81, 2, 81, 0, 82, 1, 95, 36, 73, 39, 73, 35, 74, 40, 74, 34, 75, 41, 75, 33, 76, 49, 76, 32, 77, 49, 77, 32, 78, 49, 78, 33, 79, 49, 79, 34, 80, 49, 80, 35, 81, 49, 81, 36, 82, 49, 82, 37, 83, 49, 85, 37, 86, 49, 86, 38, 87, 50, 87, 39, 88, 51, 88, 45, 89, 52, 89, 46, 90, 54, 90, 47, 91, 54, 94, 46, 95, 54, 95, 0, 96, 11, 96, 32, 96, 54, 96, 0, 97, 12, 97, 23, 97, 26, 97, 28, 97, 54, 97, 0, 98, 26, 101, 28, 98, 54, 101, 0, 102, 26, 102, 28, 102, 57, 102, 0, 103, 23, 103, 35, 103, 65, 103, 0, 104, 20, 104, 36, 104, 69, 104, 0, 105, 19, 105, 41, 105, 74, 105, 0, 106, 18, 106, 41, 106, 87, 106, 0, 107, 17, 109, 40, 107, 87, 107, 29, 108, 87, 108, 28, 109, 87, 109, 0, 110, 18, 110, 27, 110, 68, 110, 0, 111, 57, 111, 0, 112, 39, 112, 0, 113, 30, 113, 0, 114, 8, 114, 0, 115, 7, 115, 0, 116, 6, 116, 0, 117, 5, 119, 0, 120, 4, 120, 0, 121, 3, 121, 0, 122, 2, 128, 0, 129, 3, 129, 79, 112, 87, 112, 78, 113, 87, 113, 77, 114, 87, 114, 76, 115, 87, 115, 75, 116, 87, 116, 74, 117, 87, 117, 73, 118, 87, 118, 71, 119, 87, 119, 70, 120, 87, 120, 69, 121, 87, 121, 68, 122, 87, 122, 66, 123, 87, 123, 64, 124, 87, 124, 61, 125, 87, 125, 56, 126, 87, 126, 50, 127, 86, 127, 41, 128, 85, 128, 27, 129, 84, 129, 0, 130, 79, 130, 0, 131, 72, 131, 0, 132, 71, 132, 0, 133, 70, 134, 0, 135, 100, 135, 59, 0, 100, 24, 60, 25, 100, 25, 61, 26, 100, 26, 62, 27, 100, 27, 63, 28, 100, 28, 64, 29, 100, 42, 44, 43, 100, 43, 45, 44, 100, 44, 46, 45, 100, 45, 50, 46, 100, 46, 57, 47, 100, 47, 69, 48, 100, 48, 70, 49, 100, 49, 75, 50, 100, 50, 84, 51, 100, 51, 85, 52, 100, 52, 92, 53, 100, 53, 93, 54, 100, 54, 83, 55, 89, 55, 94, 55, 100, 55, 82, 56, 88, 56, 94, 56, 100, 56, 81, 57, 87, 57, 94, 57, 100, 57, 77, 58, 86, 58, 95, 58, 100, 58, 76, 59, 86, 59, 96, 59, 100, 59, 75, 60, 86, 60, 97, 60, 100, 60, 71, 61, 86, 61, 98, 61, 100, 69, 90, 63, 98, 63, 70, 62, 86, 62, 69, 63, 86, 63, 59, 64, 63, 64, 68, 64, 86, 64, 58, 65, 86, 65, 53, 66, 86, 66, 52, 67, 86, 67, 51, 68, 86, 68, 46, 69, 86, 69, 45, 70, 90, 70, 94, 70, 100, 70, 45, 71, 60, 71, 82, 71, 89, 71, 95, 71, 100, 74, 51, 72, 58, 72, 52, 73, 57, 73, 53, 74, 58, 74, 54, 75, 100, 75, 55, 76, 100, 77, 55, 78, 62, 78, 75, 78, 100, 78, 55, 79, 59, 79, 87, 79, 100, 79, 88, 80, 100, 80, 89, 81, 100, 81, 90, 82, 100, 82, 53, 83, 75, 83, 91, 83, 100, 83, 54, 84, 87, 84, 92, 84, 100, 84, 55, 85, 87, 85, 93, 85, 100, 95, 59, 86, 86, 86, 60, 87, 78, 87, 60, 88, 66, 88, 59, 89, 64, 89, 58, 90, 63, 91, 58, 92, 64, 92, 58, 93, 73, 93, 58, 94, 78, 94, 58, 95, 83, 95, 58, 96, 100, 97, 59, 98, 100, 98, 60, 99, 100, 99, 71, 100, 100, 100, 82, 101, 100, 101, 92, 102, 100, 103, 91, 104, 100, 129, 90, 130, 100, 130, 89, 131, 100, 131, 88, 132, 100, 132, 85, 133, 100, 133, 78, 134, 100, 134);
    };
    TheHole.prototype.openFirstChest = function () {
        this.firstChestOpened = true;
        this.foundGridOrEqItem(new QuestItemFound(this, "gridItemPossessedHeartPendant", "You opened a chest and found a heart pendant!", "You gain a heart pendant."));
    };
    TheHole.prototype.openFourthChest = function () {
        this.fourthChestOpened = true;
        this.foundChocolateBars(4);
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You opened a chest and found four chocolate bars!", null, true));
    };
    TheHole.prototype.openSecondChest = function () {
        this.secondChestOpened = true;
        this.foundGridOrEqItem(new QuestItemFound(this, "gridItemPossessedFortressKey", "You opened a chest and found the desert fortress key!", "You gain the desert fortress key."));
    };
    TheHole.prototype.openThirdChest = function () {
        this.thirdChestOpened = true;
        this.foundGridOrEqItem(new QuestItemFound(this, "gridItemPossessedBlackMagicGrimoire", "You opened a chest and found a grimoire!", "You gain a black magic grimoire."));
    };
    TheHole.prototype.moveHorizontally = function () {
        var leftPressed = Keyboard.isKeyPressed("left");
        var rightPressed = Keyboard.isKeyPressed("right");
        if (leftPressed && !rightPressed) {
            this.getGame().getPlayer().move(new Pos(-1, 0));
            this.isGoingRight = false;
        }
        else if (rightPressed && !leftPressed) {
            this.getGame().getPlayer().move(new Pos(1, 0));
            this.isGoingRight = true;
        }
    };
    TheHole.prototype.thePlayerWon = function () {
        // If the player reached the bottom of the hole
        if (this.getGame().getPlayer().getGlobalPosition().y >= 134)
            return true;
        return false;
    };
    return TheHole;
})(Quest);
///<reference path="Quest.ts"/>
var TheSea = (function (_super) {
    __extends(TheSea, _super);
    // Constructor
    function TheSea(game) {
        _super.call(this, game, "You can move with the down and up arrow keys!");
        // Floors
        this.floors = [];
        // Generation projection (how many characters the player doesn't already see should we generate)
        this.generationProjection = 10;
        // The distance we've swimed so far
        this.distance = 0;
        // Min and max floor height
        this.floorMinHeight = 3;
        this.floorMaxHeight = 8;
        // Patterns stuff
        this.currentPattern = null;
        this.currentPatternLevel = null;
        // Last player movement
        this.lastPlayerMovement = new Pos(0, 0);
        // Did we already generate a sponge? Shell powder?
        this.spongeGenerated = false;
        this.shellPowderGenerated = false;
        // Resize the quest
        this.resizeQuest(100, 30);
        // Add collision boxes around
        this.addPlayerCollisionBoxes(true, false, true, true);
        // Gravity is disabled
        this.setGravityDisabled(true);
        this.setWormsLikeDisabled(true);
        // Add the player
        this.getGame().getPlayer().loadMediumCharacter(this);
        this.getGame().getPlayer().setGlobalPosition(new Pos(0, 5));
        this.configPlayerOrClone(this.getGame().getPlayer());
        this.addEntity(this.getGame().getPlayer());
        // Fill the floors array with null values
        for (var i = 0; i <= 99 + this.generationProjection; i++) {
            this.floors.push(null);
        }
        // Generate for the first time
        this.generate(0, 99 + this.generationProjection);
        // Add the message
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You jump into the sea! You know you could find precious hidden treasures in the depths..."));
    }
    // willBeDisplayed()
    TheSea.prototype.willBeDisplayed = function () {
        // We call the mother willBeDisplayed()
        _super.prototype.willBeDisplayed.call(this);
        // Register hotkeys so that they can't be used by the player's browser
        this.getGame().addHotkey(new Hotkey("up", null));
        this.getGame().addHotkey(new Hotkey("down", null));
    };
    // Public methods
    TheSea.prototype.addBigShark = function (pos) {
        var bigShark = new BigShark(this, pos);
        bigShark.setHealthBar(new QuestEntityHealthBar(bigShark, new Pos(47, 1)));
        if (this.addEntity(bigShark))
            return bigShark; // We return it
        return null; // Else, we return null
    };
    TheSea.prototype.addJellyFish = function (pos) {
        var jellyFish = new JellyFish(this, pos);
        jellyFish.setHealthBar(new QuestEntityHealthBar(jellyFish, new Pos(6, 1), new Pos(0, 0)));
        if (this.addEntity(jellyFish))
            return jellyFish; // We return it
        return null; // Else, we return null
    };
    TheSea.prototype.addMediumFish = function (pos) {
        var mediumFish = new MediumFish(this, pos);
        mediumFish.setHealthBar(new QuestEntityHealthBar(mediumFish, new Pos(8, 1), new Pos(0, 0)));
        if (this.addEntity(mediumFish))
            return mediumFish; // We return it
        return null; // Else, we return null
    };
    TheSea.prototype.addMiniShark = function (pos) {
        var miniShark = new MiniShark(this, pos);
        miniShark.setHealthBar(new QuestEntityHealthBar(miniShark, new Pos(19, 1)));
        if (this.addEntity(miniShark))
            return miniShark; // We return it
        return null; // Else, we return null
    };
    TheSea.prototype.addSeahorse = function (pos, intendedXPosition) {
        var seahorse = new Seahorse(this, pos, intendedXPosition);
        seahorse.setHealthBar(new QuestEntityHealthBar(seahorse, new Pos(4, 1)));
        if (this.addEntity(seahorse))
            return seahorse; // We return it
        return null; // Else, we return null
    };
    TheSea.prototype.addSeaSnake = function (pos) {
        var seaSnake = new SeaSnake(this, pos);
        if (this.addEntity(seaSnake))
            return seaSnake; // We return it
        return null; // Else we return null
    };
    TheSea.prototype.addSmallestFish = function (pos) {
        var smallestFish = new SmallestFish(this, pos);
        smallestFish.setHealthBar(new QuestEntityHealthBar(smallestFish, new Pos(3, 1)));
        if (this.addEntity(smallestFish))
            return smallestFish; // We return it
        return null; // Else, we return null
    };
    TheSea.prototype.castJump = function () { }; // We can't jump in the sea !
    TheSea.prototype.castPlayerAcidRain = function () {
        // We cast from 0 to 100, not strictly around the player as usual
        _super.prototype.castPlayerAcidRain.call(this, null, null, 0, 100);
    };
    TheSea.prototype.castPlayerTeleport = function () {
        // We teleport, be we stay on the left side of the quest
        _super.prototype.castPlayerTeleport.call(this, new Pos(0, 0), new Pos(0, this.getRealQuestSize().y - 1));
    };
    TheSea.prototype.configPlayerOrClone = function (entity) {
        entity.setQuestEntityMovement(new QuestEntityMovement(new Pos(1, 0)));
        entity.getQuestEntityMovement().setGravity(false);
        entity.getQuestEntityMovement().setWormsLike(false);
    };
    TheSea.prototype.endQuest = function (win) {
        // Variable used to generate the winning message
        var comment;
        // We add some messages
        if (win) {
            switch (Random.between(0, 8)) {
                case 0:
                    comment = "by jumping on a jellyfish";
                    break;
                case 1:
                    comment = "by hanging onto a sea turtle";
                    break;
                case 2:
                    comment = "by following a dolphin";
                    break;
                case 3:
                    comment = "(you don't know how)";
                    break;
                case 4:
                    comment = "by hanging onto a shark's fin";
                    break;
                case 5:
                    comment = "by following a whale";
                    break;
                case 6:
                    comment = "by following a squid";
                    break;
                case 7:
                    comment = "by asking your way to a shrimp";
                    break;
                case 8:
                    comment = "thanks to some updrafts";
                    break;
            }
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You almost died in the sea but managed to get to the surface in time " + comment + "."));
        }
        else {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You died in the sea."));
        }
        // We call the endQuest method of our mother class
        _super.prototype.endQuest.call(this, win);
    };
    // getLeftLimit()
    TheSea.prototype.getLeftLimit = function () {
        return 100;
    };
    TheSea.prototype.update = function () {
        if (this.getQuestEnded() == false) {
            // Test if the player is dead, if so, end the quest (he won!!) and return
            if (this.getGame().getPlayer().shouldDie()) {
                this.endQuest(true); // true because we always win
                return;
            }
            // Add some enemies
            this.handlePatterns(100, 115);
            // Move the player vertically
            this.moveVertically();
            // Update entities
            this.updateEntities();
            // Force scrolling of everything
            this.globalScrolling();
        }
        // Draw
        this.preDraw();
        this.drawSea();
        this.drawEntities();
        this.drawAroundQuest();
        this.addExitQuestButton(new CallbackCollection(this.endQuest.bind(this, true), this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestKeeping");
        this.postDraw();
    };
    // Public getters
    TheSea.prototype.getDistance = function () {
        return this.distance;
    };
    TheSea.prototype.getFloorMaxHeight = function () {
        return this.floorMaxHeight;
    };
    TheSea.prototype.getFloorMinHeight = function () {
        return this.floorMinHeight;
    };
    TheSea.prototype.getLastPlayerMovement = function () {
        return this.lastPlayerMovement;
    };
    TheSea.prototype.getRightLimit = function () {
        return 70;
    };
    // Private methods    
    TheSea.prototype.addFloor = function (index, type, height, previousFloor) {
        if (previousFloor === void 0) { previousFloor = null; }
        // Add the floor
        this.floors[index] = new TheSeaFloor(type, height, previousFloor);
        // If the type is normal
        if (type == TheSeaFloorType.NORMAL)
            this.addFloorCollisionBox(new Pos(index, this.getRealQuestSize().y - (height - 1)), new Pos(1, height - 1)); // Add a floor collision box at height - 1
        else
            this.addFloorCollisionBox(new Pos(index, this.getRealQuestSize().y - height), new Pos(1, height)); // Add a floor collision box at height
    };
    TheSea.prototype.addFloorCollisionBox = function (pos, size) {
        var wall = new Wall(this, pos);
        wall.addBox(new Pos(0, 0), size);
        this.addEntity(wall);
    };
    TheSea.prototype.drawFloors = function () {
        for (var i = 0; i <= 99; i++) {
            if (this.floors[i] != null) {
                this.floors[i].draw(this.getRenderArea(), this.getRealQuestPosition().y + this.getRealQuestSize().y, i);
            }
        }
    };
    TheSea.prototype.drawSea = function () {
        this.drawFloors();
    };
    TheSea.prototype.generate = function (x1, x2) {
        this.generateFloors(x1, x2);
        this.generateShellPowder(x1, x2);
        this.generateSponge(x1, x2);
        this.generatePlants(x1, x2);
    };
    TheSea.prototype.generateFloors = function (x1, x2) {
        // Create variables which will be useful
        var type;
        for (var i = x1; i <= x2; i++) {
            // If we're placing the first floor
            if (i == 0) {
                // We place it at a random height and with the normal type
                this.addFloor(i, TheSeaFloorType.NORMAL, Random.between(this.floorMinHeight, this.floorMaxHeight));
            }
            else {
                // Init the variables
                type = null;
                // If we want to keep the same type and it's possible to do so
                if (Random.oneChanceOutOf(15 - this.floors[i - 1].getHowManyFloorsOfTheSameTypeBefore()) == false && ((this.floors[i - 1].getType() == TheSeaFloorType.NORMAL) ||
                    (this.floors[i - 1].getType() == TheSeaFloorType.GOING_DOWN && this.floors[i - 1].getHeight() > this.floorMinHeight) ||
                    (this.floors[i - 1].getType() == TheSeaFloorType.GOING_UP && this.floors[i - 1].getHeight() < this.floorMaxHeight) // We want to keep going up and we're not too high : no problem
                )) {
                    // We will keep the same type as the previous floor
                    type = this.floors[i - 1].getType();
                }
                else {
                    // If the previous floor has a normal type
                    if (this.floors[i - 1].getType() == TheSeaFloorType.NORMAL) {
                        if (this.floors[i - 1].getHeight() == this.floorMinHeight)
                            type = TheSeaFloorType.GOING_UP; // If the previous floor was too low, we must go up
                        else if (this.floors[i - 1].getHeight() >= this.floorMaxHeight - 1)
                            type = TheSeaFloorType.GOING_DOWN; // If the previous floor was too high, we must go down
                        else {
                            // Else, we pick randomly the new type
                            if (Random.flipACoin())
                                type = TheSeaFloorType.GOING_UP;
                            else
                                type = TheSeaFloorType.GOING_DOWN;
                        }
                    }
                    else {
                        type = TheSeaFloorType.NORMAL;
                    }
                }
                // Create the floor from the type decided before
                switch (type) {
                    case TheSeaFloorType.NORMAL:
                        if (this.floors[i - 1].getType() == TheSeaFloorType.GOING_UP)
                            this.addFloor(i, TheSeaFloorType.NORMAL, this.floors[i - 1].getHeight() + 1, this.floors[i - 1]);
                        else
                            this.addFloor(i, TheSeaFloorType.NORMAL, this.floors[i - 1].getHeight(), this.floors[i - 1]);
                        break;
                    case TheSeaFloorType.GOING_DOWN:
                        this.addFloor(i, TheSeaFloorType.GOING_DOWN, this.floors[i - 1].getHeight() - 1, this.floors[i - 1]);
                        break;
                    case TheSeaFloorType.GOING_UP:
                        if (this.floors[i - 1].getType() == TheSeaFloorType.NORMAL)
                            this.addFloor(i, TheSeaFloorType.GOING_UP, this.floors[i - 1].getHeight(), this.floors[i - 1]);
                        else
                            this.addFloor(i, TheSeaFloorType.GOING_UP, this.floors[i - 1].getHeight() + 1, this.floors[i - 1]);
                        break;
                }
            }
        }
    };
    TheSea.prototype.generatePlants = function (x1, x2) {
        // Set some parameters important for the generation
        var minPlantNumber = 0;
        var maxPlantNumber = 10;
        // Create some variables which will be useful
        var thereIsAlreadyAPlant;
        // Iterate over newly generated floors, searching for one which could receive a plant
        for (var i = x1; i <= x2; i++) {
            if (Random.oneChanceOutOf(3) &&
                i >= 4 &&
                this.floors[i].getType() == TheSeaFloorType.NORMAL &&
                this.floors[i].getHowManyFloorsOfTheSameTypeBefore() >= 4 // And there's at least 4 floors of the same type before
            ) {
                // Init the variable
                thereIsAlreadyAPlant = false;
                // Check if there is already a plant
                for (var j = i - 4; j <= i; j++) {
                    // If this floor already has a plant on it
                    if (this.floors[j].getHasAPlant() == true) {
                        thereIsAlreadyAPlant = true;
                        break;
                    }
                }
                // We add a plant here if there isn't already a plant on one of the floors
                if (thereIsAlreadyAPlant == false) {
                    // We add the plant
                    this.addEntity(new Plant(this, new Pos(i - 4, this.getRealQuestSize().y - this.floors[i].getHeight()), minPlantNumber, maxPlantNumber));
                    // We inform the floors that they now have a plant on them
                    for (var j = i - 4; j <= i; j++) {
                        this.floors[j].setHasAPlant(true);
                    }
                }
            }
        }
    };
    TheSea.prototype.generateShellPowder = function (x1, x2) {
        // If we don't already have shell powder and no shell powder have been generated in this quest so far and the distance is at least 500
        if (Saving.loadBool("gridItemPossessedShellPowder") == false && this.shellPowderGenerated == false && this.distance >= 500) {
            // Iterate over newly generated floors, searching for one which could receive the powder
            for (var i = x1; i <= x2; i++) {
                if (i >= 6 &&
                    this.floors[i].getType() == TheSeaFloorType.NORMAL &&
                    this.floors[i].getHowManyFloorsOfTheSameTypeBefore() >= 6 // And there's at least 6 floors of the same type before
                ) {
                    // Check if there is already a plant, if so return
                    for (var j = i - 6; j <= i; j++) {
                        // If this floor already has a plant on it, return
                        if (this.floors[j].getHasAPlant() == true)
                            return;
                    }
                    // Add the powder and change the shellPowderGenerated bool
                    this.shellPowderGenerated = true;
                    this.addEntity(new ShellPowder(this, new Pos(i - 6, this.getRealQuestSize().y - this.floors[i].getHeight())));
                    this.getLastEntity().setHealthBar(new QuestEntityHealthBar(this.getLastEntity(), new Pos(6, 1)));
                    // Inform the floors that they now have a plant on them
                    for (var j = i - 6; j <= i; j++) {
                        this.floors[j].setHasAPlant(true);
                    }
                }
            }
        }
    };
    TheSea.prototype.generateSponge = function (x1, x2) {
        // If we don't already have a sponge and no sponge have been generated in this quest so far and the distance is at least 793
        if (Saving.loadBool("gridItemPossessedSponge") == false && this.spongeGenerated == false && this.distance >= 793) {
            // Iterate over newly generated floors, searching for one which could receive a sponge
            for (var i = x1; i <= x2; i++) {
                if (i >= 6 &&
                    this.floors[i].getType() == TheSeaFloorType.NORMAL &&
                    this.floors[i].getHowManyFloorsOfTheSameTypeBefore() >= 6 // And there's at least 6 floors of the same type before
                ) {
                    // Check if there is already a plant, if so return
                    for (var j = i - 6; j <= i; j++) {
                        // If this floor already has a plant on it, return
                        if (this.floors[j].getHasAPlant() == true)
                            return;
                    }
                    // Add the sponge and change the spongeGenerated bool
                    this.spongeGenerated = true;
                    this.addEntity(new Sponge(this, new Pos(i - 6, this.getRealQuestSize().y - this.floors[i].getHeight())));
                    this.getLastEntity().setHealthBar(new QuestEntityHealthBar(this.getLastEntity(), new Pos(6, 1)));
                    // Inform the floors that they now have a plant on them (well, actually its a sponge, but these "animals" looks kind of like plants, so don't worry about that)
                    for (var j = i - 6; j <= i; j++) {
                        this.floors[j].setHasAPlant(true);
                    }
                }
            }
        }
    };
    TheSea.prototype.globalScrolling = function () {
        // How much do we have to scroll ?
        var scrollingXOffset = -(this.getGame().getPlayer().getCharacterType() == PlayerCharacterType.MEDIUM ? this.getGame().getPlayer().getGlobalPosition().x : this.getGame().getPlayer().getGlobalPosition().x - 2);
        // If we should scroll
        if (scrollingXOffset < 0) {
            // Set the x last player movement
            this.lastPlayerMovement.x = -scrollingXOffset;
            // Increase the distance
            this.distance += -scrollingXOffset;
            // Scroll entities
            this.forceMovingAllEntities(new Pos(scrollingXOffset, 0));
            // Scroll the floor
            this.scrollFloor(-scrollingXOffset);
            // Generate new things to fill the new area
            this.generate(100 + scrollingXOffset + this.generationProjection, 99 + this.generationProjection);
        }
        else {
            // Set the x last player movement
            this.lastPlayerMovement.x = 0;
        }
    };
    TheSea.prototype.handlePatterns = function (x1, x2) {
        // If the pattern is null or done, we need a new pattern
        if (this.currentPattern == null || this.currentPattern.isPatternDone()) {
            // If the level is null, we begin with level 0
            if (this.currentPatternLevel == null)
                this.currentPatternLevel = new TheSeaPatternLevel_Level0(this);
            else if (this.currentPatternLevel.isLevelDone())
                this.currentPatternLevel = this.currentPatternLevel.getNextLevel();
            // We get the new pattern from the current level
            this.currentPattern = this.currentPatternLevel.getPattern(this.distance);
        }
        // We run the pattern
        this.currentPattern.run(x1, x2);
    };
    TheSea.prototype.moveVertically = function () {
        var upPressed = Keyboard.isKeyPressed("up");
        var downPressed = Keyboard.isKeyPressed("down");
        if (upPressed && !downPressed) {
            this.getGame().getPlayer().move(new Pos(0, -1));
            this.lastPlayerMovement.y = -1;
        }
        else if (downPressed && !upPressed) {
            this.getGame().getPlayer().move(new Pos(0, 1));
            this.lastPlayerMovement.y = 1;
        }
    };
    TheSea.prototype.scrollFloor = function (howMany) {
        for (var i = howMany; i <= 99 + this.generationProjection; i++) {
            this.floors[i - howMany] = this.floors[i];
        }
    };
    return TheSea;
})(Quest);
var TheSeaFloor = (function () {
    // Constructor
    function TheSeaFloor(type, height, previousFloor) {
        if (previousFloor === void 0) { previousFloor = null; }
        // Does this floor have a plant on it ?
        this.hasAPlant = false;
        this.type = type;
        this.height = height;
        // If the previous floor is null or has a different type
        if (previousFloor == null || previousFloor.getType() != this.type) {
            // There's no floor of the same type before
            this.howManyFloorsOfTheSameTypeBefore = 0;
        }
        else {
            // We take the howManyFloorsOfTheSameTypeBefore of the previous floor and we add one
            this.howManyFloorsOfTheSameTypeBefore = previousFloor.howManyFloorsOfTheSameTypeBefore + 1;
        }
        // Special character stuff
        if (Random.oneChanceOutOf(3) && (previousFloor == null || previousFloor.getHasSpecialCharacter() == false)) {
            // We will have a special character
            this.hasSpecialCharacter = true;
            // Set the height
            this.specialCharacterHeight = Random.between(0, this.height - 1);
            // Set the character
            if (Random.oneChanceOutOf(4)) {
                this.specialCharacter = "^";
            }
            else {
                this.specialCharacter = "-";
            }
        }
        else {
            // We won't have a special character
            this.hasSpecialCharacter = false;
        }
    }
    // Public methods
    TheSeaFloor.prototype.draw = function (renderArea, floorPosition, xPosition) {
        // We can draw different characters for the floor, depending on the type
        switch (this.type) {
            case TheSeaFloorType.NORMAL:
                renderArea.drawString("_", xPosition, floorPosition - this.height);
                break;
            case TheSeaFloorType.GOING_DOWN:
                renderArea.drawString("\\", xPosition, floorPosition - this.height);
                break;
            case TheSeaFloorType.GOING_UP:
                renderArea.drawString("/", xPosition, floorPosition - this.height);
                break;
        }
        // If we have a special character
        if (this.hasSpecialCharacter) {
            // We draw it
            renderArea.drawString(this.specialCharacter, xPosition, floorPosition - this.specialCharacterHeight);
        }
    };
    // Pubic getters
    TheSeaFloor.prototype.getHasAPlant = function () {
        return this.hasAPlant;
    };
    TheSeaFloor.prototype.getHasSpecialCharacter = function () {
        return this.hasSpecialCharacter;
    };
    TheSeaFloor.prototype.getHeight = function () {
        return this.height;
    };
    TheSeaFloor.prototype.getHowManyFloorsOfTheSameTypeBefore = function () {
        return this.howManyFloorsOfTheSameTypeBefore;
    };
    TheSeaFloor.prototype.getType = function () {
        return this.type;
    };
    // Public setters
    TheSeaFloor.prototype.setHasAPlant = function (hasAPlant) {
        this.hasAPlant = hasAPlant;
    };
    return TheSeaFloor;
})();
var TheSeaFloorType;
(function (TheSeaFloorType) {
    TheSeaFloorType[TheSeaFloorType["NORMAL"] = 0] = "NORMAL";
    TheSeaFloorType[TheSeaFloorType["GOING_DOWN"] = 1] = "GOING_DOWN";
    TheSeaFloorType[TheSeaFloorType["GOING_UP"] = 2] = "GOING_UP";
})(TheSeaFloorType || (TheSeaFloorType = {}));
var TheSeaPattern = (function () {
    // Constructor
    function TheSeaPattern(theSea, initialDistance) {
        this.theSea = theSea;
        this.initialDistance = initialDistance;
    }
    // Public methods
    TheSeaPattern.prototype.isPatternDone = function () {
        return false;
    };
    TheSeaPattern.prototype.run = function (x1, x2) {
    };
    // Public getters
    TheSeaPattern.prototype.getInitialDistance = function () {
        return this.initialDistance;
    };
    TheSeaPattern.prototype.getTheSea = function () {
        return this.theSea;
    };
    return TheSeaPattern;
})();
var TheSeaPatternLevel = (function () {
    // Constructor
    function TheSeaPatternLevel(theSea) {
        // How many patterns launched already ?
        this.howManyPatterns = 0;
        this.theSea = theSea;
    }
    // Public methods
    TheSeaPatternLevel.prototype.getNextLevel = function () {
        return new TheSeaPatternLevel(this.theSea);
    };
    TheSeaPatternLevel.prototype.getPattern = function (initialDistance) {
        return new TheSeaPattern(this.theSea, initialDistance);
    };
    TheSeaPatternLevel.prototype.increaseHowManyPatterns = function () {
        this.howManyPatterns += 1;
    };
    TheSeaPatternLevel.prototype.isLevelDone = function () {
        return false;
    };
    // Public getters
    TheSeaPatternLevel.prototype.getHowManyPatterns = function () {
        return this.howManyPatterns;
    };
    TheSeaPatternLevel.prototype.getTheSea = function () {
        return this.theSea;
    };
    return TheSeaPatternLevel;
})();
///<reference path="TheSeaPatternLevel.ts"/>
var TheSeaPatternLevel_Boss0 = (function (_super) {
    __extends(TheSeaPatternLevel_Boss0, _super);
    // Constructor
    function TheSeaPatternLevel_Boss0(theSea) {
        _super.call(this, theSea);
    }
    // Public methods
    TheSeaPatternLevel_Boss0.prototype.getNextLevel = function () {
        return new TheSeaPatternLevel_Level1(this.getTheSea());
    };
    TheSeaPatternLevel_Boss0.prototype.getPattern = function (initialDistance) {
        this.increaseHowManyPatterns();
        return new TheSeaPattern_Boss0_Shapes(this.getTheSea(), initialDistance);
    };
    TheSeaPatternLevel_Boss0.prototype.isLevelDone = function () {
        if (this.getHowManyPatterns() >= 1)
            return true;
        return false;
    };
    return TheSeaPatternLevel_Boss0;
})(TheSeaPatternLevel);
///<reference path="TheSeaPatternLevel.ts"/>
var TheSeaPatternLevel_Boss1 = (function (_super) {
    __extends(TheSeaPatternLevel_Boss1, _super);
    // Constructor
    function TheSeaPatternLevel_Boss1(theSea) {
        _super.call(this, theSea);
    }
    // Public methods
    TheSeaPatternLevel_Boss1.prototype.getNextLevel = function () {
        return new TheSeaPatternLevel_Level2(this.getTheSea());
    };
    TheSeaPatternLevel_Boss1.prototype.getPattern = function (initialDistance) {
        this.increaseHowManyPatterns();
        return new TheSeaPattern_Boss1_Seahorses(this.getTheSea(), initialDistance);
    };
    TheSeaPatternLevel_Boss1.prototype.isLevelDone = function () {
        if (this.getHowManyPatterns() >= 1)
            return true;
        return false;
    };
    return TheSeaPatternLevel_Boss1;
})(TheSeaPatternLevel);
///<reference path="TheSeaPatternLevel.ts"/>
var TheSeaPatternLevel_Level0 = (function (_super) {
    __extends(TheSeaPatternLevel_Level0, _super);
    // Constructor
    function TheSeaPatternLevel_Level0(theSea) {
        _super.call(this, theSea);
    }
    // Public methods
    TheSeaPatternLevel_Level0.prototype.getNextLevel = function () {
        return new TheSeaPatternLevel_Boss0(this.getTheSea());
    };
    TheSeaPatternLevel_Level0.prototype.getPattern = function (initialDistance) {
        this.increaseHowManyPatterns();
        switch (Random.upTo(2)) {
            case 0:
                return new TheSeaPattern_MaybeOneSmallestFish(this.getTheSea(), initialDistance);
                break;
            case 1:
                return new TheSeaPattern_OneSmallestFish(this.getTheSea(), initialDistance);
                break;
            case 2:
                return new TheSeaPattern_MaybeOneMediumFish(this.getTheSea(), initialDistance);
                break;
        }
    };
    TheSeaPatternLevel_Level0.prototype.isLevelDone = function () {
        if (this.getHowManyPatterns() >= 2)
            return true;
        return false;
    };
    return TheSeaPatternLevel_Level0;
})(TheSeaPatternLevel);
///<reference path="TheSeaPatternLevel.ts"/>
var TheSeaPatternLevel_Level1 = (function (_super) {
    __extends(TheSeaPatternLevel_Level1, _super);
    // Constructor
    function TheSeaPatternLevel_Level1(theSea) {
        _super.call(this, theSea);
    }
    // Public methods
    TheSeaPatternLevel_Level1.prototype.getNextLevel = function () {
        return new TheSeaPatternLevel_Boss1(this.getTheSea());
    };
    TheSeaPatternLevel_Level1.prototype.getPattern = function (initialDistance) {
        this.increaseHowManyPatterns();
        switch (Random.upTo(1)) {
            case 0:
                return new TheSeaPattern_LotOfMiniSharks(this.getTheSea(), initialDistance);
                break;
            case 1:
                return new TheSeaPattern_JellyFishStorm(this.getTheSea(), initialDistance);
                break;
        }
    };
    TheSeaPatternLevel_Level1.prototype.isLevelDone = function () {
        if (this.getHowManyPatterns() >= 2)
            return true;
        return false;
    };
    return TheSeaPatternLevel_Level1;
})(TheSeaPatternLevel);
///<reference path="TheSeaPatternLevel.ts"/>
var TheSeaPatternLevel_Level2 = (function (_super) {
    __extends(TheSeaPatternLevel_Level2, _super);
    // Constructor
    function TheSeaPatternLevel_Level2(theSea) {
        _super.call(this, theSea);
    }
    // Public methods
    TheSeaPatternLevel_Level2.prototype.getNextLevel = function () {
        return new TheSeaPatternLevel_Level2(this.getTheSea());
    };
    TheSeaPatternLevel_Level2.prototype.getPattern = function (initialDistance) {
        this.increaseHowManyPatterns();
        // If this is the first pattern, then we return the big sharks pattern
        if (this.getHowManyPatterns() == 1)
            return new TheSeaPattern_BigSharks(this.getTheSea(), initialDistance);
        else
            return new TheSeaPattern_SeaSnakesForever(this.getTheSea(), initialDistance);
    };
    TheSeaPatternLevel_Level2.prototype.isLevelDone = function () {
        return false;
    };
    return TheSeaPatternLevel_Level2;
})(TheSeaPatternLevel);
///<reference path="TheSeaPattern.ts"/>
var TheSeaPattern_BigSharks = (function (_super) {
    __extends(TheSeaPattern_BigSharks, _super);
    // Constructor
    function TheSeaPattern_BigSharks(theSea, initialDistance) {
        _super.call(this, theSea, initialDistance);
    }
    // Public methods
    TheSeaPattern_BigSharks.prototype.isPatternDone = function () {
        if (this.getTheSea().getDistance() > this.getInitialDistance() + 125)
            return true;
        return false;
    };
    TheSeaPattern_BigSharks.prototype.run = function (x1, x2) {
        if (this.getTheSea().getDistance() % 60 == 0)
            this.getTheSea().addBigShark(new Pos(x2, Random.fromArray([2, 6])));
    };
    return TheSeaPattern_BigSharks;
})(TheSeaPattern);
///<reference path="TheSeaPattern.ts"/>
var TheSeaPattern_Boss0_Shapes = (function (_super) {
    __extends(TheSeaPattern_Boss0_Shapes, _super);
    // Constructor
    function TheSeaPattern_Boss0_Shapes(theSea, initialDistance) {
        _super.call(this, theSea, initialDistance);
        // Fishes of the squares
        this.fishes = [];
        // Did we add the fishes already ?
        this.fishesAdded = false;
        // Are fishes moving right now ?
        this.fishesAreMoving = true;
        // Set the shape type
        this.shapeType = Random.upTo(2);
    }
    // Public methods    
    TheSeaPattern_Boss0_Shapes.prototype.isPatternDone = function () {
        if (this.getTheSea().getDistance() > this.getInitialDistance() + 50)
            return true;
        return false;
    };
    TheSeaPattern_Boss0_Shapes.prototype.run = function (x1, x2) {
        // If it's time to add the fishes
        if (this.fishesAdded == false && this.getTheSea().getDistance() > this.getInitialDistance() + 30) {
            this.fishesAdded = true;
            this.addShape(x1, 1);
            this.addShape(x1, 8);
            this.addShape(x1, 15);
            this.addShape(x1 + 15, 0);
            this.addShape(x1 + 15, 7);
            this.addShape(x1 + 15, 14);
            this.addShape(x1 + 30, 1);
            this.addShape(x1 + 30, 8);
            this.addShape(x1 + 30, 15);
        }
        // Handle fishes movement (to make them stop if the player stop moving)
        this.handleFishesMovement();
    };
    // Private methods
    TheSeaPattern_Boss0_Shapes.prototype.addFish = function (smallestFish) {
        if (smallestFish != null)
            this.fishes.push(smallestFish);
    };
    TheSeaPattern_Boss0_Shapes.prototype.addCross = function (x, y) {
        this.addFish(this.getTheSea().addSmallestFish(new Pos(x, y + 1)));
        this.addFish(this.getTheSea().addSmallestFish(new Pos(x + 3, y + 2)));
        this.addFish(this.getTheSea().addSmallestFish(new Pos(x + 6, y + 3)));
        this.addFish(this.getTheSea().addSmallestFish(new Pos(x + 9, y + 4)));
        this.addFish(this.getTheSea().addSmallestFish(new Pos(x, y + 4)));
        this.addFish(this.getTheSea().addSmallestFish(new Pos(x + 3, y + 3)));
        this.addFish(this.getTheSea().addSmallestFish(new Pos(x + 6, y + 2)));
        this.addFish(this.getTheSea().addSmallestFish(new Pos(x + 9, y + 1)));
    };
    TheSeaPattern_Boss0_Shapes.prototype.addLines = function (x, y) {
        for (var i = x; i <= x + 9; i += 3) {
            for (var j = y; j <= y + 4; j += 2) {
                this.addFish(this.getTheSea().addSmallestFish(new Pos(i, j)));
            }
        }
    };
    TheSeaPattern_Boss0_Shapes.prototype.addShape = function (x, y) {
        // Call a random shape method
        switch (this.shapeType) {
            case 0:
                this.addSquare(x, y);
                break;
            case 1:
                this.addLines(x, y);
                break;
            case 2:
                this.addCross(x, y);
                break;
        }
    };
    TheSeaPattern_Boss0_Shapes.prototype.addSquare = function (x, y) {
        // Top & bottom
        for (var i = x; i <= x + 9; i += 3) {
            // Top of the square
            this.addFish(this.getTheSea().addSmallestFish(new Pos(i, y)));
            // Bottom of the square
            this.addFish(this.getTheSea().addSmallestFish(new Pos(i, y + 5)));
        }
        // Left & right
        for (var j = y; j <= y + 4; j++) {
            // Left of the square
            this.addFish(this.getTheSea().addSmallestFish(new Pos(x, j)));
            // Right of the square
            this.addFish(this.getTheSea().addSmallestFish(new Pos(x + 9, j)));
        }
    };
    TheSeaPattern_Boss0_Shapes.prototype.handleFishesMovement = function () {
        // If fishes are moving but shouldn't be
        if (this.fishesAreMoving == true && this.getTheSea().getLastPlayerMovement().x == 0 && this.getTheSea().getGame().getPlayer().getGlobalPosition().y >= 20) {
            // Fishes are not moving any more
            this.fishesAreMoving = false;
            for (var i = 0; i < this.fishes.length; i++) {
                this.fishes[i].setQuestEntityMovement(new QuestEntityMovement(new Pos(0, 0)));
            }
        }
        else if (this.fishesAreMoving == false && (this.getTheSea().getLastPlayerMovement().x > 0 || this.getTheSea().getGame().getPlayer().getGlobalPosition().y < 20)) {
            // Fishes are now moving
            this.fishesAreMoving = true;
            for (var i = 0; i < this.fishes.length; i++) {
                this.fishes[i].setQuestEntityMovement(new QuestEntityMovement(new Pos(-1, 0)));
            }
        }
    };
    return TheSeaPattern_Boss0_Shapes;
})(TheSeaPattern);
///<reference path="TheSeaPattern.ts"/>
var TheSeaPattern_Boss1_Seahorses = (function (_super) {
    __extends(TheSeaPattern_Boss1_Seahorses, _super);
    // Constructor
    function TheSeaPattern_Boss1_Seahorses(theSea, initialDistance) {
        _super.call(this, theSea, initialDistance);
        // Variables
        this.seahorses = [];
        this.seahorsesAdded = false;
        this.seaHorsesStopped = false;
        // The special seahorse wandering
        this.seahorseWandering = null;
        this.seahorseWanderingIsGoingUp = false;
        // The special seahorse following player
        this.seahorseFollowingPlayer = null;
    }
    // Public methods
    TheSeaPattern_Boss1_Seahorses.prototype.addSeahorse = function (seahorse) {
        if (seahorse != null) {
            this.seahorses.push(seahorse);
            return seahorse;
        }
        return null;
    };
    TheSeaPattern_Boss1_Seahorses.prototype.isPatternDone = function () {
        // Return false if seahorses aren't added yet
        if (this.seahorsesAdded == false)
            return false;
        // Return false if any of the seahorses is still alive
        for (var i = 0; i < this.seahorses.length; i++) {
            if (this.seahorses[i].getDead() == false)
                return false;
        }
        return true;
    };
    TheSeaPattern_Boss1_Seahorses.prototype.run = function (x1, x2) {
        // If we didn't add seahorses already (and we're far enough), we do so
        if (this.seahorsesAdded == false && this.getTheSea().getDistance() > this.getInitialDistance() + 30) {
            this.seahorsesAdded = true;
            // First column
            this.addSeahorse(this.getTheSea().addSeahorse(new Pos(x1, 2), 75));
            this.addSeahorse(this.getTheSea().addSeahorse(new Pos(x1, 12), 75));
            // Second column
            this.seahorseWandering = this.addSeahorse(this.getTheSea().addSeahorse(new Pos(x1 + 7, 10), 81));
            // Third Column
            this.seahorseFollowingPlayer = this.addSeahorse(this.getTheSea().addSeahorse(new Pos(x1 + 14, 10), 87));
            // Fourth column
            this.addSeahorse(this.getTheSea().addSeahorse(new Pos(x1 + 21, 7), 93));
            this.addSeahorse(this.getTheSea().addSeahorse(new Pos(x1 + 21, 17), 93));
        }
        // If we already added seahorses, we increase the moving counter
        if (this.seahorsesAdded == true && this.seaHorsesStopped == false) {
            // Find the seahorse which is the most on the left and store its x position
            var mostLeftX = 500;
            for (var i = 0; i < this.seahorses.length; i++) {
                if (this.seahorses[i].getGlobalPosition().x < mostLeftX)
                    mostLeftX = this.seahorses[i].getGlobalPosition().x;
            }
            // If this mostLeftX is <= 75
            if (mostLeftX - this.getTheSea().getGame().getPlayer().getGlobalPosition().x <= 75) {
                // We stop the seahorses
                this.seaHorsesStopped = true;
                for (var i = 0; i < this.seahorses.length; i++) {
                    this.seahorses[i].getQuestEntityMovement().setOffset(new Pos(0, 0));
                }
            }
        }
        // If the sea horses are stopped, we adjust their movement so that they swim with the player
        if (this.seaHorsesStopped) {
            for (var i = 0; i < this.seahorses.length; i++) {
                this.seahorses[i].tryToGoToIntendedXPosition(this.getTheSea().getGame().getPlayer().getGlobalPosition().x);
            }
        }
        // We handle the special seahorse wandering
        if (this.seahorseWandering != null) {
            if (this.seahorseWanderingIsGoingUp) {
                this.seahorseWandering.getQuestEntityMovement().getOffset().y = -1;
                if (this.seahorseWandering.getGlobalPosition().y <= 0)
                    this.seahorseWanderingIsGoingUp = false;
            }
            else {
                this.seahorseWandering.getQuestEntityMovement().getOffset().y = 1;
                if (this.seahorseWandering.getGlobalPosition().y >= 16)
                    this.seahorseWanderingIsGoingUp = true;
            }
        }
        // We handle the special seahorse following the player
        if (this.seahorseFollowingPlayer != null) {
            // By default we don't move
            this.seahorseFollowingPlayer.getQuestEntityMovement().getOffset().y = 0;
            // If the player is above
            if (this.getTheSea().getGame().getPlayer().getGlobalPosition().y < this.seahorseFollowingPlayer.getGlobalPosition().y - 1) {
                // If we're not too high
                if (this.seahorseFollowingPlayer.getGlobalPosition().y > 0)
                    // We go up
                    this.seahorseFollowingPlayer.getQuestEntityMovement().getOffset().y = -1;
            }
            else if (this.getTheSea().getGame().getPlayer().getGlobalPosition().y > this.seahorseFollowingPlayer.getGlobalPosition().y - 1) {
                // If we're not too low
                if (this.seahorseFollowingPlayer.getGlobalPosition().y < 17)
                    // We go down
                    this.seahorseFollowingPlayer.getQuestEntityMovement().getOffset().y = +1;
            }
        }
    };
    return TheSeaPattern_Boss1_Seahorses;
})(TheSeaPattern);
///<reference path="TheSeaPattern.ts"/>
var TheSeaPattern_JellyFishStorm = (function (_super) {
    __extends(TheSeaPattern_JellyFishStorm, _super);
    // Constructor
    function TheSeaPattern_JellyFishStorm(theSea, initialDistance) {
        _super.call(this, theSea, initialDistance);
    }
    // Public methods
    TheSeaPattern_JellyFishStorm.prototype.isPatternDone = function () {
        if (this.getTheSea().getDistance() > this.getInitialDistance() + 100)
            return true;
        return false;
    };
    TheSeaPattern_JellyFishStorm.prototype.run = function (x1, x2) {
        if (Random.oneChanceOutOf(10))
            this.getTheSea().addJellyFish(new Pos(Random.between(x1, x2), Random.between(0, this.getTheSea().getRealQuestSize().y - this.getTheSea().getFloorMaxHeight() - 6)));
    };
    return TheSeaPattern_JellyFishStorm;
})(TheSeaPattern);
///<reference path="TheSeaPattern.ts"/>
var TheSeaPattern_LotOfMiniSharks = (function (_super) {
    __extends(TheSeaPattern_LotOfMiniSharks, _super);
    // Constructor
    function TheSeaPattern_LotOfMiniSharks(theSea, initialDistance) {
        _super.call(this, theSea, initialDistance);
        // Variables
        this.sharksAdded = false;
    }
    // Public methods
    TheSeaPattern_LotOfMiniSharks.prototype.isPatternDone = function () {
        if (this.getTheSea().getDistance() > this.getInitialDistance() + 60)
            return true;
        return false;
    };
    TheSeaPattern_LotOfMiniSharks.prototype.run = function (x1, x2) {
        if (this.getTheSea().getDistance() > this.getInitialDistance() + 30 && this.sharksAdded == false) {
            this.sharksAdded = true;
            this.getTheSea().addMiniShark(new Pos(x1 + Random.upTo(6), 2));
            this.getTheSea().addMiniShark(new Pos(x1 + Random.upTo(6), 8));
            this.getTheSea().addMiniShark(new Pos(x1 + Random.upTo(6), 14));
        }
    };
    return TheSeaPattern_LotOfMiniSharks;
})(TheSeaPattern);
///<reference path="TheSeaPattern.ts"/>
var TheSeaPattern_MaybeOneMediumFish = (function (_super) {
    __extends(TheSeaPattern_MaybeOneMediumFish, _super);
    // Constructor
    function TheSeaPattern_MaybeOneMediumFish(theSea, initialDistance) {
        _super.call(this, theSea, initialDistance);
    }
    // Public methods
    TheSeaPattern_MaybeOneMediumFish.prototype.isPatternDone = function () {
        if (this.getTheSea().getDistance() > this.getInitialDistance() + 100)
            return true;
        return false;
    };
    TheSeaPattern_MaybeOneMediumFish.prototype.run = function (x1, x2) {
        if (Random.oneChanceOutOf(5)) {
            this.getTheSea().addMediumFish(new Pos(Random.between(x1, x2), Random.between(0, this.getTheSea().getRealQuestSize().y - this.getTheSea().getFloorMaxHeight() - 4)));
        }
    };
    return TheSeaPattern_MaybeOneMediumFish;
})(TheSeaPattern);
///<reference path="TheSeaPattern.ts"/>
var TheSeaPattern_MaybeOneSmallestFish = (function (_super) {
    __extends(TheSeaPattern_MaybeOneSmallestFish, _super);
    // Constructor
    function TheSeaPattern_MaybeOneSmallestFish(theSea, initialDistance) {
        _super.call(this, theSea, initialDistance);
    }
    // Public methods
    TheSeaPattern_MaybeOneSmallestFish.prototype.isPatternDone = function () {
        if (this.getTheSea().getDistance() > this.getInitialDistance() + 100)
            return true;
        return false;
    };
    TheSeaPattern_MaybeOneSmallestFish.prototype.run = function (x1, x2) {
        if (Random.flipACoin()) {
            this.getTheSea().addSmallestFish(new Pos(Random.between(x1, x2), Random.between(0, this.getTheSea().getRealQuestSize().y - this.getTheSea().getFloorMaxHeight() - 2)));
        }
    };
    return TheSeaPattern_MaybeOneSmallestFish;
})(TheSeaPattern);
///<reference path="TheSeaPattern.ts"/>
var TheSeaPattern_OneSmallestFish = (function (_super) {
    __extends(TheSeaPattern_OneSmallestFish, _super);
    // Constructor
    function TheSeaPattern_OneSmallestFish(theSea, initialDistance) {
        _super.call(this, theSea, initialDistance);
    }
    // Public methods
    TheSeaPattern_OneSmallestFish.prototype.isPatternDone = function () {
        if (this.getTheSea().getDistance() > this.getInitialDistance() + 100)
            return true;
        return false;
    };
    TheSeaPattern_OneSmallestFish.prototype.run = function (x1, x2) {
        this.getTheSea().addSmallestFish(new Pos(Random.between(x1, x2), Random.between(0, this.getTheSea().getRealQuestSize().y - this.getTheSea().getFloorMaxHeight() - 2)));
    };
    return TheSeaPattern_OneSmallestFish;
})(TheSeaPattern);
///<reference path="TheSeaPattern.ts"/>
var TheSeaPattern_SeaSnakesForever = (function (_super) {
    __extends(TheSeaPattern_SeaSnakesForever, _super);
    // Constructor
    function TheSeaPattern_SeaSnakesForever(theSea, initialDistance) {
        _super.call(this, theSea, initialDistance);
        // Variables
        this.addedRedSharkFin = false;
        this.addedGreenSharkFin = false;
        this.addedPurpleSharkFin = false;
        this.nextSnakeIn = 0;
        this.nextSharkIn = Random.between(0, 50);
    }
    // Public methods
    TheSeaPattern_SeaSnakesForever.prototype.isPatternDone = function () {
        return false;
    };
    TheSeaPattern_SeaSnakesForever.prototype.run = function (x1, x2) {
        // Possibly add a snake
        this.nextSnakeIn -= 1;
        if (this.nextSnakeIn <= 0) {
            this.getTheSea().addSeaSnake(new Pos(x2, Random.between(0, this.getTheSea().getRealQuestSize().y - this.getTheSea().getFloorMaxHeight() - 12)));
            this.nextSnakeIn = 85 - Math.ceil((1 - Math.exp(-(this.getTheSea().getDistance() - this.getInitialDistance()) / 1500)) * 83);
        }
        // Possibly add a shark
        this.nextSharkIn -= 1;
        if (this.nextSharkIn <= 0) {
            // Store the shark
            var shark = this.getTheSea().addBigShark(new Pos(x2, Random.between(0, this.getTheSea().getRealQuestSize().y - this.getTheSea().getFloorMaxHeight() - 10)));
            // If a shark was added
            if (shark != null) {
                if (Saving.loadBool("gridItemPossessedRedSharkFin") == false && this.addedRedSharkFin == false && this.getTheSea().getDistance() - this.getInitialDistance() > 150) {
                    shark.hasFin(BigSharkFinType.RED);
                    this.addedRedSharkFin = true;
                }
                else if (Saving.loadBool("gridItemPossessedGreenSharkFin") == false && this.addedGreenSharkFin == false && this.getTheSea().getDistance() - this.getInitialDistance() > 700) {
                    shark.hasFin(BigSharkFinType.GREEN);
                    this.addedGreenSharkFin = true;
                }
                else if (Saving.loadBool("gridItemPossessedPurpleSharkFin") == false && this.addedPurpleSharkFin == false && this.getTheSea().getDistance() - this.getInitialDistance() > 2500) {
                    shark.hasFin(BigSharkFinType.PURPLE);
                    this.addedPurpleSharkFin = true;
                }
            }
            // Set the next shark in
            this.nextSharkIn = 60 - Math.ceil((1 - Math.exp(-(this.getTheSea().getDistance() - this.getInitialDistance()) / 1500)) * 55);
        }
    };
    return TheSeaPattern_SeaSnakesForever;
})(TheSeaPattern);
///<reference path="House.ts"/>
var ThirdHouse = (function (_super) {
    __extends(ThirdHouse, _super);
    // Constructor
    function ThirdHouse(game) {
        _super.call(this, game);
        // The render area
        this.renderArea = new RenderArea();
        // The game running
        this.gameRunning = null;
        this.renderArea.resizeFromArray(Database.getAscii("places/village/thirdHouse"), 0, 3);
        this.update();
    }
    // getRenderArea()
    ThirdHouse.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // willBeDisplayed()
    ThirdHouse.prototype.willBeDisplayed = function () {
        this.getGame().getQuestCallbackCollection().addCallback(this.runGame.bind(this));
        // Add some hotkeys
        this.getGame().addHotkey(new Hotkey("up", new CallbackCollection(this.pressedUpButton.bind(this))));
        this.getGame().addHotkey(new Hotkey("down", new CallbackCollection(this.pressedDownButton.bind(this))));
        this.getGame().addHotkey(new Hotkey("space", new CallbackCollection(this.pressedSpaceButton.bind(this))));
    };
    // Private methods
    ThirdHouse.prototype.addControls = function (x, y) {
        // If there's a game running, we add the controls
        if (this.gameRunning != null) {
            // UP button
            this.renderArea.addAsciiButton(x, x + 4, y, "thirdHouseUpButton");
            this.renderArea.addLinkCall(".thirdHouseUpButton", new CallbackCollection(this.pressedUpButton.bind(this)));
            // Space button
            this.renderArea.addAsciiButton(x + 7, x + 25, y + 1, "thirdHouseSpaceButton");
            this.renderArea.addLinkCall(".thirdHouseSpaceButton", new CallbackCollection(this.pressedSpaceButton.bind(this)));
            // DOWN button
            this.renderArea.addAsciiButton(x + 28, x + 34, y, "thirdHouseDownButton");
            this.renderArea.addLinkCall(".thirdHouseDownButton", new CallbackCollection(this.pressedDownButton.bind(this)));
        }
    };
    ThirdHouse.prototype.addInsertCandiesButtons = function (x, y) {
        // First button (10 candies)
        this.renderArea.addAsciiButton(x, x + 4, y, "thirdHouseInsert10CandiesButton");
        this.renderArea.addLinkCall(".thirdHouseInsert10CandiesButton", new CallbackCollection(this.insert10Candies.bind(this)));
        // Second button (1000 candies)
        this.renderArea.addAsciiButton(x, x + 4, y + 2, "thirdHouseInsert1000CandiesButton");
        this.renderArea.addLinkCall(".thirdHouseInsert1000CandiesButton", new CallbackCollection(this.insert1000Candies.bind(this)));
    };
    ThirdHouse.prototype.insert10Candies = function () {
        // If we have enough candies
        if (this.getGame().getCandies().getCurrent() >= 10) {
            // We pay the price
            this.getGame().getCandies().add(-10);
            // We launch the game
            this.gameRunning = new SuperRPG(this);
        }
    };
    ThirdHouse.prototype.insert1000Candies = function () {
        // If we have enough candies
        if (this.getGame().getCandies().getCurrent() >= 1000) {
            // We pay the price
            this.getGame().getCandies().add(-1000);
            // We launch the game
            this.gameRunning = new GalacticWars(this);
        }
    };
    ThirdHouse.prototype.pressedDownButton = function () {
        if (this.gameRunning != null)
            this.gameRunning.pressedDownButton();
    };
    ThirdHouse.prototype.pressedSpaceButton = function () {
        if (this.gameRunning != null)
            this.gameRunning.pressedSpaceButton();
    };
    ThirdHouse.prototype.pressedUpButton = function () {
        if (this.gameRunning != null)
            this.gameRunning.pressedUpButton();
    };
    ThirdHouse.prototype.runGame = function () {
        // If there's a game running, we run it
        if (this.gameRunning != null) {
            // If it should stop running
            if (this.gameRunning.run() == true) {
                this.gameRunning = null; // We set it to null
                // We update
                this.update();
                this.getGame().updatePlace();
            }
            else {
                // We update
                this.update();
                // We draw the game on the screen
                this.renderArea.drawArea(this.gameRunning.getRenderArea(), 19, 10);
                // We update at the game level
                this.getGame().updatePlace();
            }
        }
    };
    ThirdHouse.prototype.update = function () {
        // Erase everything
        this.renderArea.resetAllButSize();
        // Back to the village button
        this.addBackToTheVillageButton(this.renderArea, "thirdHouseBackToTheVillageButton");
        // Draw the house
        this.renderArea.drawArray(Database.getAscii("places/village/thirdHouse"), 0, 3);
        // Add the buttons to insert candies
        this.addInsertCandiesButtons(25, 28);
        // Add the buttons to control the game
        this.addControls(29, 24);
    };
    return ThirdHouse;
})(House);
///<reference path="Place.ts"/>
var Treasure = (function (_super) {
    __extends(Treasure, _super);
    // Constructor
    function Treasure(game) {
        _super.call(this, game);
        // The render area
        this.renderArea = new RenderArea();
        this.renderArea.resizeFromArray(Database.getAscii("places/treasure"), 57, 3);
        this.update();
    }
    // getRenderArea()
    Treasure.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // Private methods
    Treasure.prototype.dig = function () {
        // We found the treasure
        Saving.saveBool("TheCavePattern_TreasureMapFoundTreasure", true);
        // Get it
        this.getGame().getChocolateBars().add(3);
        // Update
        this.update();
        this.getGame().updatePlace();
    };
    Treasure.prototype.update = function () {
        // Erase everything
        this.renderArea.resetAllButSize();
        // Back to the map button
        this.addBackToMainMapButton(this.renderArea, "treasureBackToTheMapButton");
        // Draw the ascii
        this.renderArea.drawArray(Database.getAscii("places/treasure"), 28, 3);
        // If we didn't find the treasure yet
        if (Saving.loadBool("TheCavePattern_TreasureMapFoundTreasure") == false) {
            // Add the button to get the treasure
            this.renderArea.addAsciiRealButton(Database.getText("treasureButtonDig"), 49, 14, "treasureButton", Database.getTranslatedText("treasureButtonDig"), true, -1, null, false);
            this.renderArea.addLinkCall(".treasureButton", new CallbackCollection(this.dig.bind(this)));
        }
        else {
            // Add the text
            this.renderArea.drawString(Database.getText("treasureButtonYouFound"), 49, 14);
            this.renderArea.drawString(Database.getTranslatedText("treasureButtonYouFound"), 49, 15, true);
        }
    };
    return Treasure;
})(Place);
///<reference path="QuestEntity.ts"/>
var TreeSpirit = (function (_super) {
    __extends(TreeSpirit, _super);
    // Constructor
    function TreeSpirit(quest, pos, groundYPosition) {
        _super.call(this, quest, pos, new Naming("A tree spirit", "a tree spirit"), new RenderArea(5, 5), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 1), new Pos(5, 2)), new CollisionBox(this, new Pos(1, 3), new Pos(3, 2))), new QuestEntityMovement());
        // Set the ground y position from the value given in parameter
        this.groundYPosition = groundYPosition;
        // Set the default values for ammunition related variables
        this.maxAmmunition = 5;
        this.ammunition = 5;
        this.ammunitionTimer = 0;
        // Set the default values for magic spines related variables
        this.magicSpineTimer = 0;
        // Set the ascii art and the transparent character
        this.getRenderArea().drawArray(Database.getAscii("places/quests/forest/treeSpirit"));
        this.setTransparency(new RenderTransparency(" "));
        // Set gravity
        this.getQuestEntityMovement().setGravity(true);
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(100);
        this.setHp(100);
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("Spines", "spines"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, 0), new Pos(7, 6))), 2));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setFixedDelay(1);
    }
    // update()
    TreeSpirit.prototype.update = function () {
        // Calculate the distance from the player
        var distanceFromPlayer = this.getGlobalPosition().plus(new Pos(2, 0)).getDistance(this.getQuest().getGame().getPlayer().getGlobalPosition());
        // Handle ammunition timer
        if (this.ammunitionTimer <= 0) {
            if (this.ammunition < this.maxAmmunition)
                this.ammunition += 1;
            this.ammunitionTimer = 20;
        }
        else
            this.ammunitionTimer -= 1;
        // Handle magic spine timer
        if (this.magicSpineTimer > 0)
            this.magicSpineTimer -= 1;
        // Set the movement depending on the distance from the player
        this.getQuestEntityMovement().setOffset(new Pos((distanceFromPlayer.x > 0 ? -1 : 1), 0));
        // If the player is above the ground position
        if (this.getQuest().getGame().getPlayer().getGlobalPosition().y < this.groundYPosition) {
            // If the timer is okay
            if (this.magicSpineTimer <= 0) {
                // We shoot a magic spine on the left or on the right
                if (this.shootMagicSpine((distanceFromPlayer.x > 0 ? true : false))) {
                    this.ammunition -= 1; // We lower the ammunition
                    this.magicSpineTimer = 12; // We set the countdown
                }
            }
        }
        // Call the mother class update
        _super.prototype.update.call(this);
    };
    // willDie()
    TreeSpirit.prototype.willDie = function () {
        this.getQuest().getGame().getQuestLog().addMessage(new QuestLogMessage(this.getDeathMessage() + " (and found " + Algo.pluralFormat(this.getQuest().foundCandies(100 + 50 * Random.upTo(10)), " candy", " candies") + ")", this.getQuest().getCandiesFoundMessage()));
    };
    // Private methods
    TreeSpirit.prototype.shootMagicSpine = function (onTheLeft) {
        // Create the magic spine
        var magicSpine = new Fireball(this.getQuest(), this.getGlobalPosition().plus(new Pos((onTheLeft ? -3 : 5), 2)), new Naming("A magical spine", "a magical spine"), new Color(ColorType.TREE_SPIRIT_MAGIC_SPINE), new Pos(3, 1), 150, this.getAndPossiblyCreateSpellCastingDamageReason(new Naming("A magical spine", "a magical spine")));
        // No target
        magicSpine.setTargetTypeNoTarget(new Pos((onTheLeft ? -2 : 2), 0));
        // Add the entity
        return this.getQuest().addEntity(magicSpine);
    };
    return TreeSpirit;
})(QuestEntity);
///<reference path="EqItem.ts"/>
var TribalSpear = (function (_super) {
    __extends(TribalSpear, _super);
    // Constructor
    function TribalSpear() {
        _super.call(this, "eqItemWeaponTribalSpear", "eqItemWeaponTribalSpearName", "eqItemWeaponTribalSpearDescription", "eqItems/weapons/tribalSpear");
    }
    // Public getters
    TribalSpear.prototype.getQuestEntityWeapon = function (quest, player) {
        var qew = new QuestEntityWeapon(quest, player, new Naming("A tribal spear", "a tribal spear"), player.getClassicCollisionBoxCollection(), 8);
        qew.getCloseCombatDelay().setFixedDelay(2);
        return qew;
    };
    return TribalSpear;
})(EqItem);
///<reference path="QuestEntity.ts"/>
var TripodCamel = (function (_super) {
    __extends(TripodCamel, _super);
    // Constructor
    function TripodCamel(quest, pos) {
        _super.call(this, quest, pos, new Naming("A tripod camel", "a tripod camel"), new RenderArea(7, 2), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 0), new Pos(6, 1)), new CollisionBox(this, new Pos(2, 1), new Pos(5, 1))), new QuestEntityMovement());
        // Set gravity
        this.getQuestEntityMovement().setGravity(true);
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(7);
        this.setHp(7);
        // Set the ascii art and the transparent character
        if (Random.flipACoin())
            this.getRenderArea().drawArray(Database.getAscii("places/quests/desert/tripodCamel1"));
        else
            this.getRenderArea().drawArray(Database.getAscii("places/quests/desert/tripodCamel2"));
        this.setTransparency(new RenderTransparency(" "));
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("Its long neck", "its long neck"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, 0), new Pos(3, 3))), 5));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setBetweenDelay(6, 8);
    }
    // Public methods
    TripodCamel.prototype.willDie = function () {
        this.getQuest().getGame().getQuestLog().addMessage(new QuestLogMessage(this.getDeathMessage() + " (and found " + Algo.pluralFormat(this.getQuest().foundCandies(20 + Random.upTo(12)), " candy", " candies") + ")", this.getQuest().getCandiesFoundMessage()));
    };
    return TripodCamel;
})(QuestEntity);
///<reference path="QuestEntity.ts"/>
var Troll = (function (_super) {
    __extends(Troll, _super);
    // Constructor
    function Troll(quest, pos) {
        _super.call(this, quest, pos, new Naming("A troll", "a troll"), new RenderArea(15, 10), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(11, 0), new Pos(2, 1)), new CollisionBox(this, new Pos(4, 1), new Pos(3, 3)), new CollisionBox(this, new Pos(9, 1), new Pos(6, 2)), new CollisionBox(this, new Pos(0, 4), new Pos(8, 4)), new CollisionBox(this, new Pos(2, 8), new Pos(5, 2)), new CollisionBox(this, new Pos(8, 4), new Pos(4, 2)), new CollisionBox(this, new Pos(11, 3), new Pos(2, 4)) // The lowest part of the bludgeon
        ), new QuestEntityMovement());
        // Set gravity
        this.getQuestEntityMovement().setGravity(true);
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(80);
        this.setHp(80);
        // Set the ascii art and the transparent character
        this.getRenderArea().drawArray(Database.getAscii("places/quests/bridge/troll"));
        this.setTransparency(new RenderTransparency(" "));
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new Bludgeon(this.getQuest(), this, new Naming("Its bludgeon", "its bludgeon"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(17, 11))), 15));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setFixedDelay(6);
    }
    // Public methods
    Troll.prototype.draw = function (renderArea) {
        _super.prototype.draw.call(this, renderArea);
        // We add the missing "<" on the troll's bludgeon as a tag
        renderArea.addTag(new RenderTagLt(this.getQuest().getRealQuestPosition().x + this.getGlobalPosition().x + this.getRenderAreaPosition().x + 9), this.getQuest().getRealQuestPosition().y + this.getGlobalPosition().y + this.getRenderAreaPosition().y + 1);
    };
    Troll.prototype.willDie = function () {
        this.getQuest().getGame().getQuestLog().addMessage(new QuestLogMessage(this.getDeathMessage() + " (and found " + Algo.pluralFormat(this.getQuest().foundCandies(500), " candy", " candies") + ")", this.getQuest().getCandiesFoundMessage()));
        this.getQuest().foundGridOrEqItem(new QuestItemFound(this.getQuest(), "eqItemWeaponTrollBludgeon", "You picked up the troll's bludgeon from the floor", "You gain the troll's bludgeon"));
    };
    return Troll;
})(QuestEntity);
///<reference path="EqItem.ts"/>
var TrollBludgeon = (function (_super) {
    __extends(TrollBludgeon, _super);
    // Constructor
    function TrollBludgeon() {
        _super.call(this, "eqItemWeaponTrollBludgeon", "eqItemWeaponTrollBludgeonName", "eqItemWeaponTrollBludgeonDescription", "eqItems/weapons/trollBludgeon");
    }
    // Public getters
    TrollBludgeon.prototype.getQuestEntityWeapon = function (quest, player) {
        var qew = new PlayerBludgeon(quest, player, new Naming("The troll's bludgeon", "the troll's bludgeon"), player.getClassicCollisionBoxCollection());
        qew.getCloseCombatDelay().setFixedDelay(6);
        return qew;
    };
    return TrollBludgeon;
})(EqItem);
///<reference path="GridItem.ts"/>
var UnicornHorn = (function (_super) {
    __extends(UnicornHorn, _super);
    function UnicornHorn() {
        _super.apply(this, arguments);
    }
    UnicornHorn.prototype.update = function (player, quest) {
        player.heal(3);
    };
    return UnicornHorn;
})(GridItem);
///<reference path="Place.ts"/>
var Village = (function (_super) {
    __extends(Village, _super);
    // Constructor
    function Village(game) {
        _super.call(this, game);
        // Render areas
        this.renderArea = new RenderArea();
        // Smoke
        this.smokes = [new Smoke(8, 26, 1, 3, 1, 3),
            new Smoke(64, 26, 2, 4, 0, 0),
            new Smoke(80, 26, 1, 3, 1, 3),
            new Smoke(59, 42, 1, 3, 1, 3)
        ];
        // Resize the area
        this.renderArea.resizeFromArray(Database.getAscii("places/village/village"), 0, 3);
        // Update
        this.update();
    }
    // Public methods    
    Village.prototype.willBeDisplayed = function () {
        this.getGame().getOneSecondCallbackCollection().addCallback(this.actionSmokes.bind(this));
        this.update(); // We update. This is needed because the village is the first thing to be loaded when we launch the game
    };
    // getRenderArea()
    Village.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // Private methods
    Village.prototype.actionSmokes = function () {
        // We make the smokes move
        for (var i = 0; i < this.smokes.length; i++) {
            this.smokes[i].move();
        }
        // We update on the page
        this.update();
        this.getGame().updatePlace();
    };
    Village.prototype.update = function () {
        // Erase everything
        this.renderArea.resetAllButSize();
        // Back to the map button only if we possess the main map
        if (Saving.loadBool("gridItemPossessedMainMap"))
            this.addBackToMainMapButton(this.renderArea, "villageBackToTheMapButton");
        // Draw the ascii
        this.renderArea.drawArray(Database.getAscii("places/village/village"), 0, 3);
        // Draw smokes
        for (var i = 0; i < this.smokes.length; i++) {
            this.smokes[i].draw(this.renderArea);
        }
        // Load various things
        this.loadFirstHouse(2, 3 + 24);
        this.loadSecondHouse(18, 3 + 21);
        this.loadThirdHouse(32, 3 + 25);
        this.loadForge(61, 3 + 24);
        this.loadFourthHouse(77, 3 + 24);
        this.loadFifthHouse(91, 3 + 25);
    };
    // Private "go to" methods
    Village.prototype.goToFirstHouse = function () {
        alert("yay");
    };
    Village.prototype.goToSecondHouse = function () {
        this.getGame().setPlace(new SecondHouse(this.getGame()));
    };
    Village.prototype.goToThirdHouse = function () {
        this.getGame().setPlace(new ThirdHouse(this.getGame()));
    };
    Village.prototype.goToForge = function () {
        this.getGame().setPlace(new Forge(this.getGame()));
    };
    Village.prototype.goToFourthHouse = function () {
        this.getGame().setPlace(new FourthHouse(this.getGame()));
    };
    Village.prototype.goToFifthHouse = function () {
        this.getGame().setPlace(new FifthHouse(this.getGame()));
    };
    // Private "load" methods
    Village.prototype.loadFirstHouse = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiNinjaButtons("mapVillageFirstHouseButton", x + 6, x + 8, y, x + 1, x + 10, y + 1, x, x + 11, y + 2, x - 1, x + 12, y + 3, x, x + 11, y + 4, x, x + 11, y + 5);
        // Comments
        this.renderArea.addFullComment(x + 6, y + 6, Database.getText("mapVillageLockedHouseComment"), Database.getTranslatedText("mapVillageLockedHouseComment"), "mapVillageFirstHouseComment");
        // Interactions
        this.renderArea.addLinkOver(".mapVillageFirstHouseButton, .mapVillageFirstHouseComment", ".mapVillageFirstHouseComment");
    };
    Village.prototype.loadSecondHouse = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("mapVillageSecondHouseButton", x + 1, x + 9, y, x, x + 10, y + 1, x - 1, x + 11, y + 2, x, x + 10, y + 3, x, x + 10, y + 4, x, x + 10, y + 5, x, x + 10, y + 6, x, x + 10, y + 7, x, x + 10, y + 8);
        // Comments
        this.renderArea.addFullComment(x + 5, y + 9, Database.getText("mapVillageTheShopComment"), Database.getTranslatedText("mapVillageTheShopComment"), "mapVillageSecondHouseComment");
        // Interactions
        this.renderArea.addLinkOver(".mapVillageSecondHouseButton, .mapVillageSecondHouseComment", ".mapVillageSecondHouseComment");
        this.renderArea.addLinkCall(".mapVillageSecondHouseButton, .mapVillageSecondHouseComment", new CallbackCollection(this.goToSecondHouse.bind(this)));
    };
    Village.prototype.loadThirdHouse = function (x, y) {
        // If we have the key to the third house
        if (Saving.loadBool("gridItemPossessedThirdHouseKey")) {
            // Buttons
            this.renderArea.addMultipleAsciiButtons("mapVillageThirdHouseButton", x + 1, x + 7, y, x, x + 8, y + 1, x - 1, x + 9, y + 2, x, x + 8, y + 3, x, x + 8, y + 4);
            // Comments
            this.renderArea.addFullComment(x + 4, y + 5, Database.getText("mapVillageAHouseComment"), Database.getTranslatedText("mapVillageAHouseComment"), "mapVillageThirdHouseComment");
            // Interactions
            this.renderArea.addLinkOver(".mapVillageThirdHouseButton, .mapVillageThirdHouseComment", ".mapVillageThirdHouseComment");
            this.renderArea.addLinkCall(".mapVillageThirdHouseButton, .mapVillageThirdHouseComment", new CallbackCollection(this.goToThirdHouse.bind(this)));
        }
        else {
            // Buttons
            this.renderArea.addMultipleAsciiNinjaButtons("mapVillageThirdHouseButton", x + 1, x + 7, y, x, x + 8, y + 1, x - 1, x + 9, y + 2, x, x + 8, y + 3, x, x + 8, y + 4);
            // Comments
            this.renderArea.addFullComment(x + 4, y + 5, Database.getText("mapVillageLockedHouseComment"), Database.getTranslatedText("mapVillageLockedHouseComment"), "mapVillageThirdHouseComment");
            // Interactions
            this.renderArea.addLinkOver(".mapVillageThirdHouseButton, .mapVillageThirdHouseComment", ".mapVillageThirdHouseComment");
        }
    };
    Village.prototype.loadForge = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("mapVillageForgeButton", x + 3, x + 6, y, x + 1, x + 10, y + 1, x, x + 11, y + 2, x - 1, x + 12, y + 3, x, x + 11, y + 4, x, x + 11, y + 5);
        // Comments
        this.renderArea.addFullComment(x + 6, y + 6, Database.getText("mapVillageForgeComment"), Database.getTranslatedText("mapVillageForgeComment"), "mapVillageForgeComment");
        // Interactions
        this.renderArea.addLinkOver(".mapVillageForgeButton, .mapVillageForgeComment", ".mapVillageForgeComment");
        this.renderArea.addLinkCall(".mapVillageForgeButton, .mapVillageForgeComment", new CallbackCollection(this.goToForge.bind(this)));
    };
    Village.prototype.loadFourthHouse = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("mapVillageFourthHouseButton", x + 3, x + 5, y, x + 1, x + 10, y + 1, x, x + 11, y + 2, x - 1, x + 12, y + 3, x, x + 11, y + 4, x, x + 11, y + 5);
        // Comments
        this.renderArea.addFullComment(x + 6, y + 6, Database.getText("mapVillageAHouseComment"), Database.getTranslatedText("mapVillageAHouseComment"), "mapVillageFourthHouseComment");
        // Interactions
        this.renderArea.addLinkOver(".mapVillageFourthHouseButton, .mapVillageFourthHouseComment", ".mapVillageFourthHouseComment");
        this.renderArea.addLinkCall(".mapVillageFourthHouseButton, .mapVillageFourthHouseComment", new CallbackCollection(this.goToFourthHouse.bind(this)));
    };
    Village.prototype.loadFifthHouse = function (x, y) {
        // Buttons
        this.renderArea.addMultipleAsciiButtons("mapVillageFifthHouseButton", x + 1, x + 9, y, x, x + 10, y + 1, x - 1, x + 11, y + 2, x, x + 10, y + 3, x, x + 10, y + 4);
        // Comments
        this.renderArea.addFullComment(x + 5, y + 5, Database.getText("mapVillageAHouseComment"), Database.getTranslatedText("mapVillageAHouseComment"), "mapVillageFifthHouseComment");
        // Interactions
        this.renderArea.addLinkOver(".mapVillageFifthHouseButton, .mapVillageFifthHouseComment", ".mapVillageFifthHouseComment");
        this.renderArea.addLinkCall(".mapVillageFifthHouseButton, .mapVillageFifthHouseComment", new CallbackCollection(this.goToFifthHouse.bind(this)));
    };
    return Village;
})(Place);
///<reference path="QuestEntity.ts"/>
var Wall = (function (_super) {
    __extends(Wall, _super);
    // Constructor
    function Wall(quest, pos) {
        _super.call(this, quest, pos, new Naming("A wall", "a wall"), null, new Pos(0, 0), new CollisionBoxCollection());
    }
    // Public method
    Wall.prototype.addBox = function (pos, size) {
        this.getCbc().addCollisionBox(new CollisionBox(this, pos, size));
    };
    Wall.prototype.removeBoxes = function () {
        this.getCbc().removeBoxes();
    };
    return Wall;
})(QuestEntity);
///<reference path="Place.ts"/>
// Candies stuff
Saving.registerBool("wishingWellFirstCandyThrown", false);
Saving.registerNumber("wishingWellPreviousCandyWishPrice", 1);
Saving.registerNumber("wishingWellCurrentCandyWishPrice", 1);
// Lollipops stuff
Saving.registerBool("wishingWellFirstLollipopThrown", false);
Saving.registerNumber("wishingWellCurrentLollipopWishPrice", 1);
// How many chocolate bars did we threw?
Saving.registerBool("wishingWellWeAreEnchanting", false); // If true, it means a chocolate bar was thrown and we're waiting for the player to choose its enchantment
Saving.registerNumber("wishingWellHowManyChocolateBarsThrown", 0);
// How many pains au chocolat did we threw?
Saving.registerBool("wishingWellWeArePainAuChocolating", false); // If true, it means a pain au chocolat was thrown and we're waiting for the player to choose its reward
Saving.registerNumber("wishingWellHowManyPainsAuChocolatThrown", 0);
// Chocolate bars stuff
Saving.registerBool;
var WishingWell = (function (_super) {
    __extends(WishingWell, _super);
    // Constructor
    function WishingWell(game) {
        _super.call(this, game);
        // The render area
        this.renderArea = new RenderArea();
        // Current speech
        this.currentSpeech = null;
        this.selectedEnchantmentId = "wishingWellPossibleEnchantment0";
        // Gifts
        this.selectedGiftId = "wishingWellGiftPower";
        this.createPossibleEnchantments();
        this.renderArea.resizeFromArray(Database.getAscii("places/wishingWell"), 62, 3);
        this.update();
    }
    // getRenderArea()
    WishingWell.prototype.getRenderArea = function () {
        return this.renderArea;
    };
    // Private methods
    WishingWell.prototype.addEnchantmentIfPossible = function (enchantment) {
        if (enchantment.isPossible())
            this.possibleEnchantments.push(enchantment);
    };
    WishingWell.prototype.chooseGift = function () {
        switch (this.selectedGiftId) {
            case "wishingWellGiftPower":
                Saving.saveNumber("gameGiftPower", Saving.loadNumber("gameGiftPower") + 1);
                break;
            case "wishingWellGiftHealth":
                Saving.saveNumber("gameGiftHealth", Saving.loadNumber("gameGiftHealth") + 1);
                break;
            case "wishingWellGiftMagic":
                Saving.saveNumber("gameGiftMagic", Saving.loadNumber("gameGiftMagic") + 1);
                break;
        }
        // We're not pain au chocolating anymore
        Saving.saveBool("wishingWellWeArePainAuChocolating", false);
        // Set the speech
        this.currentSpeech = "wishingWellGiftDoneSpeech";
        // Re calc max hp
        this.getGame().getPlayer().reCalcMaxHp();
        // Update
        this.update();
        this.getGame().updatePlace();
    };
    WishingWell.prototype.createPossibleEnchantments = function () {
        // We empty the array
        this.possibleEnchantments = [];
        // We add the echantments
        this.addEnchantmentIfPossible(new Enchantment(new EnchantmentItem(this.getGame(), "eqItemGlovesLeatherGloves", EqItemType.GLOVES), new EnchantmentItem(this.getGame(), "eqItemGlovesRedEnchantedGloves", EqItemType.GLOVES)));
        this.addEnchantmentIfPossible(new Enchantment(new EnchantmentItem(this.getGame(), "eqItemGlovesLeatherGloves", EqItemType.GLOVES), new EnchantmentItem(this.getGame(), "eqItemGlovesPinkEnchantedGloves", EqItemType.GLOVES)));
        this.addEnchantmentIfPossible(new Enchantment(new EnchantmentItem(this.getGame(), "eqItemWeaponTribalSpear", EqItemType.WEAPON), new EnchantmentItem(this.getGame(), "eqItemWeaponSummoningTribalSpear", EqItemType.WEAPON)));
        this.addEnchantmentIfPossible(new Enchantment(new EnchantmentItem(this.getGame(), "eqItemWeaponMonkeyWizardStaff", EqItemType.WEAPON), new EnchantmentItem(this.getGame(), "eqItemWeaponEnchantedMonkeyWizardStaff", EqItemType.WEAPON)));
        this.addEnchantmentIfPossible(new Enchantment(new EnchantmentItem(this.getGame(), "eqItemBodyArmoursKnightBodyArmour", EqItemType.BODYARMOUR), new EnchantmentItem(this.getGame(), "eqItemBodyArmoursEnchantedKnightBodyArmour", EqItemType.BODYARMOUR)));
        this.addEnchantmentIfPossible(new Enchantment(new EnchantmentItem(this.getGame(), "eqItemHatOctopusKingCrown", EqItemType.HAT), new EnchantmentItem(this.getGame(), "eqItemHatOctopusKingCrownWithJaspers", EqItemType.HAT)));
        this.addEnchantmentIfPossible(new Enchantment(new EnchantmentItem(this.getGame(), "eqItemHatOctopusKingCrown", EqItemType.HAT), new EnchantmentItem(this.getGame(), "eqItemHatOctopusKingCrownWithObsidian", EqItemType.HAT)));
        this.addEnchantmentIfPossible(new Enchantment(new EnchantmentItem(this.getGame(), "eqItemWeaponGiantSpoon", EqItemType.WEAPON), new EnchantmentItem(this.getGame(), "eqItemWeaponGiantSpoonOfDoom", EqItemType.WEAPON)));
        // We create the list array
        this.createPossibleEnchantmentsArrayForTheList();
    };
    WishingWell.prototype.createPossibleEnchantmentsArrayForTheList = function () {
        this.possibleEnchantmentsArrayForTheList = [];
        for (var i = 0; i < this.possibleEnchantments.length; i++) {
            this.possibleEnchantmentsArrayForTheList.push("wishingWellPossibleEnchantment" + i, this.possibleEnchantments[i].getBeforeItem().getText() + " -> " + this.possibleEnchantments[i].getAfterItem().getText());
        }
    };
    WishingWell.prototype.drawCandiesStuff = function (x, y) {
        // If we didn't throw our first candy yet
        if (Saving.loadBool("wishingWellFirstCandyThrown") == false) {
            // The button
            this.renderArea.addAsciiRealButton(Database.getText("wishingWellThrowFirstCandyButton"), x, y, "wishingWellThrowFirstCandyButton", Database.getTranslatedText("wishingWellThrowFirstCandyButton"), true);
            this.renderArea.addLinkCall(".wishingWellThrowFirstCandyButton", new CallbackCollection(this.throwFirstCandy.bind(this)));
        }
        else {
            // The button
            this.renderArea.addAsciiRealButton("Throw " + Algo.pluralFormatNicely(Saving.loadNumber("wishingWellCurrentCandyWishPrice"), " candy", " candies") + " in the well", x, y, "wishingWellThrowCandiesButton");
            this.renderArea.addLinkCall(".wishingWellThrowCandiesButton", new CallbackCollection(this.throwCandies.bind(this)));
        }
    };
    WishingWell.prototype.drawChocolateBarsStuff = function (x, y) {
        // If we're not enchanting
        if (Saving.loadBool("wishingWellWeAreEnchanting") == false) {
            // The button
            this.renderArea.addAsciiRealButton(Database.getText("wishingWellThrowChocolateBarButton"), x, y, "wishingWellThrowChocolateBarButton", Database.getTranslatedText("wishingWellThrowChocolateBarButton"), true);
            // The link
            this.renderArea.addLinkCall(".wishingWellThrowChocolateBarButton", new CallbackCollection(this.throwChocolateBar.bind(this)));
        }
        else {
            // If there's at least one possible enchantment
            if (this.possibleEnchantments.length >= 1) {
                // "Choose the enchantment"
                this.renderArea.drawString(Database.getText("wishingWellChooseEnchantment"), x, y);
                this.renderArea.drawString(Database.getTranslatedText("wishingWellChooseEnchantment"), x, y + 1, true);
                // The list
                this.renderArea.addList(x, x + 30, y + 3, "wishingWellEnchantmentList", new CallbackCollection(this.enchantmentSelected.bind(this)), this.possibleEnchantmentsArrayForTheList);
                // Enchant button
                this.renderArea.addAsciiRealButton(Database.getText("wishingWellEnchantButton"), x, y + 6, "wishingWellEnchantButton", Database.getTranslatedText("wishingWellEnchantButton"));
                this.renderArea.addLinkCall(".wishingWellEnchantButton", new CallbackCollection(this.enchant.bind(this)));
                // Add the link which will call the selectRightEnchantment method after the html dom is created
                this.renderArea.addLinkCallbackCollection(new CallbackCollection(this.selectRightEnchantment.bind(this)));
            }
            else {
                // We tell the player that there's nothing to enchant
                this.renderArea.drawString(Database.getText("wishingWellNoPossibleEnchantment"), x, y);
                this.renderArea.drawString(Database.getTranslatedText("wishingWellNoPossibleEnchantment"), x, y + 1, true);
            }
        }
    };
    WishingWell.prototype.drawLollipopsStuff = function (x, y) {
        // If we didn't throw our first lollipop yet
        if (Saving.loadBool("wishingWellFirstLollipopThrown") == false) {
            // The button
            this.renderArea.addAsciiRealButton(Database.getText("wishingWellThrowFirstLollipopButton"), x, y, "wishingWellThrowFirstLollipopButton", Database.getTranslatedText("wishingWellThrowFirstLollipopButton"), true);
            this.renderArea.addLinkCall(".wishingWellThrowFirstLollipopButton", new CallbackCollection(this.throwFirstLollipop.bind(this)));
        }
        else {
            // The button
            this.renderArea.addAsciiRealButton("Throw " + Algo.pluralFormatNicely(Saving.loadNumber("wishingWellCurrentLollipopWishPrice"), " lollipop", " lollipops") + " in the well", x, y, "wishingWellThrowLollipopsButton");
            this.renderArea.addLinkCall(".wishingWellThrowLollipopsButton", new CallbackCollection(this.throwLollipops.bind(this)));
        }
    };
    WishingWell.prototype.drawPainsAuChocolatStuff = function (x, y) {
        // If we're not pain au chocolating
        if (Saving.loadBool("wishingWellWeArePainAuChocolating") == false) {
            // The button
            this.renderArea.addAsciiRealButton(Database.getText("wishingWellThrowPainAuChocolatButton"), x, y, "wishingWellThrowPainAuChocolatButton", Database.getTranslatedText("wishingWellThrowPainAuChocolatButton"), true);
            // The link
            this.renderArea.addLinkCall(".wishingWellThrowPainAuChocolatButton", new CallbackCollection(this.throwPainAuChocolat.bind(this)));
        }
        else {
            // "Choose your gift"
            this.renderArea.drawString(Database.getText("wishingWellChooseGift"), x, y);
            this.renderArea.drawString(Database.getTranslatedText("wishingWellChooseGift"), x, y + 1, true);
            // The list
            this.renderArea.addList(x, x + 30, y + 3, "wishingWellGiftList", new CallbackCollection(this.giftSelected.bind(this)), this.getGiftsArray());
            // Choose gift button
            this.renderArea.addAsciiRealButton(Database.getText("wishingWellChooseGiftButton"), x, y + 6, "wishingWellChooseGiftButton", Database.getTranslatedText("wishingWellChooseGiftButton"));
            this.renderArea.addLinkCall(".wishingWellChooseGiftButton", new CallbackCollection(this.chooseGift.bind(this)));
            // Add the link which will call the selectRightEnchantment method after the html dom is created
            this.renderArea.addLinkCallbackCollection(new CallbackCollection(this.giftSelected.bind(this), this.selectRightGift.bind(this)));
        }
    };
    WishingWell.prototype.enchant = function () {
        // Get the index of the selected echantment
        var index = parseInt(this.selectedEnchantmentId.substr(30));
        // Enchant (lose the before item and gain the after item)
        this.possibleEnchantments[index].enchant();
        // We're not enchanting anymore
        Saving.saveBool("wishingWellWeAreEnchanting", false);
        // We re-create the lists
        this.createPossibleEnchantments();
        // Set the speech
        this.currentSpeech = "wishingWellEnchantmentDoneSpeech";
        // Update
        this.update();
        this.getGame().updatePlace();
    };
    WishingWell.prototype.enchantmentSelected = function () {
        // Get the selected language id
        this.selectedEnchantmentId = $("#wishingWellEnchantmentList").find(":selected").attr("id");
    };
    WishingWell.prototype.getGiftsArray = function () {
        // Crate the array
        var arr = [];
        // Add the power gift
        arr.push("wishingWellGiftPower");
        arr.push("More power");
        // Add the health gift
        arr.push("wishingWellGiftHealth");
        arr.push("More health");
        // Add the magic gift if we have less than 6 in magic gift
        if (Saving.loadNumber("gameGiftMagic") < 6) {
            arr.push("wishingWellGiftMagic");
            arr.push("More magic");
        }
        // Return the array
        return arr;
    };
    WishingWell.prototype.giftSelected = function () {
        // Get the selected language id
        this.selectedGiftId = $("#wishingWellGiftList").find(":selected").attr("id");
    };
    WishingWell.prototype.selectRightEnchantment = function () {
        // We select the right question
        $("#" + this.selectedEnchantmentId).prop('selected', true);
    };
    WishingWell.prototype.selectRightGift = function () {
        // We select the right question
        $("#" + this.selectedGiftId).prop('selected', true);
    };
    WishingWell.prototype.throwCandies = function () {
        // We save the old price
        var oldPrice = Saving.loadNumber("wishingWellCurrentCandyWishPrice");
        // If we have enough candies
        if (this.getGame().getCandies().getCurrent() >= Saving.loadNumber("wishingWellCurrentCandyWishPrice")) {
            // If we need to be healed
            if (this.getGame().getPlayer().getHp() < this.getGame().getPlayer().getMaxHp()) {
                // Pay the price
                this.getGame().getCandies().add(-Saving.loadNumber("wishingWellCurrentCandyWishPrice"));
                // Heal the player
                this.getGame().getPlayer().setHp(this.getGame().getPlayer().getMaxHp());
                // Set the speech
                this.currentSpeech = "wishingWellThrewCandiesSpeech";
                // Set the next price
                Saving.saveNumber("wishingWellCurrentCandyWishPrice", Saving.loadNumber("wishingWellPreviousCandyWishPrice") * 2 + Saving.loadNumber("wishingWellCurrentCandyWishPrice") * 2);
                Saving.saveNumber("wishingWellPreviousCandyWishPrice", oldPrice);
            }
            else {
                // Set the speech
                this.currentSpeech = "wishingWellNoWoundSpeech";
            }
            // Update
            this.update();
            this.getGame().updatePlace();
        }
    };
    WishingWell.prototype.throwChocolateBar = function () {
        if (this.getGame().getChocolateBars().getCurrent() >= 1) {
            // Pay the price
            this.getGame().getChocolateBars().add(-1);
            // Set the speech (depending on if it's the first bar we throw or not)
            if (Saving.loadNumber("wishingWellHowManyChocolateBarsThrown") == 0)
                this.currentSpeech = "wishingWellChocolateBarIntroductionSpeech";
            else
                this.currentSpeech = "wishingWellThrewChocolateBarSpeech";
            // Increase the number of chocolate bars thrown
            Saving.saveNumber("wishingWellHowManyChocolateBarsThrown", Saving.loadNumber("wishingWellHowManyChocolateBarsThrown") + 1);
            // We are now enchanting
            Saving.saveBool("wishingWellWeAreEnchanting", true);
            // Update
            this.update();
            this.getGame().updatePlace();
        }
    };
    WishingWell.prototype.throwFirstCandy = function () {
        if (this.getGame().getCandies().getCurrent() >= 1) {
            this.getGame().getCandies().add(-1); // We use one candy
            this.currentSpeech = "wishingWellCandyIntroductionSpeech"; // Set the speech
            Saving.saveBool("wishingWellFirstCandyThrown", true); // Change the bool
            this.update();
            this.getGame().updatePlace();
        }
    };
    WishingWell.prototype.throwFirstLollipop = function () {
        if (this.getGame().getLollipops().getCurrent() >= 1) {
            this.getGame().getLollipops().add(-1); // We use one lollipop
            this.currentSpeech = "wishingWellLollipopIntroductionSpeech"; // Set the speech
            Saving.saveBool("wishingWellFirstLollipopThrown", true); // Change the bool
            this.update();
            this.getGame().updatePlace();
        }
    };
    WishingWell.prototype.throwLollipops = function () {
        // If we have enough lollipops
        if (this.getGame().getLollipops().getCurrent() >= Saving.loadNumber("wishingWellCurrentLollipopWishPrice")) {
            // Pay the price
            this.getGame().getLollipops().add(-Saving.loadNumber("wishingWellCurrentLollipopWishPrice"));
            // Add the same amount of candies
            this.getGame().getCandies().add(Math.ceil(Saving.loadNumber("wishingWellCurrentLollipopWishPrice") / 2));
            // Set the speech
            this.currentSpeech = "wishingWellThrewLollipopsSpeech";
            // Set the next price
            Saving.saveNumber("wishingWellCurrentLollipopWishPrice", Saving.loadNumber("wishingWellCurrentLollipopWishPrice") * 10);
            // Update
            this.update();
            this.getGame().updatePlace();
        }
    };
    WishingWell.prototype.throwPainAuChocolat = function () {
        if (this.getGame().getPainsAuChocolat().getCurrent() >= 1) {
            // Pay the price
            this.getGame().getPainsAuChocolat().add(-1);
            // Set the speech (depending on if it's the first pain au chocolat we throw or not)
            if (Saving.loadNumber("wishingWellHowManyPainsAuChocolatThrown") == 0)
                this.currentSpeech = "wishingWellPainAuChocolatIntroductionSpeech";
            else
                this.currentSpeech = "wishingWellThrewPainAuChocolatSpeech";
            // Increase the number of pains au chocolat thrown
            Saving.saveNumber("wishingWellHowManyPainsAuChocolatThrown", Saving.loadNumber("wishingWellHowManyPainsAuChocolatThrown") + 1);
            // We are now pain au chocolating
            Saving.saveBool("wishingWellWeArePainAuChocolating", true);
            // Update
            this.update();
            this.getGame().updatePlace();
        }
    };
    WishingWell.prototype.update = function () {
        // Erase everything
        this.renderArea.resetAllButSize();
        // Back to the map button
        this.addBackToMainMapButton(this.renderArea, "wishingWellBackToTheMapButton");
        // Draw the well
        this.renderArea.drawArray(Database.getAscii("places/wishingWell"), 38, 3);
        // Draw the speech if currentSpeech isn't null
        if (this.currentSpeech != null) {
            this.renderArea.drawSpeech(Database.getText(this.currentSpeech), 3, 75, 95, "wishingWellSpeech", Database.getTranslatedText(this.currentSpeech));
        }
        // Draw various stuff around it
        this.drawCandiesStuff(0, 4);
        if (this.getGame().getLollipops().getMax() >= 1)
            this.drawLollipopsStuff(0, 9);
        if (this.getGame().getChocolateBars().getMax() >= 1)
            this.drawChocolateBarsStuff(0, 14);
        if (this.getGame().getPainsAuChocolat().getMax() >= 1)
            this.drawPainsAuChocolatStuff(0, 24);
    };
    return WishingWell;
})(Place);
///<reference path="QuestEntity.ts"/>
var Wolf = (function (_super) {
    __extends(Wolf, _super);
    // Constructor
    function Wolf(quest, pos) {
        _super.call(this, quest, pos, new Naming("A wolf", "a wolf"), new RenderArea(7, 3), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 1), new Pos(7, 2))), new QuestEntityMovement());
        // At first, we're not taking the decision to begin running
        this.takeTheDecisionToRunTimer = null;
        // Set the area transparency
        this.setTransparency(new RenderTransparency(" "));
        // At first we're looking left and standing
        this.setIsLookingLeft(true);
        this.setIsStanding(true);
        // Set gravity
        this.getQuestEntityMovement().setGravity(true);
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(45);
        this.setHp(45);
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("Its fangs", "its fangs"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, 0), new Pos(9, 3))), 10));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setFixedDelay(2);
    }
    // update()
    Wolf.prototype.update = function () {
        // Calculate the distance from the player
        var distanceFromPlayer = this.getGlobalPosition().plus(new Pos(3, 0)).getDistance(this.getQuest().getGame().getPlayer().getGlobalPosition());
        // If the player is on our left
        if (distanceFromPlayer.x > 0) {
            // We're looking left
            this.setIsLookingLeft(true);
        }
        else {
            // We're looking right
            this.setIsLookingLeft(false);
        }
        // If we're standing
        if (this.isStanding) {
            // If we're not already taking the decision to run BUT the running movement would be possible
            if (this.takeTheDecisionToRunTimer == null && this.testNewGlobalPosition(this.getGlobalPosition().plus(new Pos(this.getRunningSpeed(), 0)))) {
                // We take the decision to run by setting the timer
                this.takeTheDecisionToRunTimer = Random.between(2, 6);
            }
            else if (this.takeTheDecisionToRunTimer != null) {
                // We decrease the timer
                this.takeTheDecisionToRunTimer -= 1;
                // If the timer is <= 0 and the running movement would be possible
                if (this.takeTheDecisionToRunTimer <= 0 && this.testNewGlobalPosition(this.getGlobalPosition().plus(new Pos(this.getRunningSpeed(), 0)))) {
                    this.setIsStanding(false); // We run
                    this.takeTheDecisionToRunTimer = null; // Not taking any decision anymore
                }
            }
        }
        else {
            // If the running movement won't be possible next turn
            if (this.testNewGlobalPosition(this.getGlobalPosition().plus(new Pos(this.getRunningSpeed(), 0))) == false) {
                // We stand
                this.setIsStanding(true);
            }
        }
        // Call the mother class update
        _super.prototype.update.call(this);
    };
    // willDie()
    Wolf.prototype.willDie = function () {
        this.getQuest().getGame().getQuestLog().addMessage(new QuestLogMessage(this.getDeathMessage() + " (and found " + Algo.pluralFormat(this.getQuest().foundCandies(100 + 50 * Random.upTo(10)), " candy", " candies") + ")", this.getQuest().getCandiesFoundMessage()));
    };
    // Private methods
    Wolf.prototype.getRunningSpeed = function () {
        return (this.isLookingLeft ? -1 : 1);
    };
    Wolf.prototype.reDrawArea = function () {
        this.getRenderArea().drawArray(Database.getAscii("places/quests/forest/wolf/" + (this.isLookingLeft ? "left" : "right") + (this.isStanding ? "Standing" : "Running")));
    };
    Wolf.prototype.setIsLookingLeft = function (isLookingLeft) {
        // If the value is different
        if (isLookingLeft != this.isLookingLeft) {
            this.isLookingLeft = isLookingLeft; // Set the value
            this.updateQuestEntityMovementOffset(); // Update the movement
            this.reDrawArea(); // Update the area
        }
    };
    Wolf.prototype.setIsStanding = function (isStanding) {
        // If the value is different
        if (isStanding != this.isStanding) {
            this.isStanding = isStanding; // Set the value
            this.updateQuestEntityMovementOffset(); // Update the movement
            this.reDrawArea(); // Update the area
        }
    };
    Wolf.prototype.updateQuestEntityMovementOffset = function () {
        // If we're standing
        if (this.isStanding) {
            // No movement
            this.getQuestEntityMovement().setOffset(new Pos(0, 0));
        }
        else {
            // Set the movement depending on our orientation
            this.getQuestEntityMovement().setOffset(new Pos(this.getRunningSpeed(), 0));
        }
    };
    return Wolf;
})(QuestEntity);
///<reference path="EqItem.ts"/>
var WoodenSword = (function (_super) {
    __extends(WoodenSword, _super);
    // Constructor
    function WoodenSword() {
        _super.call(this, "eqItemWeaponWoodenSword", "eqItemWeaponWoodenSwordName", "eqItemWeaponWoodenSwordDescription", "eqItems/weapons/woodenSword");
    }
    // Public getters
    WoodenSword.prototype.getQuestEntityWeapon = function (quest, player) {
        var qew = new QuestEntityWeapon(quest, player, new Naming("A wooden sword", "a wooden sword"), player.getClassicCollisionBoxCollection(), 1);
        qew.getCloseCombatDelay().setFixedDelay(4, 0);
        return qew;
    };
    return WoodenSword;
})(EqItem);
///<reference path="QuestEntity.ts"/>
var Xinopherydon = (function (_super) {
    __extends(Xinopherydon, _super);
    // Constructor
    function Xinopherydon(quest, pos) {
        _super.call(this, quest, pos, new Naming("A xinopherydon", "a xinopherydon"), new RenderArea(17, 6), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 1), new Pos(5, 1)), new CollisionBox(this, new Pos(0, 2), new Pos(9, 1)), new CollisionBox(this, new Pos(12, 2), new Pos(5, 1)), new CollisionBox(this, new Pos(3, 3), new Pos(14, 1)), new CollisionBox(this, new Pos(4, 4), new Pos(5, 1)), new CollisionBox(this, new Pos(10, 4), new Pos(5, 1)), new CollisionBox(this, new Pos(5, 5), new Pos(3, 1)), new CollisionBox(this, new Pos(11, 5), new Pos(3, 1))), new QuestEntityMovement());
        // Set gravity
        this.getQuestEntityMovement().setGravity(true);
        this.getQuestEntityMovement().setWormsLike(true);
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(5000);
        this.setHp(5000);
        // Set the ascii art and the transparent character
        this.getRenderArea().drawArray(Database.getAscii("places/quests/fortress/xinopherydon"));
        this.setTransparency(new RenderTransparency(" "));
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("Its huge body", "its huge body"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(19, 8))), 800));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setFixedDelay(20);
    }
    // update()
    Xinopherydon.prototype.update = function () {
        _super.prototype.update.call(this);
        console.log(this.getHp());
        // We heal ourselves if the player is too far on the left
        if (this.getQuest().getGame().getPlayer().getGlobalPosition().x < this.getGlobalPosition().x - 50)
            this.heal(50);
    };
    // willDie()
    Xinopherydon.prototype.willDie = function () {
        // Candies
        this.getQuest().getGame().getQuestLog().addMessage(new QuestLogMessage(this.getDeathMessage() + " (and found " + Algo.pluralFormat(this.getQuest().foundCandies(30000), " candy", " candies") + ")", this.getQuest().getCandiesFoundMessage()));
        // The claw
        this.getQuest().foundGridOrEqItem(new QuestItemFound(this.getQuest(), "gridItemPossessedXinopherydonClaw", "You found a strange claw on the xinopherydon's corpse.", "You gain a strange claw."));
    };
    return Xinopherydon;
})(QuestEntity);
///<reference path="GridItem.ts"/>
var XinopherydonClaw = (function (_super) {
    __extends(XinopherydonClaw, _super);
    function XinopherydonClaw() {
        _super.apply(this, arguments);
    }
    XinopherydonClaw.prototype.hit = function (player, quest, questEntity, damage, reason) {
        return damage * 2;
    };
    return XinopherydonClaw;
})(GridItem);
///<reference path="Quest.ts"/>
var Yourself = (function (_super) {
    __extends(Yourself, _super);
    // Constructor
    function Yourself(game) {
        _super.call(this, game);
        // Sentences flying across the screen
        this.sentences = [];
        // Sentences timer (to avoid having sentences at the very beginning of the quest)
        this.sentencesTimer = 30;
        // Resize the quest
        this.resizeQuest(100, 20);
        // Add collision boxes around
        this.addPlayerCollisionBoxes(true, true, true, true);
        // Add the player
        this.getGame().getPlayer().loadCandyBoxCharacter(this);
        this.getGame().getPlayer().setGlobalPosition(new Pos(0, 19));
        this.configPlayerOrClone(this.getGame().getPlayer());
        this.addEntity(this.getGame().getPlayer());
        // Add yourself
        this.addYourself();
        // Add the walls
        this.addWalls();
        // Add the message
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You are now fighting yourself."));
    }
    // Public methods
    Yourself.prototype.configPlayerOrClone = function (entity) {
        entity.setQuestEntityMovement(new QuestEntityMovement(new Pos(1, 0)));
        entity.getQuestEntityMovement().setGravity(true);
    };
    Yourself.prototype.endQuest = function (win) {
        // We add some messages
        if (win) {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You managed to beat yourself!"));
            Saving.saveBool("mainMapDoneDesert", true); // The desert is done
        }
        else {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You died trying to beat yourself."));
        }
        // We call the endQuest method of our mother class
        _super.prototype.endQuest.call(this, win);
    };
    Yourself.prototype.update = function () {
        if (this.getQuestEnded() == false) {
            // Test if the player is dead, if so, end the quest and return
            if (this.getGame().getPlayer().shouldDie()) {
                this.endQuest(false);
                return;
            }
            // Test if the player won the quest, if so, end the quest and return
            if (this.thePlayerWon()) {
                this.endQuest(true);
                return;
            }
            // Handle sentences
            this.handleSentences();
            // Update entities
            this.updateEntities();
        }
        // Draw
        this.preDraw();
        this.drawEntities();
        this.drawSentences(); // Draw the sentences
        this.drawAroundQuest();
        if (this.getQuestEnded() == false)
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestNoKeeping");
        else if (this.getQuestEndedAndWeWon() == false)
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestNoKeepingBecauseLose");
        else
            this.addExitQuestButton(new CallbackCollection(this.getGame().goToMainMap.bind(this.getGame())), "buttonExitQuestKeeping");
        this.postDraw();
    };
    // Private methods
    Yourself.prototype.addYourself = function () {
        this.yourself = new YourselfEntity(this, new Pos(96, 19));
        this.yourself.setHealthBar(new QuestEntityHealthBar(this.yourself, new Pos(100, 1), new Pos(0, 0), QuestEntityHealthBarPositionType.FIXED_ON_PAGE, true, true, BarType.HEALTH));
        this.addEntity(this.yourself);
    };
    Yourself.prototype.addWalls = function () {
        // Create the wall entity
        this.addEntity(new Wall(this, new Pos(0, 0)));
        var wall = (this.getLastEntity());
        // Add the boxes
        wall.addBox(new Pos(-1, -1), new Pos(102, 1));
        wall.addBox(new Pos(-1, 0), new Pos(1, 21));
        wall.addBox(new Pos(0, 20), new Pos(101, 1));
        wall.addBox(new Pos(101, 0), new Pos(1, 20));
    };
    Yourself.prototype.drawSentences = function () {
        // Call the sentences update methods
        for (var i = 0; i < this.sentences.length; i++) {
            this.sentences[i].draw(this.getRenderArea());
        }
    };
    Yourself.prototype.handleSentences = function () {
        // If it's time to add sentences
        if (this.sentencesTimer <= 0) {
            // If we don't have the crown
            if (this.getGame().isEquipped("hat", "eqItemHatOctopusKingCrown") == false) {
                // We possibly add a randomly-chosen sentence
                if (this.sentences.length == 0 || Random.oneChanceOutOf(10))
                    this.sentences.push(new YourselfSentence(this, Random.fromArray(["You need to be more self-confident",
                        "You need more confidence!",
                        "My crown is called content, a crown that seldom kings enjoy",
                        "Self-confidence is having confidence in oneself",
                        "The Octopus King helps those who help themselves",
                        "It's hard to beat yourself",
                        "If my head looks like an \"o\", what does my belly look like?",
                        "What does the squirrel do all the day?",
                        "I wonder what is inside the first house",
                        "I guess it's time for me to become a King",
                        "With a crown on your head, you just feel they will never hurt you",
                        "Look at all these flying sentences",
                        "Am I talking to myself?",
                        "There are three shark fins",
                        "Did you look under the carpet?",
                        "Look at this bar above",
                        "Maybe you could change its corners",
                        "Nonsense",
                        "Confidence confidence confidence",
                        "If there be no enemy there's no fight. If no fight, no victory and if no victory there is no crown",
                        "A crown is merely a hat that lets the rain in",
                        "I spent a lot of time with a crown on my head",
                        "Sometime I wish the aliens would abduct me and crown me as their leader",
                        "The crown of life is neither happiness nor annihilation; it is understanding",
                        "Tentacles tentacles tentacles"]), Random.flipACoin(), Random.between(1, 12)));
            }
            else {
                // We possibly add the sentence
                if (this.sentences.length == 0 || Random.oneChanceOutOf(20))
                    this.sentences.push(new YourselfSentence(this, Random.fromArray(["You are very self-confident."]), Random.flipACoin(), Random.between(1, 12)));
            }
        }
        else {
            this.sentencesTimer -= 1;
        }
        // Call the sentences update methods
        for (var i = 0; i < this.sentences.length; i++) {
            // If it should be deleted, we remove it from the array
            if (this.sentences[i].update()) {
                this.sentences.splice(i, 1);
                i--;
            }
        }
    };
    Yourself.prototype.thePlayerWon = function () {
        // If yourself is dead, we return true
        if (this.yourself.shouldDie())
            return true;
        // Else we return false
        return false;
    };
    return Yourself;
})(Quest);
///<reference path="QuestEntity.ts"/>
var YourselfEntity = (function (_super) {
    __extends(YourselfEntity, _super);
    // Constructor
    function YourselfEntity(quest, pos) {
        _super.call(this, quest, pos, new Naming("Yourself", "yourself"), new RenderArea(3, 1), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 0), new Pos(3, 1))), new QuestEntityMovement(new Pos(-1, 0)));
        // Set gravity
        this.getQuestEntityMovement().setGravity(true);
        // Set destructible
        this.setDestructible(true);
        this.setMaxHp(this.getQuest().getGame().getPlayer().getMaxHp());
        this.setHp(this.getQuest().getGame().getPlayer().getHp());
        // Set the ascii art
        this.getRenderArea().drawString("\\o/");
        // Set the weapon and its delay
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("The same weapon as yours", "the same weapon as yours"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(5, 3))), 0));
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setFixedDelay();
    }
    // setHp()
    YourselfEntity.prototype.setHp = function (hp) {
        // If we don't have the crown
        if (this.getQuest().getGame().isEquipped("hat", "eqItemHatOctopusKingCrown") == false) {
            // When anyone want to change our hp, we change the player's hp first :)
            this.getQuest().getGame().getPlayer().setHp(hp);
        }
        else {
            // When anyone want to change our hp, we change the player's hp first :) (but here we keep it over 0!)
            if (hp > 0)
                this.getQuest().getGame().getPlayer().setHp(hp);
            else
                this.getQuest().getGame().getPlayer().setHp(1);
        }
        _super.prototype.setHp.call(this, hp);
    };
    // willDie()
    YourselfEntity.prototype.willDie = function () {
        this.getQuest().getGame().getQuestLog().addMessage(new QuestLogMessage(this.getDeathMessage() + " (and found " + Algo.pluralFormat(this.getQuest().foundCandies(Math.floor(this.getQuest().getGame().getCandies().getCurrent() / 10)), " candy", " candies") + ")", this.getQuest().getCandiesFoundMessage()));
        this.getQuest().foundGridOrEqItem(new QuestItemFound(this.getQuest(), "eqItemBootsBootsOfIntrospection", "You found the boots of introspection", "You gain the boots of introspection"));
    };
    return YourselfEntity;
})(QuestEntity);
var YourselfSentence = (function () {
    // Constructor
    function YourselfSentence(quest, text, isGoingRight, y) {
        // Set from parameters
        this.quest = quest;
        this.text = text;
        this.isGoingRight = isGoingRight;
        // Set the position
        if (this.isGoingRight)
            this.position = new Pos(-this.text.length, y);
        else
            this.position = new Pos(100, y);
    }
    // Public methods
    YourselfSentence.prototype.draw = function (renderArea) {
        renderArea.drawString(this.text, this.quest.getRealQuestPosition().x + this.quest.getGlobalDrawingOffset().x + this.position.x, this.quest.getRealQuestPosition().y + this.quest.getGlobalDrawingOffset().y + this.position.y);
    };
    YourselfSentence.prototype.update = function () {
        if (this.isGoingRight) {
            this.position.x += 1;
            if (this.position.x > 100)
                return true; // Delete the sentence
        }
        else {
            this.position.x -= 1;
            if (this.position.x < -this.text.length)
                return true; // Delete the sentence
        }
        // We don't delete the sentence : we return false
        return false;
    };
    return YourselfSentence;
})();
///<reference path="./../../main/Quest.ts"/>
// -------------------------------
// We register on the Arena module
// -------------------------------
function HardcorePlatformer_getNewQuest(game) {
    return new HardcorePlatformer_Quest(game);
}
TheArenaModule.addQuest(new TheArenaModuleQuest("hardcorePlatformer", HardcorePlatformer_getNewQuest.bind(this)));
// -------------------------------------------------------------------------------
// We create our HardcorePlatformer_Quest class, which herits from the Quest class 
// -------------------------------------------------------------------------------
var HardcorePlatformer_Quest = (function (_super) {
    __extends(HardcorePlatformer_Quest, _super);
    // Constructor
    function HardcorePlatformer_Quest(game) {
        _super.call(this, game);
        // Resize the quest
        this.resizeQuest(240, 13);
        // Add collision boxes around
        this.addPlayerCollisionBoxes(true, false, true, true);
        // Add the player
        this.getGame().getPlayer().loadCandyBoxCharacter(this);
        this.getGame().getPlayer().setGlobalPosition(new Pos(0, 8));
        this.configPlayerOrClone(this.getGame().getPlayer());
        this.addEntity(this.getGame().getPlayer());
        // Add the ground
        this.addGround();
        // Add the spikes
        this.addAllSpikes(this.getGame().getPlayer().getMaxHp() * 100);
        // Add the message
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("This is going to be HARDCORE."));
    }
    // Public methods
    HardcorePlatformer_Quest.prototype.castPlayerAntiGravityPotion = function () {
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("Damn. These potions don't seem to work here :("));
    };
    HardcorePlatformer_Quest.prototype.castPlayerTeleport = function () {
        _super.prototype.castPlayerTeleport.call(this, new Pos(0, 8), new Pos(1, 1));
    };
    HardcorePlatformer_Quest.prototype.configPlayerOrClone = function (entity) {
        entity.setQuestEntityMovement(new QuestEntityMovement(new Pos(1, 0)));
        entity.getQuestEntityMovement().setGravity(true);
        entity.getQuestEntityMovement().setWormsLike(true);
    };
    HardcorePlatformer_Quest.prototype.endQuest = function (win) {
        // We add some messages
        if (win) {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("Yay, you made it!! You can now tell all your friends."));
        }
        else {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You failed. Try again :)"));
        }
        // We call the endQuest method of our mother class
        _super.prototype.endQuest.call(this, win);
    };
    HardcorePlatformer_Quest.prototype.update = function () {
        if (this.getQuestEnded() == false) {
            // Test if the player won the quest, if so, end the quest and return
            if (this.thePlayerWon()) {
                this.endQuest(true);
                return;
            }
            // Test if the player is dead, if so, end the quest and return
            if (this.getGame().getPlayer().shouldDie()) {
                this.endQuest(false);
                return;
            }
            // Update entities
            this.updateEntities();
        }
        // Draw
        this.preDraw();
        this.getRenderArea().drawArray(Database.getAscii("arena/hardcorePlatformer/background"), this.getRealQuestPosition().x, this.getRealQuestPosition().y);
        this.drawEntities();
        this.drawAroundQuest();
        this.addExitQuestButton(new CallbackCollection(this.endQuest.bind(this, false), this.getGame().goToMainMap.bind(this.getGame()), this.getGame().getStatusBar().selectTabByType.bind(this.getGame().getStatusBar(), StatusBarTabType.THE_ARENA), this.getGame().goToTheArena.bind(this.getGame())), "buttonExitQuestKeeping");
        this.postDraw();
    };
    // Private methods
    HardcorePlatformer_Quest.prototype.addAllSpikes = function (damage) {
        // Add long spikes on the roof (to avoid the usage of rocket boots)
        this.addSpikes(new Spikes(this, new Pos(0, 0), 300, damage, true));
        // Add the first group of spikes
        this.addSpikes(new Spikes(this, new Pos(25, 8), 4, damage));
        this.addSpikes(new Spikes(this, new Pos(37, 8), 6, damage));
        this.addSpikes(new Spikes(this, new Pos(49, 8), 6, damage));
        this.addSpikes(new Spikes(this, new Pos(60, 8), 6, damage));
        this.addSpikes(new Spikes(this, new Pos(71, 8), 6, damage));
        // Add the second group
        this.addSpikes(new Spikes(this, new Pos(112, 8), 6, damage));
        this.addSpikes(new Spikes(this, new Pos(121, 8), 2, damage));
        this.addSpikes(new Spikes(this, new Pos(127, 8), 2, damage));
        this.addSpikes(new Spikes(this, new Pos(133, 8), 2, damage));
        this.addSpikes(new Spikes(this, new Pos(139, 8), 2, damage));
        // Add the third group
        this.addSpikes(new HardcorePlatformer_Spikes(this, new Pos(196, 8), 2, damage));
        this.addSpikes(new HardcorePlatformer_Spikes(this, new Pos(198, 8), 2, damage));
        this.addSpikes(new HardcorePlatformer_Spikes(this, new Pos(200, 8), 2, damage));
        this.addSpikes(new HardcorePlatformer_Spikes(this, new Pos(202, 8), 2, damage));
        this.addSpikes(new HardcorePlatformer_Spikes(this, new Pos(204, 8), 2, damage));
        this.addSpikes(new HardcorePlatformer_Spikes(this, new Pos(206, 8), 2, damage));
        this.addSpikes(new HardcorePlatformer_Spikes(this, new Pos(208, 8), 2, damage));
        this.addSpikes(new HardcorePlatformer_Spikes(this, new Pos(210, 8), 2, damage));
        this.addSpikes(new HardcorePlatformer_Spikes(this, new Pos(212, 8), 2, damage));
        this.addSpikes(new HardcorePlatformer_Spikes(this, new Pos(214, 8), 2, damage));
        this.addSpikes(new HardcorePlatformer_Spikes(this, new Pos(216, 8), 2, damage));
        this.addSpikes(new HardcorePlatformer_Spikes(this, new Pos(218, 8), 2, damage));
        this.addSpikes(new HardcorePlatformer_Spikes(this, new Pos(220, 8), 2, damage));
        this.addSpikes(new Spikes(this, new Pos(222, 8), 2, damage));
    };
    HardcorePlatformer_Quest.prototype.addGround = function () {
        var wall = new Wall(this, new Pos(0, 0));
        wall.addBox(new Pos(0, 9), new Pos(240, 3));
        this.addEntity(wall);
    };
    HardcorePlatformer_Quest.prototype.addSpikes = function (spikes) {
        this.addEntity(spikes);
    };
    HardcorePlatformer_Quest.prototype.thePlayerWon = function () {
        // If the player is at the right of the desert, we return true
        if (this.getGame().getPlayer().getGlobalPosition().x >= 240)
            return true;
        // Else we return false
        return false;
    };
    return HardcorePlatformer_Quest;
})(Quest);
///<reference path="./../../main/Spikes.ts"/>
var HardcorePlatformer_Spikes = (function (_super) {
    __extends(HardcorePlatformer_Spikes, _super);
    function HardcorePlatformer_Spikes() {
        _super.apply(this, arguments);
    }
    // Public methods
    HardcorePlatformer_Spikes.prototype.update = function () {
        // If the player is too close, we disappear!!
        if (this.getQuest().getGame().getPlayer().getGlobalPosition().x > this.getGlobalPosition().x - 5)
            this.setDead(true);
        // Call the mother class update method
        _super.prototype.update.call(this);
    };
    return HardcorePlatformer_Spikes;
})(Spikes);
///<reference path="./../../main/Quest.ts"/>
// -------------------------------
// We register on the Arena module
// -------------------------------
function PeacefulForest_getNewQuest(game) {
    return new PeacefulForest_Quest(game);
}
TheArenaModule.addQuest(new TheArenaModuleQuest("peacefulForest", PeacefulForest_getNewQuest.bind(this)));
// ---------------------------------------------------------------------------
// We create our PeacefulForest_Quest class, which herits from the Quest class 
// ---------------------------------------------------------------------------
var PeacefulForest_Quest = (function (_super) {
    __extends(PeacefulForest_Quest, _super);
    // -----------
    // Constructor
    // -----------
    function PeacefulForest_Quest(game) {
        // Call the constructor of our mother class, the Quest class (don't change that)
        _super.call(this, game);
        // Resize the quest
        this.resizeQuest(100, 10); // 100 characters width, 10 characters height
        // Add collision boxes around
        this.addPlayerCollisionBoxes(true, false, true, true); // this means that the player will only be able to get out of the quest on the right side
        // Handle the player
        this.getGame().getPlayer().loadCandyBoxCharacter(this); // this means that we load the small ("\o/") character, not the big one used in the sea
        this.getGame().getPlayer().setGlobalPosition(new Pos(0, 9)); // the player will begin the quest at the x position of 0 and the y position of 9
        this.configPlayerOrClone(this.getGame().getPlayer()); // configure the player (see below in the public methods part)
        this.addEntity(this.getGame().getPlayer()); // finally add the player to the quest
        // Add some treeeeees (it uses a private method below)
        this.addATree(12);
        this.addATree(25);
        this.addATree(28);
        this.addATree(35);
        this.addATree(39);
        this.addATree(42);
        this.addATree(48);
        this.addATree(56);
        this.addATree(59);
        this.addATree(65);
        this.addATree(79);
        this.addATree(87);
        this.addATree(91);
        // Add a ground because we don't want our trees to fall down (it uses a private method below)
        this.addGround();
        // Add the first message in the quest log
        this.getGame().getQuestLog().addMessage(new QuestLogMessage("You enter the peaceful forest. Trees all around you. It's a great place to calm down."));
    }
    // --------------
    // Public methods
    // --------------
    // Method used to configure the player (called in the constructor)
    PeacefulForest_Quest.prototype.configPlayerOrClone = function (entity) {
        entity.setQuestEntityMovement(new QuestEntityMovement(new Pos(1, 0))); // the player is going to the right
        entity.getQuestEntityMovement().setGravity(true); // it is affected by gravity
        entity.getQuestEntityMovement().setWormsLike(false); // the player won't be able to walk over one character high steps (so that it will not walk over trees..)
    };
    // Method called by the update method when the quest is over
    PeacefulForest_Quest.prototype.endQuest = function (win) {
        // If we won the quest
        if (win) {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You reached the end of the peaceful forest. It really wasn't too hard."));
        }
        else {
            this.getGame().getQuestLog().addMessage(new QuestLogMessage("You died in the peaceful forest. How did you even manage to do that?"));
        }
        // Call the endQuest method of our mother class, the Quest class
        _super.prototype.endQuest.call(this, win);
    };
    // Method called automatically ten times per second. It updates everything in the quest
    PeacefulForest_Quest.prototype.update = function () {
        // If the quest isn't finished yet
        if (this.getQuestEnded() == false) {
            // Test if the player won the quest, if so, end the quest and return
            if (this.thePlayerWon()) {
                this.endQuest(true); // true = we won
                return;
            }
            // Test if the player is dead, if so, end the quest and return
            if (this.getGame().getPlayer().shouldDie()) {
                this.endQuest(false); // false = we failed
                return;
            }
            // Update entities (it makes everything move, it handles collisions, gravity, damage...)
            this.updateEntities();
        }
        // Draw everything
        this.preDraw(); // a special method we need to call before drawing anything
        this.drawEntities(); // draw all entities
        this.drawAroundQuest(); // draw the stuff around (the spells, etc)
        this.addExitQuestButton(new CallbackCollection(this.endQuest.bind(this, false), this.getGame().goToMainMap.bind(this.getGame()), this.getGame().getStatusBar().selectTabByType.bind(this.getGame().getStatusBar(), StatusBarTabType.THE_ARENA), this.getGame().goToTheArena.bind(this.getGame())), "buttonExitQuestKeeping"); // draw the button to exit the quest
        this.postDraw(); // a special method we need to call after drawing everything
    };
    // --------------
    // Public methods
    // --------------
    // Method called in the constructor. It is used to add a tree at a given x position.
    PeacefulForest_Quest.prototype.addATree = function (x) {
        // Create the tree
        var tree = new PeacefulForest_Tree(this, new Pos(x, 9)); // We use the x position given in parameter, the y position match the ground's position
        // Set the tree's health bar
        tree.setHealthBar(new QuestEntityHealthBar(tree, new Pos(3, 1))); // 3 characters width, 1 character height
        // Finally add the tree to the quest
        this.addEntity(tree);
    };
    // Method called in the constructor. It is used to add a ground to the quest, therefore preventing the trees to fall down.
    PeacefulForest_Quest.prototype.addGround = function () {
        // Create the ground entity
        var ground = new Wall(this, new Pos(0, 10)); // position 0, 10
        // Add the ground box (100 characters width, 1 character height)
        ground.addBox(new Pos(0, 0), new Pos(100, 1));
        // Add the ground entity
        this.addEntity(ground);
    };
    // Method called by the update method above to know if the player won the quest
    PeacefulForest_Quest.prototype.thePlayerWon = function () {
        // If the player reached the right limit of the quest, we return true because he won the quest
        if (this.getGame().getPlayer().getGlobalPosition().x >= 100)
            return true;
        // Else we return false
        return false;
    };
    return PeacefulForest_Quest;
})(Quest);
///<reference path="../../main/QuestEntity.ts"/>
var PeacefulForest_Tree = (function (_super) {
    __extends(PeacefulForest_Tree, _super);
    // Constructor
    function PeacefulForest_Tree(quest, pos) {
        _super.call(this, quest, pos, new Naming("A tree", "a tree"), new RenderArea(3, 1), new Pos(0, 0), new CollisionBoxCollection(new CollisionBox(this, new Pos(0, 0), new Pos(3, 1))), new QuestEntityMovement() // The tree's movement. We don't give any parameter because the tree isn't actually moving.
        );
        // Set gravity : the tree can fall (even if it probably won't because it lays on the ground)
        this.getQuestEntityMovement().setGravity(true);
        // Set destructible
        this.setDestructible(true); // The tree will be destructible
        this.setMaxHp(50); // Set the maximum health points
        this.setHp(50); // Set the health points
        // Set the ascii art
        this.getRenderArea().drawString("|||", 0, 0); // Draw the tree ("|||") on the render area
        // Add the tree's weapon. It will be attacking with its leaves.
        this.addQuestEntityWeapon(new QuestEntityWeapon(this.getQuest(), this, new Naming("Its leaves", "its leaves"), new CollisionBoxCollection(new CollisionBox(this, new Pos(-1, -1), new Pos(5, 2))), 1)); // The weapon's damage (1)
        // Set the weapon's delay
        this.getLastQuestEntityWeapon().getCloseCombatDelay().setFixedDelay(5); // This means the tree will inflict damage every 5 seconds
    }
    return PeacefulForest_Tree;
})(QuestEntity);
