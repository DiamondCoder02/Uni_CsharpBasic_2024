namespace GenericsExampleBasic {     public class ValueComparator     {         // egyszerű példa: két egész számot hasonlítunk össze...mi van, ha nem egész számokat szeretnénk összehasonlítani?         //public static bool AreEqual(int value1, int value2) => value1.Equals(value2);          // Általánosítás: az int típusú argumentumokat átírjuk object-té -> lehetséges megoldás, de nem típusbiztos!         //public static bool AreEqual(object value1, object value2) => value1.Equals(value2);          // Típusbiztosság garancia -> metódus túlterhelés -> lehetséges megoldás, de később, más típussal való létrehozás tovább növeli a kódméretet         /*public static bool AreEqual(int value1, int value2) => value1.Equals(value2);         public static bool AreEqual(double value1, double value2) => value1.Equals(value2);         public static bool AreEqual(string value1, string value2) => value1.Equals(value2);*/          // Metódus túlterhelés kiküszöbölése -> Generikusok         public static bool AreEqual<T>(T value1, T value2) => value1 is null ? value2 is null : value1.Equals(value2);     }      // Osztály is lehet generikus típusú, és a paraméteres konstruktora is     internal class GenericClass<T>(T value)     {         private readonly T GenericMemberVariable = value;         public T? GenericProperty { get; set; }          public T GenericMethod(T GenericParameter)         {             Console.WriteLine($"Parameter type: {typeof(T)}, Value: {GenericParameter}");             Console.WriteLine($"Return type: {typeof(T)}, Value: {GenericMemberVariable}");             return GenericMemberVariable;         }     }      // Osztály lehet generikus konstruktor megadása nélkül is     internal class NewGenericClass<T>     {         public T? Message;         public void GenericMethod(T Name, T Location)         {             Console.WriteLine($"Message: {Message}");             Console.WriteLine($"Name: {Name}");             Console.WriteLine($"Location: {Location}");         }     }      // Osztály lehet "multi-generikus" típusú     internal class GenericClass<T, U>(T Parameter1, U Parameter2)     {         public T Param1 { get; } = Parameter1;         public U Param2 { get; } = Parameter2;     }      // Megadható egyfajta korlátozás a T generikus típusra     internal class MyGenericClass<T> where T : struct     {         private T variable;          private MyGenericClass() { }          public static MyGenericClass<T> Create(T parameter)         {             MyGenericClass<T> param = new() { variable = parameter };             return param;         }          public override string ToString() => string.Format("Változó tárolt típusa: {0}, értéke: {1}", variable.GetType().Name, variable);     }      internal class Lesson5     {         public static void ProgStart()         {             var x = 10.5;             var y = 10.501;             bool IsEqual = ValueComparator.AreEqual(x, y);             Console.WriteLine(x + " = " + y + " ? -> Answer: " + (IsEqual ? "Both are Equal" : "Both are Not Equal"));              Console.WriteLine("=====================");              GenericClass<int> integerGenericClass = new(10);             int val = integerGenericClass.GenericMethod(200);             Console.WriteLine(val);              Console.WriteLine("=====================");              GenericClass<string> stringGenericClass = new("Hello Generic World") { GenericProperty = "This is a generic property example." };             // result = stringGenericClass.GenericMethod("Generic Parameter");             Console.WriteLine(stringGenericClass.GenericMethod(stringGenericClass.GenericProperty));              Console.WriteLine("====================");              NewGenericClass<string> newGenericClass = new() { Message = "Welcome to Visual Studio!" };             newGenericClass.GenericMethod("Test Name", "Hungary");              Console.WriteLine("====================");              var obj1 = new GenericClass<int, string>(100, "One Hundred");             Console.WriteLine($"{obj1.Param1} : {obj1.Param2}");             var obj2 = new GenericClass<string, string>("C# alapok", "C# Basics");             Console.WriteLine($"{obj2.Param1} : {obj2.Param2}");             var obj3 = new GenericClass<double, double>(100.25, 200.12);             Console.WriteLine($"{obj3.Param1} : {obj3.Param2}");              Console.WriteLine("====================");              MyGenericClass<int> teszt1 = MyGenericClass<int>.Create(22);             MyGenericClass<double> teszt2 = MyGenericClass<double>.Create(33.2);             MyGenericClass<char> teszt3 = MyGenericClass<char>.Create('A');             //var teszt4 = MyGenericClass<string>.Create("Teszt"); // ez nem fog működni, mert a string egy referenciatípus és nem értéktípus (struct)             Console.WriteLine(teszt1);             Console.WriteLine(teszt2);             Console.WriteLine(teszt3);              Console.ReadKey();             Environment.Exit(0);         }     } }